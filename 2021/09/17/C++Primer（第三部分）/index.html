<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    C++ primer 第三部分 (C++基础) |  
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="你又来看我了？" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-C++Primer（第三部分）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  C++ primer 第三部分 (C++基础)
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%89/" class="article-date">
  <time datetime="2021-09-17T03:45:17.027Z" itemprop="datePublished">2021-09-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">21k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">84 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>第三部分，开始！！！</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210327161629.jpg" alt="wallhaven_mdj218"></p>
<p>​    2021.3.27</p>
<a id="more"></a>

<h3 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="headerlink" title="第13章 拷贝控制"></a>第13章 拷贝控制</h3><p>一个类往往会定义五种特殊的成员函数来控制一些操作：包括拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数。</p>
<h4 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h4><p><strong>拷贝构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo();</span><br><span class="line">    	Foo(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数的第一个参数必须是一个<strong>引用类型</strong>。</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况也会发生：</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<p>当我们初始化标准库容器或是调用其<code>insert</code>或<code>push</code>成员时，容器会对其元素进行拷贝初始化，与之相对的是，用<code>emplace</code>成员创建的元素都进行直接初始化。</p>
<p>如果我们使用的初始化值要求通过一个<code>explicit</code>(指定构造函数或转换函数 (C++11起)为显式, 即它不能用于隐式转换和复制初始化)的构造函数来进行类型转化，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;<span class="comment">//错误，接受大小参数的构造函数是explicit的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br><span class="line">f(<span class="number">10</span>);<span class="comment">//错误</span></span><br><span class="line">f(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>



<p><strong>拷贝赋值运算符</strong></p>
<p>与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp;</span><br><span class="line">    Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    bookNo = rhs.bookNo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于合成拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>



<p><strong>析构函数</strong></p>
<p>构造函数初始化对象的非<code>static</code>数据成员，析构函数释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~Foo();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个析构函数中，析构部分是隐式的，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。</p>
<blockquote>
<p>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。</p>
</blockquote>
<p>智能指针是类类型，所以具有析构函数，因此与普通指针不同，只能指针成员在析构函数阶段会被自动销毁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Sales_data *p = <span class="keyword">new</span> Sales_data;</span><br><span class="line">    <span class="keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();</span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Sales_data&gt; vec;</span><br><span class="line">    vec.push_back(*p2);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;<span class="comment">//退出局部作用域;对item、p2和vec调用析构函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
</blockquote>
<p>当一个类没有定义自己的析构函数时，编译器会为它定义一个合成析构函数。</p>
<p>析构函数体自身不直接销毁成员，成员是是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象的销毁过程中，析构函数体是作为成员销毁步骤之外的一部分而进行的。</p>
<p>我们可以通过将拷贝控制成员定位为<code>=default</code>来显式地要求编译器生成合成的版本。</p>
<p>当我们在类内用<code>=default</code>修饰成员的声明时，合成的函数将隐式地声明为内联的，如果我们不希望这样，应该在成员的类外定义使用<code>=default</code>，就像对拷贝赋值运算符所做的那样。</p>
<p><strong>阻止拷贝</strong></p>
<p><code>iostream</code>类阻止了拷贝，以避免多个对象写入或读入相同的IO缓冲。</p>
<p>我们可以通过定义删除的函数<code>=delete</code>来阻止拷贝。</p>
<p>与<code>=default</code>不同，<code>=delete</code>必须出现在函数第一次声明的时候。</p>
<p>值得注意的是，我们不能删除析构函数。</p>
<p>对于具有引用成员或无法默认构造的<code>const</code>成员的类，编译器不会为其合成默认构造函数。如果一个类有<code>const</code>成员，则它不能使用合成的拷贝赋值运算符。</p>
<blockquote>
<p>本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p>
</blockquote>
<h4 id="13-2-拷贝控制和资格管理"><a href="#13-2-拷贝控制和资格管理" class="headerlink" title="13.2 拷贝控制和资格管理"></a>13.2 拷贝控制和资格管理</h4><p><strong>行为像值的类</strong></p>
<p><code>HasPtr</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        HasPtr(<span class="keyword">const</span> HasPtr&amp; p):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i)&#123;&#125;</span><br><span class="line">        HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">        ~HasPtr() &#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类值拷贝赋值运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp = rhs.ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">    ps = temp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是正确的写法，下面的编写会发生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">    ps = rhs.ps;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>rhs</code>和本对象是同一对象，<code>delete</code>操作会释放这一对象指向的<code>string</code>，接下来，我们的赋值操作就会访问一个指向无效内存的指针。</p>
<blockquote>
<p>在程序实现中，发现了这样一个问题，在上面operator=重载函数中，如果调用方式为<code>HasPtr p2 = p1;</code>，改变<code>*p1.ps = &quot;ha&quot;;</code>但是，<code>p2.ps</code>中的值没有改变。</p>
<p>如果调用方式为：<code>HasPtr p1(ptr,10),p2;</code> 和<code>p2 = p1;</code>，改变<code>*p1.ps = &quot;ha&quot;;</code>，<code>p2.ps</code>中的值会发生改变。</p>
<p>具体原因不明。</p>
</blockquote>
<p><strong>行为像指针的类</strong></p>
<p>令一个类展现类似指针的行为的最好方法是使用<code>shared_ptr</code>来管理类中的资源。</p>
<p>或者使用引用计数就很有用。但是为了不同对象中计数器的统一，一般将计数器设为指针形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">        HasPtr(<span class="keyword">const</span> HasPtr&amp; p):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i)&#123;++*use;&#125;</span><br><span class="line">        HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">        ~HasPtr() &#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr::~HasPtr() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">delete</span> ps;</span><br><span class="line">       <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use;</span><br><span class="line">    <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;<span class="comment">//递减本对象的引用次数</span></span><br><span class="line">        <span class="keyword">delete</span> ps;<span class="comment">//如果没有其他用户，释放成员</span></span><br><span class="line">        <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">    ps = rhs.ps;</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h4><p>这一章没有讲过多内容，主要介绍了<code>swap</code>函数。</p>
<p>在交换两个值的时候：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hasptr temp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = temp;</span><br></pre></td></tr></table></figure>

<p>这样的内存分配是不必要的，我们更希望是<code>swap</code>交换指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *temp = v1;</span><br><span class="line">v1.ps = v2.ps;</span><br><span class="line">v2.ps = temp;</span><br></pre></td></tr></table></figure>



<h4 id="13-4-拷贝控制示例"><a href="#13-4-拷贝控制示例" class="headerlink" title="13.4 拷贝控制示例"></a>13.4 拷贝控制示例</h4><p>这一小节主要介绍了一个<code>folder</code>和<code>message</code>的示例。</p>
<p>具体内容可以看书，在这里不做过多介绍。</p>
<h4 id="13-5-动态内存管理"><a href="#13-5-动态内存管理" class="headerlink" title="13.5 动态内存管理"></a>13.5 动态内存管理</h4><p>在这一小节，我们将实现一个类似<code>vector</code>的简化类。</p>
<p><code>StrVec</code>有三个指针成员：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210329201718.png" alt="image-20210329201711585"></p>
<p>除了指针外，<code>StrVec</code>还有一个名为<code>alloc</code>的静态成员，其类型为<code>allocator&lt;string&gt;</code>。<code>alloc</code>成员会分配<code>StrVec</code>使用的内存，此外，我们的类还有四个工具函数。</p>
<p><strong>类定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec():</span><br><span class="line">            elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">        StrVec(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">        StrVec &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">        ~StrVec();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> first_free-elements;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> cap-elements;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> elements;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> first_free;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        	</span>&#123;<span class="keyword">if</span>(size() == capacity())  reallocate();&#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>* , <span class="built_in">std</span>::<span class="built_in">string</span>*&gt; alloc_n_copy</span><br><span class="line">        (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *elements;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *first_free;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *cap;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>push_back函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>alloc_n_copy</code>成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>*&gt;</span><br><span class="line">StrVec::alloc_n_copy(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> *b, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc.allocate(e-b);</span><br><span class="line">    <span class="keyword">return</span> &#123;data, uninitialized_copy(b,e,data)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的<code>pair</code>的<code>first</code>成员指向分配的内存的开始位置，第二个成员指向最后一个构造元素之后的位置。</p>
<p><strong>free成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = first_free; p!= elements;)</span><br><span class="line">        alloc.destroy(--p);</span><br><span class="line">        alloc.deallocate(elements, cap - elements);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拷贝控制成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(<span class="keyword">const</span> StrVec &amp;s )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(s.begin(), s.end());</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StrVec::~StrVec()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>= (<span class="keyword">const</span> StrVec &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reallocate成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span>*size():<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="keyword">auto</span> dest = newdata;</span><br><span class="line">    <span class="keyword">auto</span> elem = elements;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != size(); i++)</span><br><span class="line">        alloc.construct(dest++, <span class="built_in">std</span>::move(*elem++));</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    <span class="comment">//拷贝完数据，free旧内存空间，此时的三个指针还是指向旧的内存空间</span></span><br><span class="line"></span><br><span class="line">    elements = newdata;</span><br><span class="line">    first_free = dest;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h4><p>在某种情况下，对象拷贝后就立即被销毁了，此时，移动而非拷贝对象会大幅度提升性能。</p>
<p>使用移动而不是拷贝的另一个原因源于IO类或<code>unique_ptr</code>这样的类，这些类都包含不能被共享的资源（如指针或IO缓存）。因此，这些类型的对象不能拷贝但可以移动。</p>
<blockquote>
<p>标准库容器，<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。</p>
</blockquote>
<p><strong>右值引用</strong></p>
<p>新标准引入了一种新的引用类型，我们通过&amp;&amp;而不是&amp;来获取右值引用。</p>
<p>右值引用有一个重要的性质，只能绑定到一个将要销毁的对象。</p>
<p>对于常规引用，我们可以称之为左值引用，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">//错误：不能将右值引用绑定到左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i*<span class="number">42</span>; <span class="comment">//错误：i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i *<span class="number">42</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i*<span class="number">42</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><strong>左值持久；右值短暂</strong></p>
<p>由于右值引用只能绑定到临时对象上，我们可知：</p>
<ul>
<li>所引用的对象将要被销毁。</li>
<li>该对象没有其他用户。</li>
</ul>
<p>变量是左值，因为变量是持久的，离开作用域才被销毁。因此，我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p>
<p><strong>标准库move函数</strong></p>
<p>我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<code>move</code>的新标准库函数来获取绑定到左值上的右值引用，此函数定义在头文件<code>utility</code>中。</p>
<p>调用<code>move</code>就意味着承诺：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</p>
<blockquote>
<p>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p>
</blockquote>
<p>与大多数标准库名字的使用不同，我们对<code>move</code>不提供<code>using</code>声明，我们直接调用<code>std::move</code>。</p>
<p><strong>移动构造函数和移动赋值运算符</strong></p>
<p>这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span></span><br><span class="line">    :elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">    &#123;</span><br><span class="line">        s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>noexcept</code>通知标准库我们的构造函数不抛出任何异常。</p>
<p>移动构造函数不分配任何新内存；他接管给定的<code>StrVec</code>中的内存。在接管内存之后，他将给定对象中的内存指针都置为<code>nullptr</code>。这样就完成了从给定对象的移动操作。此对象将继续存在。最终，移后源对象会被销毁。</p>
<p><code>vector</code>保证，如果调用<code>push_back</code>时发生异常，<code>vector</code>本身不会发生改变。</p>
<p>对<code>vector</code>调用<code>push_back</code>可能要求为<code>vector</code>重新分配内存空间，然后将元素从新就空间移动到新内存中。</p>
<p>如果重新分配过程中使用了移动构造函数，且移动了部分而不是全部元素后抛出一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。而拷贝构造函数可以避免这种问题。</p>
<p><strong>移动赋值函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">       <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cao = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>移动后源对象必须可析构</strong></p>
<p>从一个对象移动数据并不会销毁此对象，但有时在移动完成后，源对象会被销毁。因此，我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>
<p><strong>合成的移动操作</strong></p>
<p>与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值函数。</p>
<blockquote>
<p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认被定义为删除的。</p>
</blockquote>
<p><strong>移动右值，拷贝左值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1,v2;</span><br><span class="line">v1 = v1;	<span class="comment">//v2是左值，使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream &amp;)</span></span>;</span><br><span class="line">v2 = getVec(<span class="built_in">cin</span>);	<span class="comment">//getVec返回右值，使用移动赋值</span></span><br></pre></td></tr></table></figure>



<p>如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图调用<code>move</code>来移动它们是也是使用拷贝构造函数。</p>
<p><strong>移动迭代器</strong></p>
<p>通过标准库<code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size()?<span class="number">2</span>*size():<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="comment">//移动元素</span></span><br><span class="line">    <span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()),</span><br><span class="line">                                  make_move_iterator(end()),</span><br><span class="line">                                  first);</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = first;</span><br><span class="line">    first_free = last;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于一个移后源对象具有不确定的状态，对其调用<code>std::move</code>是危险的，当我们调用<code>move</code>时，必须绝对确定移动后源对象没有其他用户。</p>
<p><strong>右值引用和成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;<span class="comment">//拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;<span class="comment">//移动</span></span><br></pre></td></tr></table></figure>



<p>一个函数可以同时使用<code>const</code>和引用限定，在此情况下，引用限定符必须跟随在<code>const</code>限定符之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="keyword">const</span></span>;	<span class="comment">//错误</span></span><br><span class="line">    	<span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;	<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重载和引用函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    	<span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span>&amp;</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//本对象为右值，因此可以原值排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(data.begin(), data.end());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本对象是const或是一个左值，因此不能进行原值排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;	<span class="comment">//拷贝副本</span></span><br><span class="line">    sort(ret.data.begin(), ret.data.end());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个成员函数有引用限定符，则其具有相同参数列表的所有版本都必须有引用限定符。</p>
</blockquote>
<h3 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="headerlink" title="第14章 重载运算与类型转换"></a>第14章 重载运算与类型转换</h3><h4 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h4><p>重载的运算符是具有特殊名字的函数：它们的名字有关键字<code>operator</code>和其后面定义的运算符号共同组成。</p>
<p>除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p>
<p>如果一个运算符函数是成员函数，则它的第一个运算对象绑定到隐式的<code>this</code>指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。</p>
<p>对于一个运算符函数来说，或者是类的成员，或者至少含有一个类类型的参数。</p>
<p><code>int operator+(int , int);</code></p>
<p>我们只能重载已有的运算符，而无权发明新的运算符号。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210415211206.png" alt="image-20210415211159342"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);</span><br></pre></td></tr></table></figure>

<p><strong>某些运算符不应该被重载</strong></p>
<p>逻辑与运算符、或运算符和逗号逗号运算符，&amp;&amp;和||运算符不建议重载。</p>
<p><strong>成员函数</strong></p>
<p>赋值（=）、下标（[]）、调用（()）、和成员访问箭头（-&gt;）运算符必须是成员。</p>
<h4 id="14-2-输入和输出运算符"><a href="#14-2-输入和输出运算符" class="headerlink" title="14.2 输入和输出运算符"></a>14.2 输入和输出运算符</h4><p><strong>重载输出运算符&lt;&lt;</strong></p>
<p>输入运算符的第一个形参是一个非常量<code>ostream</code>对象的引用。该形参是引用是因为我们无法直接复制一个<code>ostream</code>对象。</p>
<p>第二个形参一般来说是一个常量的引用。</p>
<p>为了与其他输出运算符保持一致，<code>operator&lt;&lt;</code>一般要返回它的<code>ostream</code>形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt;  <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出运算符尽量减少格式化操作</strong></p>
<blockquote>
<p>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
</blockquote>
<p><strong>输入输出运算符必须是非成员函数</strong></p>
<p>因此，如果我们希望为类自定义IO运算符，则必须将其定义为非成员函数（否则，左侧运算符对象将是我们的类的一个对象）。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。</p>
<p><strong>重载输入运算符&gt;&gt;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream *is, Sales_data &amp;item )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span>(is)</span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        item = Sales_data();<span class="comment">//输入失败， 对象被赋予默认的状态</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</p>
</blockquote>
<p>通常情况下，输入运算符只设置<code>failbit</code>。除此之外，设置<code>eofbit</code>表示文件耗尽，而设置<code>badbit</code>表示流被破坏。最好的方式是由IO标准库自己来标示这些错误。</p>
<h4 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs; <span class="comment">//调用operator=</span></span><br><span class="line">    sum += rhs; <span class="comment">//调用+=</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相等运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">        	lhs.units_sold == rhs.units_sold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关系运算符</strong></p>
<blockquote>
<p>如果存在唯一一种逻辑可靠地&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p>
</blockquote>
<h4 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">v= &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，在创建一片新空间，不同之处是，这个运算符无需检查对象向自身的赋值。</p>
<blockquote>
<p>我们可以重载赋值运算符，无论形参的类型是什么，赋值运算符都必须定义为成员函数。</p>
</blockquote>
<h4 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h4><blockquote>
<p>下标运算符必须是成员函数。</p>
</blockquote>
<p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">        &#123;<span class="keyword">return</span> elements[n];&#125;</span><br><span class="line">    	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">        &#123;<span class="keyword">return</span> elements[n];&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> *elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h4><blockquote>
<p>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</p>
</blockquote>
<p>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果curr已经指向了容器的尾后位置，则无法递增</span></span><br><span class="line">    check(curr, <span class="string">&quot;increment past end of StrBlobPtr&quot;</span>);</span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    --curr;</span><br><span class="line">    <span class="comment">//如果curr是0，则继续递减它将产生一个无效下标</span></span><br><span class="line">    check(curr, <span class="string">&quot;decrement past end of StrBlobPtr&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>区分前置和后置运算符</strong></p>
<p>后置版本接受一个额外的（不被使用）int类型的形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">    	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了和内置版本保持一致，后置运算符应该返回对象的原值（递增递减之前的值），返回的形式是一个值而非引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无须检查有效性</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无须检查有效性</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>显式调用后置运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">//调用后置版本</span></span><br><span class="line">p.<span class="keyword">operator</span>++();<span class="comment">//调用前置版本</span></span><br></pre></td></tr></table></figure>



<h4 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = check(curr, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。</p>
</blockquote>
<h4 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h4><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象，因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;</span><br><span class="line"><span class="keyword">int</span> ui = absObj(i);</span><br></pre></td></tr></table></figure>

<p>我们将该类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">    		os(o), sep(c)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>&#123;os &lt;&lt; s&lt;&lt;sep;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	ostream &amp;os;</span><br><span class="line">    	<span class="keyword">char</span> sep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer;</span><br><span class="line">printer(s); <span class="comment">//在cout中打印s，后面跟一个空格</span></span><br><span class="line"><span class="function">PrintString <span class="title">errors</span><span class="params">(<span class="built_in">cerr</span>, <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br><span class="line">errors(s);  <span class="comment">// 在cerr中打印s，后面跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>函数对象常常作为泛型算法的实参，类似于<code>lambda</code>表达式的功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.begin(), vs.end(), PrintString(<span class="built_in">cerr</span>, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure>



<p><strong>标准库定义的函数对象</strong></p>
<p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类。例如<code>plus</code>类定义了一个函数调用运算符对一对运算对象执行+的操作。</p>
<p>这些类都被定义为模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intAdd; <span class="comment">//可执行int加法的函数对</span></span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; intNegate; <span class="comment">//可对int值取反的函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = intAdd(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">sum = intNegate(intAdd(<span class="number">10</span>,<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p>此类定义在<code>functional</code>头文件中。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210429185207.png" alt="image-20210429185130236"></p>
<p><strong>在算法中使用标准库函数对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(svec.begin(), svec.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br></pre></td></tr></table></figure>

<p>传入一个临时的函数对象用于执行两个<code>string</code>对象的<code>&gt;</code>比较运算。 </p>
<p>+</p>
<p><strong>可调用对象与function</strong></p>
<p>C++语言中有几种可调用的对象：函数、函数指针、<code>lambda</code>表达式、<code>bind</code>创建的对象（10.3节）以及重载了函数调用运算符的类。</p>
<p>两个不同类型的可调用对象却可能共享同一种调用形式，调用形式指明了调用返回的类型以及传递给调用的实参类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>是一个函数类型，它接受两个<code>int</code>，返回一个<code>int</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+ j;&#125;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i , <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i%j;&#125;;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的可调用对象共享了同一种调用形式。</p>
<p>我们希望使用这些可调用对象构建一个简单的桌面计算器，为了实现这一功能，需要定义一个寒暑表用于存储指向这些可调用对象的指针。</p>
<p>我们可以将<code>map</code>定义为如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下形式将<code>add</code>指针添加到<code>binops</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, add&#125;);</span><br></pre></td></tr></table></figure>

<p>但是我们不能将<code>mod</code>或者<code>divide</code>存入<code>binops</code>；</p>
<p>问题在于<code>mod</code>是一个<code>lambda</code>表达式，每个表达式有自己的类类型，该类型与存储在<code>binops</code>中的值类型不匹配。</p>
<p><strong>标准库function类型</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210429204530.png" alt="image-20210429204504257"></p>
<p>参考其他模板，我们在一对尖括号内指定类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以用这个新声明的类型表示任意一种桌面计算器用到的类型；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; f2(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; f3(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>利用这个<code>function</code>类型我们可以重新定义<code>map</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br></pre></td></tr></table></figure>

<p>我们可以把所有可调用对象，包括函数指针、lambda或者函数对象在内，头添加到这个<code>map</code>中、。</p>
<p><strong>重载的函数与function</strong></p>
<p>我们不能直接将重载函数的名字存入<code>function</code>类型的对象中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+ j;&#125;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>,add&#125;); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>上诉代码会导致二义性问题。解决方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span> , <span class="keyword">int</span>) = add;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;); </span><br></pre></td></tr></table></figure>

<p>存储函数指针而非函数的名字。</p>
<p>或者，也可以利用lambda表达式来指定我们希望使用的add版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>,[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> add(a, b); &#125;&#125;); </span><br></pre></td></tr></table></figure>



<h4 id="14-9-重载、类型转换和运算符"><a href="#14-9-重载、类型转换和运算符" class="headerlink" title="14.9 重载、类型转换和运算符"></a>14.9 重载、类型转换和运算符</h4><p><strong>类型转换运算符</strong></p>
<p>这是类的一种特殊成员函数，它负责将一个类类型的值转换为其他类型。类型转换函数的一般形式如下所示：</p>
<p><code>operator type() const;</code></p>
<p>其中<code>type</code>表示某种类型，类型转化运算符可以面向任意类型（除了<code>void</code>之外）进行定义，只要该类型能作为函数的返回类型，因此，我们不允许转换为数组或者函数类型，但匀速转换为指针或者引用类型。</p>
<p>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。</p>
<blockquote>
<p>一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空，类型转换函数通常应该是<code>const</code>。</p>
</blockquote>
<p>我们定义一个比较简单的类，令其表示0到255之间的一个整数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">&quot;Bad SamllInt Value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">operator</span> <span class="title">in</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数将算术类型的值转换成<code>SmallInt</code>对象，而类型转换运算符将<code>SmallInt</code>对象转换为<code>int</code>;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;</span><br><span class="line">si + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<p><strong>显式的类型转换运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line">si + <span class="number">3</span>; <span class="comment">//错误，此处需要隐式的类型转换，但类的运算符是显式的。</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;<span class="comment">//正确，显式地请求类型转换</span></span><br></pre></td></tr></table></figure>



<p><strong>避免有二义性的类型转化</strong></p>
<p>如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。</p>
<p>在下面的例子中，我们定义了两种将B转换为A的方法：一种使用B的类型转换运算符、另一个使用A的以B为参数的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">const</span> B&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = f(b);</span><br><span class="line"><span class="comment">//二义性错误：含义是f(B::operator A())，还是f(A::A(const B&amp;))</span></span><br></pre></td></tr></table></figure>

<p>如果我们想执行上述的调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = f(b.<span class="keyword">operator</span> A());</span><br><span class="line">A a2 = f(A(b));</span><br></pre></td></tr></table></figure>



<p><strong>函数匹配与重载运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line">        <span class="keyword">friend</span></span><br><span class="line">        SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	SmallInt(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br><span class="line">SmallInt s1,s2;</span><br><span class="line">SmallInt s3 = s1 + s2;</span><br><span class="line"><span class="keyword">int</span> i = s3 + <span class="number">0</span>;	<span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</p>
</blockquote>
<h3 id="第15章-面向对象程序设计"><a href="#第15章-面向对象程序设计" class="headerlink" title="第15章 面向对象程序设计"></a>第15章 面向对象程序设计</h3><h4 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h4><p><strong>继承</strong></p>
<p>先定义的一个<code>Quote</code>的类，表示按原价销售的书籍。<code>Quote</code>派生出另一个名为<code>Bulk_quote</code>的类，表示可以打折销售的书籍。</p>
<ul>
<li><code>isbn()</code>返回书籍的编号，只定义在<code>Quote</code>类中。</li>
<li><code>net_price(size_t)</code>返回书籍的实际销售价格，这个操作是类型相关的，基类和派生类都包含该函数。</li>
</ul>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过类派生列表明确指出它是从哪个基类继承而来的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态绑定</strong></p>
<p>通过使用动态绑定，我们可以通过同一段代码分别处理<code>Quote</code>和<code>Bulk_quote</code>的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_total(<span class="built_in">cout</span>, basic, <span class="number">20</span>);</span><br><span class="line">print_total(<span class="built_in">cout</span>, bulk, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//分别调用基类对象和派生类对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p>
</blockquote>
<h4 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h4><p><strong>定义基类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):</span><br><span class="line">    		bookNo(book), price(sales_price)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> n*price;&#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基类通常定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
</blockquote>
<p><strong>成员函数与继承</strong></p>
<p>​    基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数，对于前者，基类通常将其定义为<strong>虚函数</strong>，当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p>​    和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员，而受保护的成员派生类有权访问，同时禁止其他用户访问。</p>
<p><strong>定义派生类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>; <span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">    	<span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *p = &amp;bulk;</span><br><span class="line">Quote &amp;r = bulk;</span><br></pre></td></tr></table></figure>

<p>这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方，同样的道理应用于指针。</p>
<p><strong>派生类构造函数</strong></p>
<p>派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p,</span><br><span class="line">          <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">		  Quote(book, p), min_qty(qty), discount(disc)&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做，和使用基类的其他场合一样，派生类应该遵守基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
</blockquote>
<p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base::statmem();</span><br><span class="line">    Derived::statmen();</span><br><span class="line">    </span><br><span class="line">    derived_obj.statmen();</span><br><span class="line">    statmen();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不同的访问方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>派生类的声明</strong></p>
<p>派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span><span class="keyword">public</span> Quote; <span class="comment">//错误：派生列表不能出现在这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>	<span class="comment">//正确：声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>



<p><strong>防止继承的发生</strong></p>
<p>C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字<code>final</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>不存在从基类向派生类的隐式类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;	<span class="comment">//错误</span></span><br><span class="line">Bulk_quote&amp; bulkP = base;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;	<span class="comment">//使用Quote::Quote(const Quote&amp;)构造函数</span></span><br><span class="line">item = bulk;		<span class="comment">//使用Quote::operator=(const Quote&amp;)</span></span><br></pre></td></tr></table></figure>







<p>当构造<code>item</code>时，运行<code>Quote</code>的拷贝构造函数，该函数只能处理基类的两个成员，它负责拷贝<code>bulk</code>中<code>Quote</code>部分的成员，同时忽略掉<code>bulk</code>中<code>Bulk_quote</code>部分的成员，也就是说该部分被切掉了。</p>
<h4 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h4><p>当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。</p>
<p>当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。</p>
<p><strong>派生类中的虚函数</strong></p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被他覆盖的基类函数完全一致。</p>
<p>同样，派生类中虚函数的返回类型与必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用是，上述规则无效，也就是说，如果D由B派生得到，则基类的虚函数可以返回<code>B*</code>而派生类的对应函数可以返回<code>D*</code>，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。</p>
<p>如果我们使用<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p>
<blockquote>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>该代码强行调用<code>Quote</code>的<code>net_price</code>函数，而不管<code>baseP</code>实际指向的对象类型到底是什么。</p>
<h4 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h4><p>我们定义一个新的类来支持不同的折扣策略，<code>Disc_quote</code>负责保存购买量的值和折扣值。</p>
<p><strong>纯虚函数</strong></p>
<p>我们可以将<code>net_price</code>定义成纯虚函数，这样做可以告诉用户当前这个函数时没有实际意义的，我们通过在函数体的位置（即在声明语句的分号之间）书写=0就可以将一个虚函数说明为纯虚函数，其中，<code>=0</code>只能出现在类内部的虚函数声明语句处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disc_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Disc_quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">                  <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">    				Quote(book, price),</span><br><span class="line">    				quantity(qty), discount(disc)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。</p>
<blockquote>
<p>我们不能创建抽象基类的对象。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">                  <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">    			Disc_quote(book, price, qty, disc)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h4><p>受保护的成员</p>
<p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</p>
<p>和公有成员类似，受保护的成员对于派生类的成员和友元是可访问的。</p>
<p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    protect:</span><br><span class="line">    	<span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;	</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>&#123;s.j = s.prot_mem = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>公有、私有受保护的继承</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">int</span> prot_mem;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>派生访问说明符的目的是控制派生类用户对于基类成员的访问权限：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;</span><br><span class="line">d1.pub_mem(); <span class="comment">//正确</span></span><br><span class="line">Priv_Derv d2;</span><br><span class="line">d2.pub_mem(); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>并且，<code>Priv_Derv</code>的派生类无法执行类的访问，对于它们而言，继承自<code>Base</code>的所有成员都是私有的。</p>
<p>我的理解是，在派生类的定义时，派生访问说明符是没有特别作用的，只有在类使用时，比如类对象</p>
<blockquote>
<p>假定我们还定义了一个<code>Prot_Derv</code>的类，采用受保护继承，则<code>Base</code>的所有公有成员在新定义的类中都是受保护的。<code>Prot_Derv</code>的用户不能访问<code>pub_mem</code>，但是<code>Prot_Derv</code>的成员和友元可以访问那些继承而来的成员。</p>
</blockquote>
<p><strong>友元与继承</strong></p>
<p>就像友元关系不能传递一样，友元关系同样也不能继承，类似的，派生类的友元也不能随意访问基类的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;<span class="keyword">return</span> b.prot_mem;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.j;&#125; <span class="comment">//错误: Pal 不是Sneaky的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.prot_mem;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Pal&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.prot_mem; <span class="comment">//错误，友元关系不能继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能继承友元关系，每个类负责控制各自成员的访问权限。</p>
</blockquote>
<p><strong>改变个别成员的可访问性</strong></p>
<p>有时，我们需要改变派生类继承的某个名字的访问级别，通过使用<code>using</code>声明。</p>
<p><strong>继承保护级别</strong></p>
<p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的，而使用<code>struct</code>关键字定义的派生类是公有继承的。</p>
<h4 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h4><p>派生类的作用域位于基类作用域之内。</p>
<p>和其他作用域一样，派生类也能重新定义在其直接基类或间接基类中的名字，此时，定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域的名字。</p>
<blockquote>
<p>即，派生类的成员将隐藏同名的基类成员。</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
</blockquote>
<p><strong>虚函数与作用域</strong></p>
<p>如果基类与继承类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。</p>
<h4 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h4><p><strong>虚析构函数</strong></p>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Quote *item = <span class="keyword">new</span> Quote;</span><br><span class="line"><span class="keyword">delete</span> item; <span class="comment">//调用Quote的析构函数</span></span><br><span class="line">item = <span class="keyword">new</span> Bulk_quote;</span><br><span class="line"><span class="keyword">delete</span> item; <span class="comment">//调用Bulk_quote的析构函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</p>
</blockquote>
<p>之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不需要上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法因此推断基类还需要赋值运算符或拷贝构造函数。</p>
<p><strong>析构函数将阻止合成移动操作</strong></p>
<p><strong>合成拷贝控制与继承</strong></p>
<p>基类和派生类对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或校会的操作。例如：</p>
<p>合成的<code>Bulk_quote</code>默认构造函数运行<code>Disc_quote</code>的默认构造函数，后者又运行<code>Quote</code>的默认构造函数。</p>
<p><strong>派生类中删除的拷贝控制与基类的关系</strong></p>
<p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问的，则派生类中对应的成员将是被删除的。</p>
<p><strong>派生类的拷贝控制成员</strong></p>
<p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类的赋值运算符也必须为其基类部分的成员赋值。</p>
<p>​    和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。</p>
<blockquote>
<p>派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分基类部分成员在内的整个对象。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	D(<span class="keyword">const</span> D&amp; d): Base(d)<span class="comment">//拷贝基类成员</span></span><br><span class="line">            </span><br><span class="line">        D(D&amp;&amp; d):Base(<span class="built_in">std</span>::move(d))<span class="comment">//移动基类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝（或移动）构造函数。</p>
</blockquote>
<p><strong>派生类赋值运算符</strong></p>
<p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);<span class="comment">//为基类赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类成员赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>派生类析构函数</strong></p>
<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数。</p>
<p><strong>继承的构造函数</strong></p>
<p>一个类也只能继承其直接基类的构造函数，类不能继承默认、拷贝和移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span><span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">using</span> Disc_quote::Disc_quote;</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些编译器生成的构造函数形如：</p>
<p><code>derived(parms) : base(args)&#123;&#125;</code></p>
<p>其中，<code>derived</code>是派生类的名字，<code>base</code>是基类的名字，<code>parms</code>是构造函数的形参列表，<code>args</code>将派生类构造函数的形参传递给基类的构造函数。在我们的<code>Bulk_quote</code>类中，继承的构造函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">	Disc_quote(book, price, qty, disc)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>
<p>当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（ 没有默认实参），另一个构造函数只接受一个形参，对应于基类中最左侧的没有默认值的那个形参。</p>
<h4 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h4><p><strong>在容器中放置指针而非对象</strong></p>
<p>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针。和往常一样，这些指针所指向对象的动态类型可能是基类类型，也可能是派生类类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(</span><br><span class="line">    make_shared&lt;Bulk_quote&gt;(<span class="string">&quot;0-201-82470-8&quot;</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));</span><br></pre></td></tr></table></figure>

<p>可以把派生类的指针（智能）转化为基类的指针（智能）。</p>
<h3 id="第16章-模板与泛型编程"><a href="#第16章-模板与泛型编程" class="headerlink" title="第16章 模板与泛型编程"></a>第16章 模板与泛型编程</h3><h4 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h4><p><strong>函数模板</strong></p>
<p>模板定义以关键字<code>template</code>开始，后跟一个<strong>模板参数列表</strong>，这是一个逗号分隔的一个或多个模板参数的列表。</p>
<p>在模板定义中，模板参数列表不能为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//推断出T为int</span></span><br></pre></td></tr></table></figure>

<p><strong>模板类型参数</strong></p>
<p>类型参数必须使用关键字<code>class</code>和<code>typename</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误，U之前必须加上class 或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span> &gt;</span> calc(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;);</span><br><span class="line"><span class="comment">//正确，在模板参数列表中，typename和class没有什么区别。</span></span><br></pre></td></tr></table></figure>



<p><strong>非类型模板参数</strong></p>
<p>除了定义类型参数，还可以在模板中定义非类型参数，一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字<code>class</code>或<code>typename</code>来指定非类型参数。</p>
<p>我们编写一个<code>compare</code>版本处理字符串字符常量，由于希望比较不同长度的字符串字符常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>compare</code>时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>编译器会使用字面常量的大小来代替<code>N</code>和<code>M</code>，从而实例化模板，记住，编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符。</p>
<blockquote>
<p>非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>
<p>函数模板可以声明为<code>inline</code>或者<code>contexpr</code>的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误，inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板程序应该尽量减少对实参类型的要求。</p>
</blockquote>
<p>​    通常，当我们调用一个函数时，编译器只需要掌握函数的声明，类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>​    类模板则不同，为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>类模板</strong></p>
<p>与函数模板不同，编译器不能为类模板推断参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个类模板的每个实例都形成一个独立的类，类型<code>Blob&lt;string&gt;</code>与任何其他<code>Blob</code>类型都没有关联，也不会对任何其他<code>Blob</code>类型的成员有特殊访问权限。</p>
</blockquote>
<p><strong>类模板的成员函数</strong></p>
<p>​    与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p>
<p>​    类模板的成员函数具有和模板相同的模板参数，因而，定义在类模板之外的成员函数就必须以关键字<code>template</code>开始，后接类模板参数列表。</p>
<p>​    对于<code>StrBlob</code>的一个给定的成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret-type StrBlob::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>对应的<code>Blob</code>的成员应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>



<p><strong>构造函数</strong></p>
<p>与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(): data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>类模板成员函数的实例化</strong></p>
<p>如果一个成员函数没有被使用，则它不会被实例化，成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。</p>
<blockquote>
<p>默认情况下，对于一个实例化的类模板，其成员只有在使用时才被实例化。</p>
</blockquote>
<p><strong>在类代码内简化模板类名的使用</strong></p>
<p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外，在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&#123;</span></span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即，就好像我们这样编写代码一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br></pre></td></tr></table></figure>



<p><strong>类模板和友元</strong></p>
<p>​    当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例，如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== &lt;T&gt;</span><br><span class="line">        (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友好关系被限定在用相同类型实例化的<code>Blob</code>与<code>BlobPtr</code>相同运算符之间；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;</span><br></pre></td></tr></table></figure>

<p>​    <code>BlobPtr&lt;char&gt;</code>的成员可以访问<code>ca</code>(或者其他<code>Blob&lt;char&gt;</code>对象)的非<code>public</code>部分，但<code>ca</code>对<code>ia</code>(或者其他<code>Blob&lt;int&gt;</code>对象)或<code>Blob</code>的任何其他实例都没有特殊访问权限。</p>
<p>​    一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;</span><br><span class="line">    <span class="comment">//用类C实例化的Pal是C的一个友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">    <span class="comment">//Pal2的所有实例都是C的友元</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;;</span><br><span class="line">    <span class="comment">//C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">    <span class="comment">//Pal2的所有实例都是C的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> </span><br><span class="line">    <span class="comment">//Pal3是一个非模板类，是所有实例的友元，不需要Pal3的前置声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>令类型参数成为友元</strong></p>
<p>在新标准中，我们可以将模板类型参数声明为友元；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，对于某个类型名<code>Foo</code>,<code>Foo</code>将成为<code>Bar&lt;Foo&gt;</code>的友元，<code>Sales_data</code>将成为<code>Bar&lt;Sales_data&gt;</code>的友元，以此类推。</p>
<p><strong>模板类型别名</strong></p>
<p>我们可以定义一个<code>typedef</code>来引用实例化的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure>

<p>无法定义一个<code>typedef</code>引用<code>Blob&lt;T&gt;</code></p>
<p>但是，新标准允许我们为类模板定义一个类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = <span class="built_in">pair</span>&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">//authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>static成员</strong></p>
<p>与其他类相同，类模板可以声明<code>static</code>成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ctr;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>Foo</code>的实例都有其自己的<code>static</code>成员实例，即，对任意给定类型<code>X</code>，都有一个<code>Foo&lt;X&gt;::ctr</code>和一个<code>Foo&lt;X&gt;::count</code>成员。所有<code>Foo&lt;X&gt;</code>类型的对象共享相同的<code>ctr</code>对象和<code>count</code>函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi,fi2,fi3;</span><br><span class="line"><span class="comment">// 所有三个对象共享相同的`ctr`对象和`count`函数</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过类类型对象来访问一个类模板的<code>static</code>成员，也可以使用作用域运算符直接访问成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;</span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;::count();</span><br><span class="line">ct = fi.count();</span><br><span class="line">ct = Foo::count();<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>



<p><strong>模板参数</strong></p>
<p>类似函数参数的名字，我们通常将类型参数命名为<code>T</code>，但实际上我们可以使用任何名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Foo&gt; <span class="function">Foo <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Foo&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo tmp = a;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模板参数与作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A tmp = a;</span><br><span class="line">    <span class="keyword">double</span> B; <span class="comment">//错误：重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt; </span><br><span class="line"><span class="comment">//错误，非法重用模板参数名V</span></span><br></pre></td></tr></table></figure>

<p><strong>模板声明</strong></p>
<p>模板声明必需包含模板参数。</p>
<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，我们通过关键字<code>typename</code>来实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span> <span class="params">(<span class="keyword">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back():</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。</p>
</blockquote>
<p><strong>默认模板实参</strong></p>
<p>我们可以提供默认模板实参。</p>
<p>我们重写<code>compare</code>，默认使用标准库的<code>less</code>函数对象模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T&amp;v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户调用这个版本的<code>compare</code>时，可以提供自己的比较操作，但这并不是必需的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> j = compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>



<p><strong>模板默认实参与类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Numbers(T v = <span class="number">0</span>): val(V)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lot;</span><br><span class="line">Numbers&lt;&gt; av;<span class="comment">//空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>



<p><strong>成员模板</strong></p>
<p>​    一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数，这种成员被称为成员模板，成员模板不能是虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>): os(s)	&#123;&#125;</span><br><span class="line">    	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T *p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    	</span>&#123; os &lt;&lt; <span class="string">&quot;deleting&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">delete</span> p;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d;</span><br><span class="line">d(p);<span class="comment">//调用DebugDelete::operator()(double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">DebugDelete()(ip);</span><br><span class="line"><span class="comment">//在一个临时DebugDelete对象上调用DebugDelete::operator()(int*)</span></span><br></pre></td></tr></table></figure>

<p>我们可以将<code>DebugDelete</code>用作<code>unique_ptr</code>的删除器。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());</span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span><br></pre></td></tr></table></figure>



<p><strong>类模板的成员模板</strong></p>
<p>​    对于类模板，我们也可以为其定义成员模板，在此情况下，类和成员各自有自己的、独立的模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; Blob(It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在类模板外定义一个成员模板是，必须同时为类模板和成员模板挺模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::Blob(It b, It e):</span><br><span class="line">		data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e))&#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实例化与成员模板</strong></p>
<p>为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。</p>
<p>我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span><span class="params">(begin(ia), end(ia))</span></span>;</span><br><span class="line"><span class="comment">//调用了如下版本:</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt;::Blob(<span class="keyword">int</span>*, <span class="keyword">int</span>*);</span><br></pre></td></tr></table></figure>



<p><strong>控制实例化</strong></p>
<p>在大系统中，多个文件中实例化相同模板的额外开销可能非常严重，在新标准中，我们可以通过显式实例化来避免这种开销。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure>

<p><code>declaration</code>是一个类或函数声明，其中所有模板参数已被替换为模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="built_in">string</span>&gt;; <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<p>当编译器遇到<code>extern</code>模板声明时，它不会再本文件中生成实例化代码，将一个实例化声明为<code>extern</code>就表示承诺在程序其他位置有该实例化的一个非<code>extern</code>声明（定义）。对于一个给定的实例化版本，可能有多个<code>extern</code>声明，但必须只有一个定义。</p>
<blockquote>
<p>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义</p>
</blockquote>
<blockquote>
<p>在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。</p>
</blockquote>
<h4 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h4><p>从函数实参来确定模板实参的过程被称为<strong>模板实参推断</strong>。</p>
<p><strong>类型转换与模板类型参数</strong></p>
<p>在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li><code>const</code>转换：可以将一个非<code>const</code>对象的引用（或指针）传递给一个<code>const</code>的引用（或指针）形参。</li>
<li>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能用于函数模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T,T)</span></span>;		<span class="comment">// 实参拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;another val&quot;</span>)</span></span>;</span><br><span class="line">fobj(s1,s2);		<span class="comment">// 调用 fobj(string,string)，实参顶层 const 被忽略</span></span><br><span class="line">fref(s1,s2);		<span class="comment">// 调用 fref(const string&amp;,const string&amp;)，形参顶层 const 被忽略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">52</span>];</span><br><span class="line">fobj(a,b);			<span class="comment">// 调用 fobj(int*,int*);</span></span><br><span class="line">fref(a,b);			<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>如果形参是一个引用，则数组不会转换为指针，a和b的类型是不匹配的，因此调用是错误的。</p>
<blockquote>
<p>如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p>
</blockquote>
<p><strong>函数模板显式实参</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在本例中，没有任何函数实参的类型可用来推断<code>T1</code>的类型。每次调用<code>sum</code>时调用者都必须为<code>T1</code>提供一个<strong>显式模板实参</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>此调用显式指定<code>T1</code>的类型，而<code>T2</code>和<code>T3</code>的类型则由编译器推断出来。</p>
<p>​        显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br><span class="line"><span class="comment">//糟糕的设计</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">//错误，不能推断出T3模板实参</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">//正确&lt;long long, int, long&gt;分别对应 T1,T2,T3</span></span><br></pre></td></tr></table></figure>



<p><strong>正常类型转换应用于显式指定的实参</strong></p>
<p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);		  <span class="comment">//错误，模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">//正确，实例化compare(long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>如我们所见，第一个调用是错误的，因为传递给<code>compare</code>的实参必须具有相同的类型。如果我们显式指定模板类型参数，就可以进行正常类型转换了。</p>
<p><strong>尾置返回类型和类型转换</strong></p>
<p>由于尾置返回出现在参数列表之后，它可以使用函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>decltype</code>推断的类型为<code>beg</code>表示的元素的类型的引用。</p>
<p><strong>进行类型转换的标准库模板类</strong></p>
<p>为了获取元素类型，我们可以使用标准库的<strong>类型转换</strong>模板，这些模板定义在头文件<code>type_traits</code>中。</p>
<p>我们可以使用<code>remove_reference</code>来获取元素类型，<code>remove_reference</code>模板有一个模板类型参数和一个名为<code>type</code>的<code>(public)</code>类型成员。如果我们用一个引用类型实例化<code>remove_reference</code>，则<code>type</code>将表示被引用的类型。例如，如果我们实例化<code>remove_reference&lt;int&amp;&gt;</code>，则<code>type</code>成员将是<code>int</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line"><span class="comment">//将获得beg引用的元素的类型</span></span><br></pre></td></tr></table></figure>

<p><code>decltype(*beg)</code>返回元素类型的引用类型。<code>remove_reference::type</code>脱去引用，剩下元素类型本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; </span><br><span class="line">	<span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210903095629082.png" alt="image-20210903095629082"></p>
<p><strong>函数指针和实参推断</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br><span class="line"><span class="comment">//pf指向实例int compare(const int&amp;, const int&amp;) </span></span><br></pre></td></tr></table></figure>

<p><code>func</code>的重载版本，每个版本接受一个不同的函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(compare); <span class="comment">// 错误，使用compare的哪个实例？</span></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">//正确，显式模板实参消除func调用的歧义</span></span><br></pre></td></tr></table></figure>



<p><strong>模板实参推断和引用</strong></p>
<p>在[13.6 对象移动](#13.6 对象移动) 中，已经介绍过一次左值、右值引用的概念，在这里结合我自己的理解，重新梳理一遍。</p>
<p><strong>1. 左值、右值</strong></p>
<p>左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li>
<li>5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。</li>
</ul>
<p>再举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>) &#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">A a = A();</span><br></pre></td></tr></table></figure>

<ul>
<li>同样的，a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li>
<li>A()是个临时值，没法通过 &amp; 取地址，位于等号右边，所以A()是个右值。</li>
</ul>
<p>可见左右值的概念很清晰，有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<p><strong>2. 什么是左值引用、右值引用</strong></p>
<p><strong>2.1 左值引用</strong></p>
<p>左值引用大家都很熟悉，<strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>

<p><strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。</strong></p>
<p>但是，const左值引用是可以指向右值的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>

<p>const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用<code>const &amp;</code>作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<p><strong>2.2 右值引用</strong></p>
<p>再看下右值引用，右值引用的标志是<code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"> </span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>



<p><strong>2.3 右值引用有办法指向左值吗？</strong></p>
<p>有办法，<code>std::move</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>

<p>在上边的代码里，看上去是左值a通过std::move移动到了右值ref_a_right中，那是不是a里边就没有值了？并不是，打印出a的值仍然是5。</p>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong></p>
<p>同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="number">5</span>;</span><br><span class="line">ref_a = <span class="number">6</span>; </span><br><span class="line"> </span><br><span class="line">等同于以下代码：</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="built_in">std</span>::move(temp);</span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参是个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// ref_a_left是个左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// ref_a_right是个右值引用</span></span><br><span class="line"> </span><br><span class="line">    change(a); <span class="comment">// 编译不过，a是左值，change参数要求右值</span></span><br><span class="line">    change(ref_a_left); <span class="comment">// 编译不过，左值引用ref_a_left本身也是个左值</span></span><br><span class="line">    change(ref_a_right); <span class="comment">// 编译不过，右值引用ref_a_right本身也是个左值</span></span><br><span class="line">     </span><br><span class="line">    change(<span class="built_in">std</span>::move(a)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_right)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_left)); <span class="comment">// 编译通过</span></span><br><span class="line"> </span><br><span class="line">    change(<span class="number">5</span>); <span class="comment">// 当然可以直接接右值，编译通过</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    <span class="comment">// 打印这三个左值的地址，都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完后你可能有个问题，std::move会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以move返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：<strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>没有什么区别，等号左边就是左值，右边就是右值。</p>
<p>书归正传…</p>
<p><strong>从左值引用函数参数推断类型</strong></p>
<p>当一个函数参数是模板类型参数的一个普通左值引用是，规定告诉我们，只能传递给它一个左值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">f1(i); <span class="comment">//ok</span></span><br><span class="line">f1(ci); <span class="comment">// T是const int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">//错误，传递给&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果一个函数参数的类型是<code>const T&amp;</code>，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象、一个临时对象或是一个字面常量值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">f1(i); <span class="comment">// ok</span></span><br><span class="line">f1(ci); <span class="comment">// T是int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">// 一个const &amp;参数可以绑定到一个右值；T是int</span></span><br></pre></td></tr></table></figure>

<p><strong>从右值引用函数参数推断类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">//模板参数T是int</span></span><br></pre></td></tr></table></figure>



<p><strong>引用折叠</strong></p>
<p>在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X：</p>
<ul>
<li>类型<code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code></li>
<li>类型<code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code></li>
</ul>
<blockquote>
<p>引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f3(i); <span class="comment">// 实参是一个左值：模板参数T是int&amp;</span></span><br><span class="line">f3(ci); <span class="comment">// 实参是一个左值：模板参数T是const int&amp;</span></span><br><span class="line"><span class="comment">//当T是int&amp;时，函数参数为int&amp; &amp;&amp;</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp; &amp;&amp;);</span><br><span class="line"><span class="comment">//函数折叠为：</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个函数参数是指向模板参数类型的右值引用（如，T&amp;&amp;）、则可以传递给他任意类型的实参。</p>
</blockquote>
<p><strong>编写接受右值引用参数的模板函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = val;</span><br><span class="line">    t = fcn(t);</span><br><span class="line">    <span class="keyword">if</span>(val == t)</span><br><span class="line">    &#123;<span class="comment">/*    */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>当我们对一个右值调用<code>f3</code>时，例如字面常量42，<code>T</code>为<code>int</code>。当我们对<code>t</code>赋值时，参数<code>val</code>保持不变。</p>
<p>另一方面，当我们对一个左值<code>i</code>调用<code>f3</code>时，则<code>T</code>为<code>int &amp;</code>，因此，对<code>t</code>的初始化将其绑定到<code>val</code>。当我们改变<code>t</code>的值时，也同时改变了<code>val</code>的值。所以，在这个实例化版本中，<code>if</code>判断永远得到<code>true</code>。</p>
<p>使用右值引用的函数模板通常使用我们在13.6节中看到的方式来进行重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>



<p>理解 <code>std::move</code> </p>
<p><code>std::move</code> 是如何定义的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>std::move</code> 的函数参数是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。</p>
<p><code>static_cast</code>在第4节介绍过，其作用是强制类型转换。</p>
<p><strong>转发</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们希望用它调用一个接受引用参数的函数时就会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>f</code>改变了绑定到<code>v2</code>的实参的值，但是，如果我们通过<code>flip1</code>调用<code>f</code>，<code>f</code>所做的改变就不会影响实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">42</span>, i); <span class="comment">//f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">//不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于<code>j</code>被传递给<code>flip1</code>的参数<code>t1</code>。此参数是一个普通的、非引用的类型<code>int</code>，而非<code>int&amp;</code>。因此，这个<code>flip1</code>调用实例化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn)(<span class="keyword">int</span>, <span class="keyword">int</span>&amp;), <span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>j</code>的值被拷贝到<code>t1</code>中。<code>f</code>中的引用参数被绑定到<code>t1</code>，而非<code>j</code>，从而其改变不会影响<code>j</code>。</p>
<p><strong>定义能保持类型信息的函数参数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">//改变j</span></span><br></pre></td></tr></table></figure>

<p>在<code>flip2</code>中，推断出的<code>T1</code>的类型为<code>int&amp;</code>，由于是引用类型，<code>t1</code>被绑定到<code>j</code>上。调用<code>f</code>时，<code>f</code>中的引用参数<code>v2</code>被绑定到<code>t1</code>，也就是<code>j</code>上。当<code>v2</code>递增时，也同时改变了<code>j</code>的值。</p>
<blockquote>
<p>如果一个函数参数是指向模板类型参数的右值引用(如<code>T&amp;&amp;</code>)，它对应的实参的<code>const</code>属性和左值/右值属性将得到保持。</p>
</blockquote>
<p>这个版本不能用于接受右值引用参数的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flip2(g, i, <span class="number">42</span>);</span><br><span class="line"><span class="comment">//调用时， t2 是右值引用，但是t2自身是左值，所以用一个左值去实例化int&amp;&amp;是错误的</span></span><br></pre></td></tr></table></figure>



<p><strong>在调用中使用std::forward保持类型信息</strong></p>
<p>​        类似<code>move</code>，<code>forward</code>定义在头文件<code>utility</code>中。与<code>move</code>不同，<code>forward</code>必须通过显式模板实参来调用，<code>forward</code>返回该显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T2&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果我们调用<code>flip(g, i, 42)</code>，<code>i</code>将以<code>int&amp;</code>类型传递给<code>g</code>，<code>42</code>将以<code>int&amp;&amp;</code>类型传递给<code>g</code>。</p>
<h4 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h4><p>​    函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。</p>
<p><strong>编写重载模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们定义打印指针的<code>debug_rep</code>版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，此函数不能用于char*;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p; <span class="comment">//打印指针本身的值</span></span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; debug_rep(*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.str(); <span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以这样使用这些函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hi&quot;)；</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>对于这个调用，只有第一个版本的<code>debug_rep</code>是可行的。第二个<code>debug_rep</code>版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数都有可行的实例：</p>
<ul>
<li><code>debug_rep(const string*&amp;)</code>，由第一个版本实例化而来，<code>T</code>被绑定到<code>string*</code>。</li>
<li><code>debug_rep(string*)</code>，由第二个版本实例化而来 ，<code>T</code>被绑定到<code>string</code>。</li>
</ul>
<p>第二个版本的<code>debug_rep</code>的实例是此调用的精确匹配。第一个版本的实例需要进行普通指针到<code>const</code>指针的转换。正常函数匹配规则告诉我们应该选择第二个版本模板，实际上编译器确实选择了这个版本。</p>
<p><strong>多个可行模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(sp) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配：</p>
<ul>
<li><code>debug_rep(const string*&amp;)</code>，由第一个版本的<code>debug_rep</code>实例化而来，<code>T</code>被绑定到<code>string*</code></li>
<li><code>debug_rep(const string*)</code>，由第二个版本实例化而来 ，<code>T</code>被绑定到<code>const string</code>。</li>
</ul>
<p>此调用被解析为<code>debug_rep(T*)</code>，即，更特例化的版本。</p>
<p>此问题在于模板<code>debug_rep(const T&amp;)</code>本质上可以用于任何类型，包括指针类型，此模板比<code>debug_rep(T*)</code>更通用，后者只能用于指针类型。</p>
<blockquote>
<p>当有多个重载模板对一个调用提供同样好的匹配是，应选择最特例化的版本。</p>
</blockquote>
<p><strong>非模板和模板重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>debug_rep</code>时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hi&quot;)；</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>有两个同样好的可行函数：</p>
<ul>
<li><code>debug_rep&lt;string&gt;(const string*&amp;)</code>，由第一个版本的<code>debug_rep</code>实例化而来，<code>T</code>被绑定到<code>string*</code></li>
<li><code>debug_rep(const string*)</code>，普通非模板函数。</li>
</ul>
<p>编译器选择最特例化的版本，出于相同的原因，一个非模板函数比一个模板函数更好。</p>
<p><strong>重载模板和类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(<span class="string">&quot;hi world~&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>三个版本都是可行的：</p>
<p><code>debug_rep(const T&amp;)</code>，<code>T</code>被绑定到<code>char[10]</code>。</p>
<p><code>debug_rep(T*)</code>，<code>T</code>被绑定到<code>const char</code>。</p>
<p><code>debug_rep(const string&amp;)</code>要求从<code>const char*</code>到<code>string</code>的类型转换。</p>
<p>非模板版本需要进行一次用户定义的类型转换，因此没有那么好。</p>
<p><code>T*</code>版本更加特例化，编译器会选择它。</p>
<blockquote>
<p>在定义任何函数之前，记得声明所哟重载的函数版本。这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非你需要的版本。</p>
</blockquote>
<h4 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h4><p>​        一个可变参数模板就是一个接受可变数目的模板函数或模板类。可变数目的参数被称为参数包。存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Args 是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明了<code>foo</code>是一个可变参数函数模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">&quot;how&quot;</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d);</span><br><span class="line">f00(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会为<code>foo</code>实例化出不同的版本；</p>
<p><strong><code>sizeof</code>…运算符</strong></p>
<p>当我们需要知道包中有多少个元素时，可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt; void g(Args ...args)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//类型参数的数目</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编写可变参数函数模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此函数必须在可变参数版本的print之前定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变参数版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;s, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...); <span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>包扩展</strong></p>
<p>对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展。当扩展一个包时，我们还要提供每个扩展元素的模式。扩展一个包就是将它分解为构成的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;s, <span class="keyword">const</span> Args&amp;... rest)</span> <span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...);  <span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>理解包扩展</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模式表示我们希望对函数参数包<code>rest</code>中的每个元素调用<code>debug_rep</code>。与之相较，下面的模式会编译失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os, debug_rep(rest...));</span><br></pre></td></tr></table></figure>

<p>这段代码的问题是我们在<code>debug_rep</code>调用中扩展了<code>rest</code>，它等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">cerr</span>, debug_rep(fcn, code.num(),</span><br><span class="line">                     otherData, item));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展中的模式会独立地应用于包中的每个元素。</p>
</blockquote>
<p><strong>转发参数包</strong></p>
<p>我们可以组合使用可变参数模板与<code>forward</code>机制来编写函数，实现将其实参不变地传递给其他函数。</p>
<p>首先，为了保持实参中的类型信息，必须将<code>emplace_back</code>的函数参数定义为模板类型参数的右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既扩展了模板参数包<code>Args</code>，也扩展了函数参数包<code>args</code>.</p>
<p>通过在此调用中使用<code>forward</code>，我们保证如果用一个右值调用<code>emplace_back</code>，则<code>construct</code>也会得到一个右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svec.emplace_back(s1+s2);</span><br></pre></td></tr></table></figure>



<h4 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//第一个版本，可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line">compare(p1, p2); <span class="comment">//调用第一个模板</span></span><br><span class="line">compare(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>); <span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>我们无法将一个指针转换为一个数组的引用，因此当参数是<code>p1</code>和<code>p2</code>时，第二个版本的<code>compare</code>是不可行的。</p>
<p>为了处理字符指针，可以为第一个版本的<code>compare</code>定义一个<strong>模板特例化</strong>版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<p><strong>定义函数模板特例化</strong></p>
<p>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参，为了指出我们正在实例化一个模板，应使用关键字<code>template</code>后跟一个空尖括号对<code>&lt;&gt;</code>。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数重载与模板实例化</strong></p>
<p>一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</p>
<p>当我们调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对此调用，两个函数模板都是可行的。且提供同样好的匹配。但是，接收字符数组参数的版本更特例化，因此编译器会选择它。</p>
<blockquote>
<p>模板及其特例化版本应该声明在同一文件夹中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p>
</blockquote>
<p><strong>类模板特例化</strong></p>
<p>必须在原模板定义所在的空间中特例化它。为达到这一目的，首先必须打开命名空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码定义了一个能处理<code>Sales_data</code>的特例化<code>hash</code>版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Saled_data&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> Sales_data argument_type;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; s)</span><span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ </span><br><span class="line">            hash&lt;<span class="built_in">string</span>&gt;()(s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="built_in">string</span>&gt;()(s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭std命名空间；注意，花括号之后没有分号</span></span><br></pre></td></tr></table></figure>

<p>类似其他任何类，我们可以在类内或类外定义特例化版本的成员。</p>
<p>由于<code>hash&lt;Sales_data&gt;</code>使用<code>Sales_data</code>的私有成员，我们必须将它声明为<code>Sales_data</code>的友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash; <span class="comment">//友元声明所需要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了让<code>Sales_data</code>的用户能使用<code>hasn</code>的特例化版本，我们应该在<code>Sales_data</code>的头文件中定义特例化版本。</p>
</blockquote>
<p><strong>类模板部分特例化</strong></p>
<p>​        与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化本身是一个模板，使用它是用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<blockquote>
<p>我们只能部分特例化类模板，而不能部分特例化函数模板。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原始版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&gt;</span><br><span class="line">	&#123;<span class="keyword">typedef</span> T type; &#125;;<span class="comment">//左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&gt;</span><br><span class="line">	&#123;<span class="keyword">typedef</span> T type; &#125;;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>



<p>我们可以只特例化特定成员函数而不是特例化整个模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    Foo(<span class="keyword">const</span> T &amp;t = T()) : mem(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    T mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//特例化Foo&lt;int&gt;的成员Bar</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">//实例化</span></span><br><span class="line">fs.Bar();    	<span class="comment">//正常实例化</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;     <span class="comment">//实例化</span></span><br><span class="line">fi.Bar();  		<span class="comment">//使用特例化版本的Bar()</span></span><br></pre></td></tr></table></figure>



























































 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%89/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-primer/" rel="tag">C++primer</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            C++ primer 第二部分(C++基础)
          
        </div>
      </a>
    
    
      <a href="/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C++ primer 第一部分（C++基础）</div>
      </a>
    
  </nav>

   
 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> xuexue
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/head.svg" alt="你又来看我了？"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025110458.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025110312.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=27937279&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>