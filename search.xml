<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vs studio调用mkl库</title>
    <url>/2021/09/17/mkl/</url>
    <content><![CDATA[<p>最近做的项目需要在Windows环境下使用MKL库，兜兜转转好几天，终于把库的调用弄好了。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201125180123.jpg" alt="1"></p>
<a id="more"></a>

<p>首先需要下载inter编译器，然后安装，在这里不细讲具体过程了。</p>
<p>Visual Studio版本： 2019。</p>
<p>然后就是环境的调用了。</p>
<p><strong>第一步</strong></p>
<p>在vsstudio中新建一个demo.cpp，然后点击项目——属性——intel performance Library</p>
<p>在Use inter MKL处，将后面的No改为你想要的类型。在这里我选的是<code>Sequential</code></p>
<p><strong>第二步（一些电脑似乎不用）</strong></p>
<p>然后选择VC++目录</p>
<p>将可执行文件目录设置为：</p>
<p><code>C:\Program Files (x86)\IntelSWTools\compilers_and_libraries_2020.0.166\windows\redist\intel64_win\mkl</code></p>
<p>包含目录为：</p>
<p><code>C:\Program Files (x86)\IntelSWTools\compilers_and_libraries_2020.0.166\windows\mkl\include\intel64</code></p>
<p>引用目录为：</p>
<p><code>C:\Program Files (x86)\IntelSWTools\compilers_and_libraries_2020.0.166\windows\mkl\lib\intel64_win</code></p>
<p><code>C:\Program Files (x86)\IntelSWTools\compilers_and_libraries_2020.0.166\windows\compiler\lib\intel64_win</code></p>
<p>这里面的路径是针对我现在的电脑的，具体路径还需要因人而异。</p>
<p>值得注意的是：<strong>每个项目都需要重新设置一下，而且<code>debug</code>模式和<code>release</code>模式的设置也不是通用的，所以分别都需要设置一下</strong></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>MKL</tag>
        <tag>vs_studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>demo</category>
      </categories>
  </entry>
  <entry>
    <title>C++ primer 第一部分（C++基础）</title>
    <url>/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>这份笔记陆陆续续写了好几年，这段时间重新开始，愿未来可期，不负韶华。</p>
<p>​                                                                                                    2020.10.26</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201026105326.jpg" alt="1"></p>
<a id="more"></a>

<h2 id="第一部分-C-基础"><a href="#第一部分-C-基础" class="headerlink" title="第一部分 C++基础"></a>第一部分 C++基础</h2><h3 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h3><h4 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h4><p>除去布尔型和扩展型的字符型之外，其他整形都可以划分为带符号的和无符号的两种。</p>
<p>单引号括起来的一个字符称为char型字符值，双引号括起来的零个或者多个字符构成了字符串型字符。</p>
<p>（编译器在每个字符串的结束处添加一个空字符‘\0’，这就导致了字符串的实际长度比内容多1）</p>
<p><strong>转义序列：</strong></p>
<p>如果反斜杠\后面跟随的八进制数字超过3个，只有前3个数字与\构成转义序列，相反\x要用到后面所有的十六进制数字。</p>
<h4 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h4><p>始化不是赋值，初始化的含义是创建变量是赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替。</p>
<p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明，而定义负责创建与名字关联的实体。</p>
<p>如果想声明一个变量而不是定义他，就要在变量名前添加关键字extern，而且不要显式地初始化变量。</p>
<p><code>extern int i; //声明i</code></p>
<p><code>extern in i = 10; //定义i</code></p>
<p>在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p>
<p>变量只能被定义一次，但是可以被多次声明</p>
<p>C++的标识符由字母、数字和下划线构成，其中必须以下划线或者字母开头，对大小写敏感。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; <span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> reused = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	# 输出为局部变量<span class="number">0</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::reused &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	# 输出为全局变量<span class="number">42</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h4><p>C++最常用的两种复合类型：引用和指针</p>
<p>引用必须被初始化</p>
<p>因为引用不是一个对象，所以不能定义引用的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 定义指针的两种方法</span><br><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval;</span><br><span class="line"><span class="keyword">double</span> *pdd ;</span><br><span class="line">pdd = &amp;dval;</span><br></pre></td></tr></table></figure>

<p><strong>空指针</strong></p>
<p>以下给出了几种定义空指针的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要先 #include cstdlib</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>void* 是一种特殊的指针类型，可以存放任意对象的地址</p>
<p><strong>复合类型的声明</strong></p>
<p><code>int i = 1024,*p = &amp;i,&amp;r = i;</code></p>
<p>在上面这个命令中，p是一个指针，r是一个引用</p>
<p>注意：</p>
<p><code>int* p1,p2;</code></p>
<p>这样的写法很容易产生错误，因为*仅仅修饰了p1，而对p2不产生影响。</p>
<p>引用本事不是一个对象，所以不能定义指向引用的指针，但是指针是对象，所以存在对指针的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 42；</span><br><span class="line">int *p；</span><br><span class="line">int *&amp;r &#x3D; p;</span><br><span class="line">&#x2F;&#x2F; r是一个对指针p的引用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>*<em>离变量最近的符号对变量的类型有最直接的影响，因为在上面的例子中，r是一个引用。声明符的其余部分用以确定r引用的类型是什么，符号</em>说明r引用的是一个指针，最后，声明的基本数据类型说明r引用的是一个int指针**</p>
<h4 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h4><p>因为const对象一旦创建后其值就不能发生改变，所以const对象必须初始化。</p>
<p>默认情况下，const对象被设定为仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>但某些时候，有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享，对于这种变量不管是声明还是定义都添加上<code>extern</code>关键字，这样只需要定义一次就可以了。</p>
<p><strong>const的引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;</span><br><span class="line"><span class="comment">//引用及其对应的对象都是常量</span></span><br><span class="line"><span class="comment">//通常，引用的类型必须和其引用对象类型一致</span></span><br><span class="line"><span class="comment">//允许为一个常量引用绑定非常量的对象、字面值、甚至是一般表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r4 = r2 * <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>指针和const</strong></p>
<p>不能用普通指针指向常量</p>
<p>也不能给指向常量的指针赋值</p>
<p>和常量引用一样，指向常量的指针也没有规定其指向的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他路径改变。</p>
<p><strong>指针是对象，但是引用不是，所以可以把指针本身定义为常量，</strong>常量指针必须初始化，一旦初始化完成，就不能再改变了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;<span class="comment">// curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.141595</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">// pip是一个指向常量对象的常量指针</span></span><br><span class="line"><span class="comment">//pip所指的对象和pip自己的地址都不能改变</span></span><br><span class="line"><span class="comment">//相反，可以用curErr修改errNumb的值</span></span><br><span class="line">*curErr = <span class="number">0</span>；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>顶层const</strong></p>
<p>用顶层const表示指针本身是个常量，用名词底层const表示指针所指的对象是一个常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;	<span class="comment">//顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci; <span class="comment">//底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;	<span class="comment">//既有顶层const部分，又有底层const部分</span></span><br><span class="line">p2 = p3;	<span class="comment">//顶层const部分不受影响</span></span><br></pre></td></tr></table></figure>

<p><strong>constexpr和常量表达式</strong></p>
<p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明为constexpr类型。</p>
<p>尽管指针和引用都能定义为constexpr，但它们的初始值却受到严格限制，一个constexpr指针的初始值必须是nullptr或者0，或者是存储在某个固定地址中的对象。</p>
<p>如果在constexpr声明中定义一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;	<span class="comment">//p是指向整形常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;	<span class="comment">//q是指向整数的常量指针</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h4><p>类型别名是一个名字，他是某种类型的同义词。</p>
<p>有两种方法可以定义类型别名，传统方法是使用关键字typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base,*p;	<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>

<p>新规定了一种方法，使用别名声明来定义类型的别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sale_item;	<span class="comment">//SI是Sale_item的同义词</span></span><br></pre></td></tr></table></figure>

<p>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;	<span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;	<span class="comment">//ps是一个指针，他的对象是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>; <span class="comment">//和上面的式子不一样，cstr是一个指向const char的指针</span></span><br></pre></td></tr></table></figure>



<p><strong>auto类型符</strong></p>
<p>用auto可以让编译器替我们分析表达式所属的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;	<span class="comment">//item初始化为相加的结果</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;	<span class="comment">//正确，i是整型数据，p是整形指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都一样。</p>
<p>当引用被用作初始值时，此时编译器以引用对象的类型作为auto的类型。</p>
<p>auto一般会忽略顶层const，同时底层const则会保留下来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> b = ci;	<span class="comment">//b是一个整数（顶层const被忽略掉了）</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;ci;	<span class="comment">//c是一个指向整数常量的指针（底层const没有被忽略掉）</span></span><br></pre></td></tr></table></figure>

<p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。</p>
<p><strong>decltype</strong></p>
<p>希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int ci &#x3D; 0, &amp;cj &#x3D; ci; </span><br><span class="line">decltype(ci) x &#x3D; 0;	&#x2F;&#x2F;x的类型是const int</span><br><span class="line">decltype(cj) y &#x3D; x;	&#x2F;&#x2F;y的类型是const int&amp;，y绑定到变量x</span><br><span class="line">decltype(cj) z;	&#x2F;&#x2F;错误，z是一个引用必须初始化</span><br></pre></td></tr></table></figure>

<p>如果decltype使用的表达式不是一个变量，则返回表达式结果对应的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;	<span class="comment">//b是int型数据，而不是引用</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;	<span class="comment">//错误，c是引用，必须初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果给变量加上一层或者多层括号，编译器会把他当成一个表达式，双层括号的结果永远是引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;	<span class="comment">//错误，d是引用必须初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h4><p><strong>头文件保护符</strong></p>
<p><code>#ifdef</code>当且仅当变量已定义为真时</p>
<p><code>#ifndef</code>当且仅当变量未定义为真时</p>
<p>一旦检查结果为真，则实行后续操作直到遇到<code>#endif</code>指令为止。</p>
<p>注意：预处理变量无视C++语言中关于作用域的规则</p>
<p>整个程序中的预处理变量包括头文件保护符必须统一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性，为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p>
<h3 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h3><h4 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h4><p>头文件不应包含using声明</p>
<h4 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h4><p>初始化string对象的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = s2;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//把s4初始化为由n个字符c组成的串</span></span><br></pre></td></tr></table></figure>

<p><strong>直接初始化和拷贝初始化</strong></p>
<p>如果使用等号初始化一个变量，实际执行的拷贝初始化，反之，执行的是直接初始化。</p>
<p><strong>string的操作</strong></p>
<ul>
<li><code>os&lt;&lt;s</code>    将s写到输出流os当中，返回os</li>
<li><code>is&gt;&gt;s</code>    从is中读取字符串赋给s，字符串以空格分割，返回is</li>
<li><code>getline(is,s)</code>    从is中读取一行赋给s，返回is</li>
<li><code>s.empty()</code>    s为空返回true，否则false</li>
<li><code>s.size()</code>    返回s中字符串的个数</li>
</ul>
<p>用IO操作读取string对象的时候，会自动忽略开头的空白（即空格符、换行符、制表符）并从第一个真正的字符开始读起，直到遇见下一处空白为止。因此，可以多个输入或者多个输出连写在一起。</p>
<p><strong>getline</strong></p>
<p>有时候，我们希望能在得到的字符串中保留输入时的空白符，这时应该用getline函数。函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符被读进来了），然后把内容存到string对象中（不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符。</p>
<p><strong>s.size()</strong></p>
<p>返回值是一个string::size_type，它是一个无符号的值，如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免一些错误。</p>
<p><strong>string对象的比较</strong></p>
<p>如果两个string对象的长度不同，且包含内容相同，则较短的小于较长的string对象</p>
<p>如果两个string对象在某些位置不同，则string对象比较的结果就是第一对相异字符比较的结果。</p>
<p><strong>string对象相加</strong></p>
<p>当把两个string对象和字符字面值混在一条语句中使用时，必须确定每个加法运算的两侧运算对象至少有一个是string：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span> , s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + &#x27;&#x27; + s2;	//正确</span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093628.jpg" alt="image-20191204203756466"></p>
<p>C++中兼容了很多C中的库，C语言中的头文件形如<code>name.h</code>，C++将这些文件命名为<code>cname</code></p>
<p>特别的，在名为<code>cname</code>的头文件中定义的名字从属于命名空间<code>std</code>，但定义在<code>.h</code>的头文件中的则不然。</p>
<p><strong>范围for语句</strong></p>
<p>这种语句用来遍历给定序列中的每个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">&quot;some strings&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果想改变string对象中字符的值，必须把循环变量定义为引用变量。</strong></p>
<h4 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h4><p>再问头文件中做如下声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>

<p>C++既有类模板，也有函数模板，其中vector是一个类模板。在模板名字后面跟一对尖括号，在括号中放上信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; Sales_vec;	<span class="comment">//保存Sales_item类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file; <span class="comment">//该向量中的元素是vector对象</span></span><br></pre></td></tr></table></figure>

<p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector，但组成vector的元素也可以是vector。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093636.jpg" alt="image-20191204204043033"></p>
<p>当然，也可以采用列表初始化vector对象的方法，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表的初始化，而不能放在圆括号里。</p>
<p><strong>想vector对象中添加元素</strong></p>
<p>使用vector的成员函数向其添加元素，push_back负责把一个值当成vector对象的尾元素压到对象的尾端。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> word；</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">	text.push_back(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。</p>
<p><strong>vector操作</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093644.jpg" alt="image-20191204204117056"></p>
<p>同字符串的操作，只有把控制变量定义为引用类型，采用通过控制变量给vector对象赋值。</p>
<p>size函数返回的是：<code>vector&lt;int&gt;::size_type</code></p>
<p>使用下标运算符能获得到指定的元素，但是不能通过下标形式添加元素，这也说明了，只能对已存在的元素执行下标操作。</p>
<h4 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h4><p>迭代器都有名为begin和end的成员，其中begin成员负责返回指向第一个元素的迭代器，end成员返回指向容器（或string对象）尾元素的下一个位置的迭代器。</p>
<p>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
<p>因为end迭代器返回的并不实际指向某个元素，所以不能对其进行递增或者解引用操作。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093750.jpg" alt="image-20191204204142245"></p>
<p><strong>迭代器的类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;	<span class="comment">//it可以读写vector&lt;int&gt;的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;	<span class="comment">//it2能读写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;	<span class="comment">//只读</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;	<span class="comment">//只读</span></span><br></pre></td></tr></table></figure>

<p>两个新函数<code>cbegin</code>，<code>cend</code>，无论<code>vector</code>本身是否是常量，返回值都是<code>const_iterator</code>。</p>
<p><strong>解引用和成员访问</strong></p>
<p>注意如下区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*it).empty() <span class="comment">//it是一个vector对象的迭代器，解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.empty()	<span class="comment">//错误，试图访问it的empty成员，但it是个迭代器，没有empty成员</span></span><br><span class="line">it-&gt;empty() <span class="comment">//同第一个，将解引用和成员访问放在一起。</span></span><br></pre></td></tr></table></figure>

<p><strong>谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093404.jpg" alt="image-20191204204205504"></p>
<p>只有两个迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，才能进行减操作。</p>
<h4 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h4><p>数组的大小确定不变，不能随意向数组中添加元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">string</span> bad[cnt]; <span class="comment">//错误，cnt不是常量表达式</span></span><br></pre></td></tr></table></figure>

<p>定义数组的时候必须指定数组的类型，不允许auto关键字由初始值的列表推断类型。另外，数组的元素为对象，所以不存在引用的数组。</p>
<p>由定义而言，不允许用一个数组给其他数组拷贝或者赋值。但是一些编译器支持，这就是编译器的扩展。</p>
<p>数组可以有引用，但是数组不能存放引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] <span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;	<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arry;	<span class="comment">//Parray引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>

<p><strong>访问数组元素</strong></p>
<p>在使用数组下标的时候，通常将其定义为<code>size_t</code>类型，在<code>cstddef</code>头文件中定义。</p>
<p><strong>数组和指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;	<span class="comment">//ia2是一个整形指针，指向ia的第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>;	<span class="comment">//同上</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">//返回的类型是10个整数构成的指针</span></span><br></pre></td></tr></table></figure>

<p><code>iterator</code>头文件中定义了两个函数，<code>begin</code>和<code>end</code>，注意这两个函数不是成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *beg = begin(ia);</span><br><span class="line"><span class="keyword">int</span> *last = end(ia);</span><br></pre></td></tr></table></figure>

<p>如果两个指针相减，返回的是一种类型为<code>ptrdiff_t</code>的标准库类型，这是一种带符号类型。</p>
<p>数组内置的下标运算所用的索引值可以为负数。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093533.jpg" alt="image-20191204204231604"></p>
<p>此类函数的指针必须指向以空字符作为结束的标志。</p>
<p><strong>使用数组初始化vector对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr),end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h4><p>通常说的多维数组，其实是数组的数组。</p>
<p>对于，二维数组而言，通常把第一个维度称为行，第二个维度称为列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用范围for语句处理多维数组（读或者写），除了最内层的循环外，其他循环控制变量都要用引用类型</strong></p>
<p><strong>指针和多维数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>]; <span class="comment">//指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* p[<span class="number">4</span>]; <span class="comment">//整形指针的数组</span></span><br></pre></td></tr></table></figure>



<h3 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h3><h4 id="4-1基础"><a href="#4-1基础" class="headerlink" title="4.1基础"></a>4.1基础</h4><p>对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//&lt;&lt;没有明确规定如何运算对象求值</span></span><br></pre></td></tr></table></figure>



<h4 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = -b;	<span class="comment">// b2是ture</span></span><br></pre></td></tr></table></figure>

<p>所以说，布尔值一般不参与运算。</p>
<p>参与取余运算的对象必须是整数类型。</p>
<p>规定商一律向0取整。</p>
<p>一般规定，(-m)/n 和 m/(-n) 都等于 -(m/n) , m%(-n) 等于 m%n，(-m)%n 等于 -(m%n)。</p>
<h4 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : text)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">	<span class="keyword">if</span>(s.empty())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为text的元素是string对象，可能非常大，所以将s声明为引用类型可以避免对元素的拷贝；又因为不需要对元素进行写操作，所以声明为常量的引用。</p>
<h4 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(i != <span class="number">42</span>)&#123;</span><br><span class="line">	i = get_value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更为简洁的写法</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>((i = get_value()) != <span class="number">42</span>)&#123;</span><br><span class="line">	<span class="comment">//其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(beg != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">	*beg = <span class="built_in">toupper</span>(*beg++); <span class="comment">//错误：赋值运算符左右都用到了beg，而且右端还改变了beg的值，所以该运算符是未定义的</span></span><br></pre></td></tr></table></figure>



<h4 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h4><p>因为解引用的运算符的优先级低于点运算符，所以执行解引用运算符的子表达式两端必须加上括号。</p>
<p><code>(*p).size()</code></p>
<h4 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h4><p><code>cond?expr1:expr2</code></p>
<p>嵌套条件运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fall&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h4><p>关于符号位如何处理没有明确规定，所以强烈建议仅将位运算符用于处理无符号类型。</p>
<p>位求反运算符（~），与（&amp;），或（|），异或（^）运算符在两个运算对象上逐位执行相应的逻辑操作。</p>
<p>移位运算符的优先级介于中间，比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。</p>
<h4 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sale_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span> data;	<span class="comment">//data类型的大小，等同于sizeof(Sale_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p;		<span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;		<span class="comment">//p所指类型空间的大小，等同于sizeof(Sale_data)</span></span><br></pre></td></tr></table></figure>

<p>一些sizeof的说明：</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果为1；</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间大小；</li>
<li>对指针执行sizeof操作得到指针本身所占空间大小；</li>
<li>对解引用执行sizeof操作得到指针指向的对象所占空间大小，指针不需要有效。</li>
<li>对数组执行sizeof得到整个数组所占空间的大小，等价于对数组中所有元素各执行一次sizeof运算并将结果求和，注意，sizeof不会把数组转化成指针来处理。</li>
<li>对string和vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia); <span class="comment">//计算数组的大小</span></span><br></pre></td></tr></table></figure>



<h4 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h4><h4 id="4-11-类型转化"><a href="#4-11-类型转化" class="headerlink" title="4.11 类型转化"></a>4.11 类型转化</h4><p>算术转化的含义是把一种算术类型转化为另一种算术类型，其中运算符的运算对象将转化为最宽的类型。</p>
<p><strong>显示转化</strong></p>
<p>命名的强制类型转化：</p>
<p><code>cast-name&lt;type&gt;(expression)</code></p>
<p>cast-name如下：</p>
<ul>
<li>static_cast：任何具有明确定义的类型转化，只要不包含底层const，都可以使用static_cast。</li>
<li>const_cast：const_cast只能改变运算对象的底层const。</li>
<li>reinterpret_cast：不常使用。</li>
</ul>
<h3 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h3><h4 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h4><p><code>;</code>空语句</p>
<h4 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h4><h4 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h4><p><strong>switch</strong></p>
<p>case关键字和他对应的值一直被称为case标签，case标签必须是整形常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = getVal();</span><br><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3.14</span>;	<span class="comment">//错误：不是一个整数</span></span><br><span class="line">	<span class="keyword">case</span> ival;	<span class="comment">//错误：不是一个常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，我们省略掉break语句，使得程序能够连续的执行若干个case标签：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">		++vowulCnt;</span><br><span class="line">		<span class="keyword">break</span>;	<span class="comment">//统计元音字母的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>default标签</strong></p>
<p>如果没有任何一个case标签能匹配上，switch表达式的值，程序将执行紧跟在default标签后面的语句。</p>
<p>一般不要再case语句中定义变量，虽然说，不同的case在同一个作用域中（case中没有使用{}）。</p>
<h4 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h4><p><strong>for语句</strong></p>
<p>注意，for语句中可以定义多个对象，但是只能有一个声明语句。</p>
<p><strong>范围for语句</strong></p>
<p><code>for(declaration: expression)</code></p>
<p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型对象，这些类型的共同特点是拥有返回迭代器的begin和end成员。如果需要对序列中的元素执行写操作，循环变量必须声明为引用类型。</p>
<p><strong>while</strong></p>
<p>因为对于do while 来说，先执行的是语句或者块，后判断条件，所以不允许在条件部分定义变量。</p>
<h4 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h4><p><strong>break</strong></p>
<p><strong>continue</strong>：停止最近的循环中的当前迭代并立即开始下一次迭代，continue语句只能出现在for、while和do while循环的内部。</p>
<h4 id="5-6-try语句块和异常处理"><a href="#5-6-try语句块和异常处理" class="headerlink" title="5.6 try语句块和异常处理"></a>5.6 try语句块和异常处理</h4><p><strong>throw表达式：</strong>异常检测部分使用throw表达式来表示他遇到的无法处理的问题，我们说throw引发了异常。</p>
<p><strong>try语句块：</strong>异常处理部分用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch语句结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &lt;&lt; intem1 &lt;&lt; intem2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(intem1 != intem2)</span><br><span class="line">		 <span class="keyword">throw</span>.runtime_error(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(runtime_error err)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; err.what()</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型runtime_error是标准库中异常类型的一种，定义在stdexcept头文件中。</p>
<p>try语句块内部声明的变量在块的外部无法访问，特别是在catch子句内也不可以。</p>
<ul>
<li>exception头文件定义了最通用的异常类exception，它只报告异常的发生，不提供任何额外的信息。</li>
<li>stdexcept头文件定义了几种常用的异常类。</li>
<li>new头文件定义了bad_alloc异常类型。</li>
<li>type_info头文件定义了bad_cast异常类型。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201025093833.jpg" alt="image-20191222193027808"></p>
<h3 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a>第6章 函数</h3><h4 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h4><p>在函数中，即使两个形参的类型一样，也必须把两个类型都写下来。</p>
<p>函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</p>
<p><strong>局部静态对象</strong>（定义为static类型）：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。</p>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
<h4 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h4><p>当形参是引用类型时，我们说它对应的实参被引用传递。</p>
<p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，我们说这样的实参被值传递。</p>
<p><strong>指针形参：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ip = <span class="number">0</span>;	<span class="comment">// 只改变了ip的局部变量</span></span><br><span class="line">	*ip = <span class="number">0</span>;	<span class="comment">// 改变指针ip所指对象的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">	reset(&amp;i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出i = 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用形参：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ip = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">42</span>;</span><br><span class="line">reset(j);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出为0</span></span><br></pre></td></tr></table></figure>

<p>拷贝大的类类型对象或者容器对象比较低效，比如string对象可能会很长，所以应该尽量避免直接拷贝它们，使用引用形参是比较明智的方法。</p>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用。</p>
<p>如何让一个函数能返回两个值？一种方法是定义一个数据类型，另一个方法是给函数传入一个额外的引用实参，令其保存字符出现的次数。</p>
<p>和其他初始化一样，当用实参初始化形参时形参会忽略掉顶层const，形参顶层const被忽略掉了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> <span class="comment">// fcn能够读取i，但是不能向i写值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span>	<span class="comment">// 错误，重复定义了fcn(int)</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以用一个非常量初始化一个底层const对象，但是反过来不行。</p>
<p>把函数不会改变的形参定义为（普通的）引用是一种比较常见的错误。</p>
<p><code>string:: size_type find_char(string $s)</code></p>
<p>则只能将find_char作用于string对象，下面调用会发生错误：</p>
<p><code>find_char(&quot;Hello world&quot;)</code></p>
<p><strong>数组形参</strong></p>
<p>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。但是可以传递数组指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上三种print函数是等价的。</p>
<p>但是函数并不知道数组的确切尺寸，管理指针形参有三种常用方式：</p>
<p><strong>使用标记指定数组长度：</strong></p>
<p>C风格字符串最后一个字符后面跟着一个空字符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cp)</span><br><span class="line">		<span class="keyword">while</span>(*cp)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用标准库规范：</strong></p>
<p>传递指向数组首元素和尾元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *beg, <span class="keyword">const</span> <span class="keyword">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(beg != end)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *beg++ &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显示传递一个表示数组大小的形参：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[], <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j[] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">print(j,end(j) - begin(j));</span><br></pre></td></tr></table></figure>

<p>形参也可以是数组的引用，此时，引用形参绑定到对应的数组上，也就是绑定到数组上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这里的括号关系</span></span><br><span class="line">f(<span class="keyword">int</span> &amp;arr[<span class="number">10</span>]) <span class="comment">//错误：将arr声明为了引用的数组</span></span><br><span class="line">f(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>]) <span class="comment">//正确：arr是具有10个整数的整数数组的引用</span></span><br></pre></td></tr></table></figure>

<p><strong>传递多维数组：</strong></p>
<p>数组第二维（以及后面所有维度）的大小都是数组类型的一部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowsize)</span> <span class="comment">//指向含有10个整数的数组的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>]; <span class="comment">//10个指针构成的数组,错误</span></span><br></pre></td></tr></table></figure>

<p><strong>initializer_list形参：</strong></p>
<p>是一种模板类型，和vector不一样，其中的元素永远是常量值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> beg = il.begin(); beg != il.end(); ++beg)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(expected != actual)</span><br><span class="line">	error(&#123;<span class="string">&quot;function&quot;</span>,expected, actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	error(&#123;<span class="string">&quot;function&quot;</span>, <span class="string">&quot;Okey&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>包含begin和end成员，一般用范围for循环。</p>
<h4 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h4><p>通常情况下，void函数如果想在中间退出，可以用return语句。</p>
<p>注意，不要返回局部变量对象的引用或指针，函数终止意味着引用将指向不再有效的内存区域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret;</span><br><span class="line">	<span class="keyword">if</span>(!ret.empty())</span><br><span class="line">		<span class="keyword">return</span> ret;	<span class="comment">//呜呜，返回局部对象的引用</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>; <span class="comment">//错误，是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别的是，我们可以为返回类型是非常量引用的函数的结果赋值。</p>
<p><strong>列表初始化返回值：</strong></p>
<p>函数可以返回花括号包围的值的列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="string">&quot;function&quot;</span>, <span class="string">&quot;Okey&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主函数main的返回值：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (some_failture)</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line"><span class="comment">//定义在cstdlib头文件中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回数组指针：</strong></p>
<p>虽然函数不能返回数组，但是函数可以返回数组的指针或者引用。定义一个返回数组的指针或引用最直接的方法是使用类型别名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int arrT[10];</span><br><span class="line">using arrT &#x3D; int[10];</span><br><span class="line">&#x2F;&#x2F;两个等价声明，arrT是一个类型别名，表示含有10个整数的数组</span><br><span class="line">arrT* func(int i);</span><br><span class="line">&#x2F;&#x2F;或者如下声明</span><br><span class="line">int (*func(int i))[10];</span><br></pre></td></tr></table></figure>

<p><strong>尾指返回类型：</strong></p>
<p><code>auto func(int i) -&gt; int(*)[10]</code></p>
<p><strong>decltype：</strong></p>
<p>如果我们知道函数返回的指针将指向某个数组，就可以用decltype</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd :&amp;even; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decltype并不能把数组类型转化成指针，所以arrPtr返回指针必须加一个*</span></span><br></pre></td></tr></table></figure>



<h4 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h4><p>如果同一作用域内的几个函数名字相同但是形参列表不同，我们称之为重载。</p>
<p>main函数不能重载。</p>
<p>不允许两个函数除了返回类型外其他所有的要素都相同。</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lookup(<span class="keyword">int</span>);</span><br><span class="line">lookup(<span class="keyword">const</span> <span class="keyword">int</span>); <span class="comment">//重复声明</span></span><br><span class="line">lookup(<span class="keyword">int</span>*);</span><br><span class="line">lookup(<span class="keyword">int</span>* <span class="keyword">const</span>); <span class="comment">//重复声明</span></span><br><span class="line"><span class="comment">//另一方面，如果形参是某种类型的指针或者引用，则通过区分其指向的是常量还是非常量可以显示函数重载，此时const是底层的。</span></span><br><span class="line"></span><br><span class="line">lookup(<span class="keyword">int</span>&amp;);</span><br><span class="line">lookup(<span class="keyword">const</span> <span class="keyword">int</span>&amp;); <span class="comment">//新函数</span></span><br><span class="line">lookup(<span class="keyword">int</span>*);</span><br><span class="line">lookup(<span class="keyword">const</span> <span class="keyword">int</span>*); <span class="comment">//新函数</span></span><br></pre></td></tr></table></figure>

<p>在不同的作用域中无法重载函数名，在C++中，名字查找发生在类型检查之前。</p>
<h4 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h4><p><strong>默认实参：</strong></p>
<p>在函数的很多次调用中，某种形参都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参。</p>
<p>不过要注意，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。</p>
<p>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	def = <span class="string">&#x27;*&#x27;</span>;	<span class="comment">//改变了默认实参值</span></span><br><span class="line">	sz wd = <span class="number">100</span>;	<span class="comment">//隐藏了外部定义的wd,但是没有改变默认值</span></span><br><span class="line">	window = screen();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>内联函数</strong></p>
<p>将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。</p>
<p>内联机制用于优化规模较小，流程直接，频繁调用的函数。</p>
<p>在函数返回值前加上关键字inline，这样就可以将它声明为内联函数。</p>
<p><strong>constexpr函数</strong></p>
<p>函数的返回类型及所有形参的类型都是字面值类型，而且函数中有且仅有一个return。</p>
<p>constexpr函数被隐形的指定为内联函数。</p>
<p>其内部也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。</p>
<p>我们允许其返回值并非一个常量。</p>
<p><strong>assert预处理宏</strong></p>
<p>所谓预处理宏其实就是一个预处理变量，它的行为有点类似于内联函数，assert宏使用一个表达式作为它的条件。</p>
<p><code>assert(expr)</code></p>
<p>首先对express求值，如果表达式为假，输出信息并终止程序的执行，如果表达式为真，assert什么都不做。</p>
<p><strong>NDEBUG预处理变量</strong></p>
<p>如果定义了NDEBUG，则assert什么都不做。</p>
<p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试模式。</p>
<p>或者：</p>
<p><code>$ CC -D NDEBUG main.C</code></p>
<p>相当于在main.c文件的一开始写#define NDEBUG</p>
<p>预处理定义了对于程序调试很有用的：</p>
<p><code>_ _func_ _</code>：存放函数名。</p>
<p><code>_ _FILE_ _</code>：存放文件名。</p>
<p><code>_ _LINE_ _</code>：存放当前行号</p>
<p><code>_ _TIME_ _</code>：存放编译时间</p>
<p><code>_ _DATE_ _</code>：存放编译日期</p>
<h4 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h4><p>…</p>
<h4 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h4><p><code>bool lengthCompare(..)</code></p>
<p>只需要：</p>
<p><code>bool (*pf)(..)</code>//未初始化</p>
<p>即可。</p>
<p>注意:<code>bool *pf()</code>表示一个名为pf的函数，其返回值为bool*类型。</p>
<p>当我们把函数名作为一个值使用时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;<span class="comment">//等价</span></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">bool</span> b1 = pf(..);</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(..);</span><br><span class="line"><span class="keyword">bool</span> b3 = lengthCompare(..);<span class="comment">//等价</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们使用重载函数指针时，上下文必须清晰地界定到应该选那个函数。</p>
<p><strong>函数指针形参：</strong></p>
<p><code>void useB(bool pf(..));</code></p>
<p>等价于：</p>
<p><code>void useB(bool (*pf)(..));</code></p>
<p>但是这样的方法显得冗长</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> func2</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *Func2</span>;<span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useB</span><span class="params">(func2)</span></span>;<span class="comment">//自动将函数类型转化成指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useB</span><span class="params">(Func2)</span></span>;<span class="comment">//等价</span></span><br></pre></td></tr></table></figure>



<p><strong>返回指向函数指针</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);	<span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);	<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然我们也可以用直接声明</span></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//或者使用尾置返回类型</span></span><br><span class="line">auto f1(int) -&gt;int (*)(int*, int);</span><br></pre></td></tr></table></figure>

<h3 id="第7章-类"><a href="#第7章-类" class="headerlink" title="第7章 类"></a>第7章 类</h3><h4 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h4><p>改进的<code>Sales_data</code>类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Sales_data的非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义在类内部的函数是隐式的<code>inline</code>函数</p>
</blockquote>
<p>所有的成员必须在类的内部声明，但是定义可以在类外。</p>
<p><strong>代码分析：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>Sales_data</code>的<code>isbn</code>成员时传入了<code>total</code>的地址，对于我们而言，<code>this</code>形参时隐式定义的，实际上，任何自定义名为<code>this</code>的参数或变量的行为都是非法的。</p>
<p>我们可以将上述代码等价为如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNO;&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 是一个常量指针，我们不允许改变<code>this</code>中保存的地址。</p>
<p>注意，上述代码中的<code>const</code> 的作用是修改隐式<code>this</code> 指针的类型，<code>const</code>放在成员函数的参数列表之后，此时，表示<code>this</code>是一个指向常量的指针，像这样适用的<code>const</code>的成员函数被称为常量成员函数，可以把上述代码想象成如下的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNO;&#125;</span><br><span class="line"><span class="comment">//伪代码，书上的程序有点问题</span></span><br></pre></td></tr></table></figure>

<p>因为此时的<code>this</code>是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。</p>
<p>值得注意的是，即使<code>bookNo</code>定义在<code>isbn</code>之后，<code>isbn</code>也还是可以使用<code>bookNo</code>，这是因为，编译器分为两步处理，首先编译成员的声明，然后才轮到成员函数体，因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的位置。</p>
<p><strong>在类的外部定义成员函数</strong></p>
<p>类外部定义的成员的名字必须包含它所属的类名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义一个返回this对象的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用如下函数时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">total.combine(trans);</span><br></pre></td></tr></table></figure>

<p><code>total</code> 的地址被绑定在隐式的<code>this</code>参数上。</p>
<p><strong>定义类相关的非成员函数</strong></p>
<p>类的作者常常需要定义一些辅助函数，尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但他们实际上并不属于类本身。</p>
<blockquote>
<p>一般来说，如果非成员函数时类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p>
</blockquote>
<p><strong>定义read和print函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os,<span class="keyword">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price(); </span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义add函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.combine(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<p>构造函数的作用是初始化类对象的数据成员 ，无论何时只要类对象被创建，就会制成构造函数。构造函数的名字和类的名字相同，和其他函数不同的是，构造函数没有返回类型。注意，<strong>构造函数不能声明称const类型</strong>，当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能被真正取得其常量属性， 因此，构造函数在const对象的构造过程中可以向其写值。</p>
<p>一般而言，编译器会为我们隐式的定义默认构造函数，默认构造函数没有任何实参。</p>
<p><strong>定义Sales_data的构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="comment">//新的构造函数</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s)&#123;&#125;</span><br><span class="line">	Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): </span><br><span class="line">    	bookNo(s), units_sold(n),revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p><strong>在类的外部定义构造函数</strong></p>
<p>与其他几个构造函数不同，以<code>istream</code>为参数的构造函数需要一些实际的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data::Sale_data(<span class="built_in">std</span>::istream is)</span><br><span class="line">&#123;</span><br><span class="line">    read(is,*<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类的拷贝</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   Sales_data total;</span><br><span class="line">   Sales_data trans;</span><br><span class="line">total = trans;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是，管理动态内存的类不用依赖于上述操作的合成版本，但是，使用<code>vector</code>或者<code>string</code>的类能避免分配和释放内存带来的复杂性，进一步讲，如果类包含<code>vector</code>和<code>string</code>成员，则其拷贝、赋值等操作能够正常工作。</p>
</blockquote>
<h4 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h4><p>使用<strong>访问说明符</strong>加强类的封装性：</p>
<ul>
<li>定义在<code>public</code>说明符之后的成员在整个程序内可被访问</li>
<li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s)&#123;&#125;</span><br><span class="line">	Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): </span><br><span class="line">    	bookNo(s), units_sold(n),revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>class关键字</strong></p>
<p><code>class</code>和<code>struct</code> 的区别并不是很大，即访问的默认权限不太一样。</p>
<p>类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式，如果我们使用<code>struct</code> 关键字，则定义在第一个访问说明符之前的成员时<code>public</code>，<code>class</code>反之。</p>
<p><strong>友元</strong></p>
<p>类可以允许其他类或者函数访问他的非公有成员，方法是令其他类或者函数成为他的友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;	</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s)&#123;&#125;</span><br><span class="line">	Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p): bookNo(s), units_sold(n),revenue(p*n)&#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;	</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>友元声明只能出现在类定义的内部，但是在类的内部出现的具体位置不限，友元不是类的成员也不受它所在的区域访问控制级别的约束。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明以外再专门对函数进行一次声明。</p>
<blockquote>
<p>注意，声明和定义的时候，函数中常量参数的定义一定要一致，否则会出现<code>member is inaccessible</code>或者<code>is private</code>的问题，此时并不是因为我们对于公有私有的变量定义有问题，而是无法改变<code>const</code>变量导致的错误。</p>
</blockquote>
<h4 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h4><p><strong>定义一个成员函数</strong></p>
<p>类可以定义某种类型在类中的别名，用类定义的类型别名和其他成员函数一样存在访问限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        pos cursor = <span class="number">0</span>;</span><br><span class="line">        pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用等价定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> pos = <span class="built_in">std</span>::<span class="built_in">string</span>::size_type</span><br></pre></td></tr></table></figure>

<p>注意，用来定义类型的成员必须先定义后使用。</p>
<p><strong>内联函数</strong></p>
<p>定义在类内部的成员函数是自动<code>inline</code> 的，因此<code>get</code>函数默认是<code>inline</code>的。我们可以在把类内部<code>inline</code>作为声明的一部分显示地声明成员函数，同样的，也能在类的外部用<code>inline</code>关键字修饰函数的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = r * width;</span><br><span class="line">    cursor = row + c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Screen::get</span><span class="params">(pos r, pos c)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = r * width;</span><br><span class="line">    <span class="keyword">return</span> contents[row + c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重载成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">        Screen() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        Screen(pos ht, pos wd, <span class="keyword">char</span> c): height(ht), width(wd), contents(ht*wd, c)&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> contents[cursor]; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function">Screen &amp;<span class="title">move</span> <span class="params">(pos r, pos c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        pos cursor = <span class="number">0</span>;<span class="comment">//光标的位置</span></span><br><span class="line">        pos height = <span class="number">0</span>, width = <span class="number">0</span>;<span class="comment">//屏幕的长宽</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在<code>Screen</code>类中定义了两个版本的<code>get</code>函数，一个返回返回光标当前位置的字符，另一个返回行号和列号确定的位置的字符，编译器根据实参的数量来决定运行哪个版本的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen myscreen;</span><br><span class="line"><span class="keyword">char</span> ch = myscreen.get();</span><br><span class="line">ch = myscreen.get(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>可变数据成员</strong></p>
<p>有时，我们希望能修改某个数据成员，即使是在<code>const</code>成员函数内，可以通过在变量的声明中加<code>mutable</code>关键字做到这一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++access_ctr; <span class="comment">//保存一个计数器，用于记录成员函数被调用的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于任何成员函数，包括<code>const</code>函数在内都能改变它的值。</p>
<p><strong>类数据成员的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>,<span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类内初始化必须使用=的初始化形式或者花括号括起来的直接初始化形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line">    	<span class="function">Screen &amp;<span class="title">set</span><span class="params">(pos, pos, <span class="keyword">char</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contents[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    contents[r*width + col] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myScreen.move(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们令<code>move</code>和<code>set</code>返回<code>Screen</code>而非<code>Screen &amp;</code>,则上述语句的行为将大不相同。在此例中等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen temp = myScreen.move(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">temp.<span class="built_in">set</span>(‘#’);</span><br></pre></td></tr></table></figure>

<p>假如我们定义的返回类型不是引用，调用<code>set</code>只能改变临时副本，而不能改变<code>myScreen</code>的值。</p>
<p><strong>基于const的重载</strong></p>
<blockquote>
<p>一个<code>const</code>成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen myScreen;</span><br><span class="line"><span class="comment">//如果display返回常量引用，则调用set将引发错误。</span></span><br><span class="line">myScreen.display(<span class="built_in">cout</span>).<span class="built_in">set</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">//出现问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">            </span>&#123;do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">            </span>&#123;do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span> </span>&#123;os &lt;&lt; contents;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>函数解析</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>

<p>这里面第一个<code>const</code>表示函数的返回值是一个常量，后面的<code>const</code>表示<code>this</code>的常量属性，即不可以通过本函数修改<code>this</code>指向的对象（类中的成员）。</p>
<blockquote>
<p>值得注意的是<code>Screen &amp;display()</code>的写法和<code>Screen&amp; display()</code>的写法并没有差别，取决于个人习惯。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function">Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">    myscreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>).display(<span class="built_in">cout</span>);</span><br><span class="line"><span class="comment">//调用非常量版本</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    blank.display(<span class="built_in">cout</span>);</span><br><span class="line"><span class="comment">//调用常量版本</span></span><br></pre></td></tr></table></figure>

<p><strong>类类型</strong></p>
<p>对于两个类而言，即使成员完全一样，这两个类也是两个不同的类型。</p>
<p>对于一个类而言，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。</p>
<p><strong>友元类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>,<span class="number">80</span>, <span class="string">&#x27; &#x27;</span>),Screen(<span class="number">32</span>,<span class="number">60</span>, <span class="string">&#x27;*&#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">std</span>::<span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>友元关系不具有传递性。</p>
</blockquote>
<p><strong>友元函数</strong></p>
<p>我们还可以令成员函数作为友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Screen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们必须按照如下方式设计程序：</p>
<ul>
<li>首先定义<code>Window_mgr</code>类，其中声明<code>clear</code>函数，但是不能定义它。在<code>clear</code>使用<code>Screen</code> 的成员之前必须先声明<code>Screen</code>。</li>
<li>然后定义<code>Screen</code> ,包括对于<code>clear</code>的友元函数。</li>
<li>最后定义<code>clear</code>，此时它才可以使用<code>Screen</code>的成员。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">screen</span>;</span></span><br><span class="line"><span class="comment">//先声明screen，因为在Window_mgr类中使用到了screen类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">class <span class="title">Screen</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">std</span>::<span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元函数声明中时，我们隐式地假定改名字在当前作用域中是可见的。</p>
<p>甚至在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="comment">/*友元函数可以定义在类中*/</span>&#125;</span><br><span class="line">    X() &#123; f();&#125; <span class="comment">//错误</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123;<span class="function">retrun <span class="title">f</span><span class="params">()</span></span>;&#125; <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123;<span class="function">retrun <span class="title">f</span><span class="params">()</span></span>;&#125; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h4><p>每个类都会有作用域，在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen::pos ht = <span class="number">24</span>, wd = <span class="number">80</span>;</span><br><span class="line"><span class="function">Screen <span class="title">scr</span><span class="params">(ht,wd, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">Screen *p = &amp;scr;</span><br><span class="line"><span class="keyword">char</span> c = scr.get();</span><br><span class="line">c = -&gt;get();</span><br></pre></td></tr></table></figure>

<p>一个类就是一个定义域很好的说明了，为什么当我们在类的外部定义成员函数时必须提供类名和函数名。</p>
<p>我们向<code>Window_mgr</code>添加一个新的函数，它负责向显示器添加一个新的屏幕。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">        <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="keyword">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    screens.push_back(s);</span><br><span class="line">    <span class="keyword">return</span> screens.size() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的定义分为两步：</p>
<ul>
<li>首先，编译成员的声明。</li>
<li>直到类全部可见后才编译函数体。</li>
</ul>
<p><strong>类型名要特殊处理</strong></p>
<p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过，然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。即使两次定义的类型是一致的，依然会出现错误。</p>
<blockquote>
<p>类型名的定义往往出现在类的开始处，这样就能确保所有使用过该类型的成员都出现在类名的定义之后。</p>
</blockquote>
<h4 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h4><p><strong>构造函数的初始值有时必不可少</strong></p>
<p>如果数据成员是<code>const</code>或者是引用的话，必须将其初始化。类似的，如果成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。</p>
<p>随着构造函数体一开始执行，初始化就完成了，我们初始化<code>const</code>或者是引用类型的数据成员的唯一机会就是通过构造函数初始值。</p>
<p><strong>成员初始化的顺序</strong></p>
<p>成员初始化的顺序与它们在类定义中出现的顺序一致。构造函数初始化值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">x</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    x(<span class="keyword">int</span> val): j(val),i(j)&#123;&#125;</span><br><span class="line">    <span class="comment">//出现问题，i在j之前被初始化。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        事实上，<code>i</code>在<code>j</code>前被初始化，因此这个初始值的效果是试图使用未定义的值<code>j</code>初始化<code>i</code>!</p>
<blockquote>
<p>最好令构造函数初始值的顺序与声明的顺序保持一致，而且如果可能的话，尽量避免使用某些成员初始化其他成员。</p>
</blockquote>
<p><strong>委托构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">//非委托构造函数</span></span><br><span class="line">    	Sales_data(<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price):</span><br><span class="line">    	bookNo(s),units_sold(cnt),revenue(cnt*price) &#123;&#125;</span><br><span class="line">    	<span class="comment">//其余构造函数全部委托给另一个构造函数</span></span><br><span class="line">    	Sales_data(): Sales_data(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    	Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s): Sales_data(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//相当于走了第一个构造函数，然后走了第二个构造函数</span></span><br><span class="line">    	Sales_data(<span class="built_in">std</span>::istream&amp; is):Sales_data()</span><br><span class="line">        &#123;read(is, *<span class="keyword">this</span>);&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</p>
<p><strong>使用默认初始化对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; obj.isbn() ;<span class="comment">//错误，声明了一个函数而非对象</span></span><br><span class="line"></span><br><span class="line">   <span class="function">Sales_data <span class="title">obj1</span><span class="params">(<span class="string">&quot;c++&quot;</span>,<span class="number">10</span>, <span class="number">25.87</span>)</span></span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; obj1.isbn();</span><br><span class="line">   Sales_data obj2;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; obj2.isbn() ;</span><br><span class="line"><span class="comment">//正确，声明了一个对象而非函数</span></span><br></pre></td></tr></table></figure>

<p><strong>隐式的类类型转化</strong></p>
<blockquote>
<p>能够通过一条实参调用的构造函数定义一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> null_book = <span class="string">&quot;9-999-99&quot;</span>;</span><br><span class="line">Sales_data item;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//units_sold和revenue等于0</span></span><br><span class="line">item.combine(null_book);</span><br></pre></td></tr></table></figure>

<p>上述操作是合法的，编译器用给定的<code>string</code>自动创建一个<code>Sales_data</code> 对象，新生成的这个对象被传递给<code>combine</code> 。因为<code>combine</code> 的参数是一个常量引用，所以我们可以给该参数传递一个临时量。 </p>
<p>但是，值得注意的是编译器只会自动地进行一步类型转换。如下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">item.combine(<span class="string">&quot;9-999-9&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>就隐式的进行了两种转化规则，先把<code>&quot;9-999-9&quot;</code>转化为<code>string</code> ，再把这个临时的<code>string</code>转化成<code>Sales_data</code>对象。正确写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">&quot;9-999-9&quot;</span>));</span><br><span class="line">item.combine(Sales_data(<span class="string">&quot;9-999-9&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>抑制隐式转换</strong></p>
<p>关键字<code>explicit</code>只对一个实参的构造函数有效，需要多个实参的构造函数不能用于实行隐式转换，只能在类内声明构造函数时使用<code>explicit</code> 关键字，在类外部定义时不应重复。</p>
<p><strong>explicit构造函数只能用于直接初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">Sales_data item2 = null_book;</span><br><span class="line"><span class="comment">//错误，不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于<code>explicit</code>参数，我们可以使用这样的构造函数显示的强制进行转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">item.combine(Sales_data(null_book));</span><br><span class="line">item.combine(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(<span class="built_in">cin</span>));</span><br></pre></td></tr></table></figure>

<p><strong>标准库中含有显示构造函数</strong></p>
<p>接受一个单参量的<code>const char*</code>的<code>string</code>构造函数不是<code>explicit</code>的。</p>
<p>接受一个容量参数的<code>vector</code>构造函数是<code>explicit</code>的。</p>
<p><strong>聚合类</strong></p>
<ul>
<li>所有成员函数都是<code>public</code>的。</li>
<li>没有类内初始值。</li>
<li>没有定义任何构造函数。</li>
<li>没有基类，没有<code>virtual</code>函数。</li>
</ul>
<p>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;</span><br><span class="line">Data vall = &#123; <span class="number">0</span>,<span class="string">&quot;Anna&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//注意初始化顺序必须与声明一致。</span></span><br></pre></td></tr></table></figure>

<p>如果初始化列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。</p>
<p><strong>constexpr构造函数</strong></p>
<p><code>constexpr</code>构造函数必须初始化所有数据类型，初始值或者使用<code>constexpr</code>构造函数，或者是一条常量表达式。</p>
<p><code>constexpr</code>构造函数用于生成<code>contexpr</code>对象以及<code>constexpr</code>函数的参数或者返回类型。</p>
<h4 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h4><p>静态数据成员的类型可以是常量、引用、指针、类类型等。</p>
<p>静态成员函数不与任何对象绑定在一起，它们不包含<code>this</code>指针，作为结果，静态成员函数不能声明为<code>const</code>的，而且我们也不能在<code>static</code>函数中使用<code>this</code>指针，这一限制适用于<code>this</code>的显式使用，也对调用非静态成员的隐式使用有效。</p>
<p>我们可以通过作用域运算符直接访问静态成员函数。</p>
<p>虽然静态成员函数不属于类的某个对象，但是我们可以通过类的对象、引用或者指针来访问静态成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line">r = ac1.rate();</span><br><span class="line">r = ac2-&gt;rate();</span><br></pre></td></tr></table></figure>

<p>成员函数不通过作用域运算符就能直接使用静态成员。</p>
<p>我们可以在类的内部也可以在类的外部定义静态成员函数，当在外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句中。</p>
<p>类似于全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义，就将一直存在于程序的整个生命周期里。如果常量静态数据成员在类内被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
<p>静态数据成员的类型可以是它所属的类类型，而非静态数据成员则受到限制，只能声明成他所属类的指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bar</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> bar mem1;<span class="comment">//正确</span></span><br><span class="line">    	bar *mem2;<span class="comment">//正确</span></span><br><span class="line">    	bar mem3；<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员和普通成员的另一个区别就是我们可以使用静态成员作为默认实参。非静态成员则不能。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ primer 第二部分(C++基础)</title>
    <url>/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>终于看完了第一部分，今天开始第二部分的学习</p>
<p>​                                                                        2020.10.26</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201026104715.jpg" alt="v2_c2bc308ed73d97e1c27b8be03d73781c_r"></p>
<a id="more"></a>

<h2 id="第二部分-C-标准库"><a href="#第二部分-C-标准库" class="headerlink" title="第二部分 C++标准库"></a>第二部分 C++标准库</h2><h3 id="第8章-IO库"><a href="#第8章-IO库" class="headerlink" title="第8章 IO库"></a>第8章 IO库</h3><h4 id="8-1-IO类"><a href="#8-1-IO类" class="headerlink" title="8.1 IO类"></a>8.1 IO类</h4><ul>
<li><code>isteam</code>（输入流）类型</li>
<li><code>ostream</code> （输出流）类型</li>
<li><code>cin</code>一个<code>istream</code>对象</li>
<li><code>cout</code> 一个<code>ostream</code>对象</li>
<li><code>cerr</code>一个<code>ostream</code>对象，通常用于输出程序错误消息，写入到标准错误</li>
<li><code>getline</code>函数，从一个给定的<code>istream</code>读取数据到<code>string</code>对象中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201026104840.png" alt="image-20201026104840853"></p>
<p>为了支持宽字符语言，标准库定义了一组类型和对象来操作<code>wchar_t</code>类型的数据，宽字符版本的类型和函数的名字以一个<code>w</code>开始。</p>
<p>由于继承机制，类型<code>ifstream</code>和<code>istringstream</code>都继承自<code>istream</code>。因此，我们可以像使用<code>istream</code>对象一样来使用<code>ifstream</code>和<code>istringstream</code>对象。</p>
<blockquote>
<p>本节剩下部分所介绍的标准库流特征都可以无差别地应用在普通流、文件流和<code>string</code>流，以及<code>char</code>或宽字符流版本。</p>
</blockquote>
<p><strong>IO对象无拷贝或赋值</strong></p>
<p>由于不能拷贝IO对象，因此我们不能将其形参或返回类型设置为流类型，进行IO操作的函数通常以引用方式传递和返回流，读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</p>
<p><strong>条件状态</strong></p>
<p>下表列出了IO类所定义的一些函数和标志：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201026105613.png" alt="image-20201026105613422"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201026105635.png" alt="image-20201026105634978"></p>
<p>由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好的状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word )</span><br></pre></td></tr></table></figure>

<p>实际上，我们将流当做条件使用的代码就等价于<code>!fail()</code>，而<code>eof</code>和<code>bad</code>操作只能表示特定的错误。</p>
<p><strong>管理条件状态</strong></p>
<p>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，对应流当前的状态，<code>clear</code>成员是一个重载的成员，不接受参数的版本复位所有的错误标志位，执行<code>clear()</code>后，调用<code>good</code>，会返回<code>true</code>。<code>setstate</code>操作将给定的条件位置位，表示发生了相应错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记住cin当前的状态</span></span><br><span class="line"><span class="keyword">auto</span> old_state = <span class="built_in">cin</span>.rdstate();</span><br><span class="line"><span class="built_in">cin</span>.clear();	<span class="comment">//使cin有效</span></span><br><span class="line">process_input(<span class="built_in">cin</span>);	<span class="comment">//使用cin</span></span><br><span class="line"><span class="built_in">cin</span>.setstate(old_state);	<span class="comment">//将cin置为原来的状态</span></span><br></pre></td></tr></table></figure>

<p>带参数的<code>clean()</code>版本接受一个<code>iostate</code>值，表示流的新状态，下面的操作将<code>failbit</code> 和<code>badbit</code>复位，但保持<code>eofbit</code>不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.clear(<span class="built_in">cin</span>.rdstate() &amp; ~<span class="built_in">cin</span>.failbit &amp; ~<span class="built_in">cin</span>.badbit);</span><br></pre></td></tr></table></figure>

<p><strong>管理输出缓存</strong></p>
<p>每个输出流都有一个缓存区，用于存放输出的数据。</p>
<p>导致缓存区刷新的原因有很多。</p>
<ul>
<li>程序正常结束，作为<code>main</code>函数的<code>return</code>操作的一部分，缓存刷新被执行。</li>
<li>缓存区满的时候，需要刷新缓存，而后新的数据才能继续写入缓存区。</li>
<li>我们可以使用操作符如<code>endl</code>来显式刷新缓存区。</li>
<li>在每个输出操作之后，我们可以用操作符<code>unitbuf</code>设置流的内部状态，来清空缓存区，默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li>
<li>一个输出流可能被关联到另一个流，当读写被关联的流时，关联到的流的缓存区会被刷新。例如，默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此，读前两者都会导致<code>cout</code>的缓存区被刷新。</li>
</ul>
<p>类似<code>endl</code>，IO库中还有两个类似的操作符：<code>flush</code>和<code>ends</code>，<code>flush</code>刷新缓存区，但不输出任何额外的字符，<code>endl</code>向缓存区插入一个空字符，然后刷新缓存区。</p>
<p><strong>unitbuf</strong></p>
<p>如果每次输出后都想刷新缓存区，我们可以使用<code>unitbuf</code>操作符。而<code>nounitbuf</code>操作符则重置流，使其恢复使用正常的缓存区刷新机制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个程序崩溃以后，输出缓存区不会被刷新，它输出的数据很有可能停留在输出缓存区中等待打印。</p>
</blockquote>
<p><strong>关联输入流和输出流</strong></p>
<p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流，标准库将<code>cout</code>和<code>cin</code>关联在一起。<code>tie</code>有两个重载的版本，第一个版本不带参数，返回指向其关联输出流的指针（未关联则返回空指针）。<code>tie</code>的第二个版本接受一个指向<code>ostream</code>的指针，将其关联到这个输出流。<code>istream</code>和<code>ostream</code>都可以关联到另一个<code>ostream</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure>

<p>每个流同时最多关联到一个流，但多个流可以同时关联到同一个<code>ostream</code>。</p>
<h4 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h4><p>头文件<code>fstream</code>定义了三个类型来支持文件IO，<code>ifstream</code>从一个给定文件读取数据，<code>ofstream</code>写入数据，<code>fstream</code>读写文件。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201026225912.png" alt="image-20201026225911928"></p>
<p><strong>使用文件流对象</strong></p>
<p>在新C++标准中，文件名既可以是库类型<code>string</code>对象，也可以是C风格字符数组。</p>
<p>根据继承的规则，如果有一个函数接受一个<code>ostream</code>参数，我们在调用这个函数的时候，可以传递给他一个<code>ofstream</code>对象。</p>
<p><strong>成员函数open</strong></p>
<p>如果调用<code>open</code>失败，<code>failbit</code>会被置位，所以一般需要检查文件是否被正常打开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream out;</span><br><span class="line">out.open(ifile + <span class="string">&quot;.copy&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(out)</span><br><span class="line">    <span class="comment">//成功，正常使用文件</span></span><br></pre></td></tr></table></figure>

<p>在使用完文件后，关闭已经关联的文件，避免出现错误。</p>
<p><strong>自动构造和析构</strong></p>
<p><code>main</code>函数接受一个要处理的文件列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = argv + <span class="number">1</span>; p ! = argv + argc; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(input)&#123;</span><br><span class="line">        process(input);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;couldn`t open :&quot;</span> + <span class="built_in">string</span>(*p);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>input</code>是<code>for</code>循环的局部变量，在每个循环中都要创建和销毁一次，而<code>fstream</code>对象被销毁时，<code>close</code>函数会被自动调用。</p>
<p><strong>练习8.4,8.5</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream ifile;</span><br><span class="line">    ifile.open(name);</span><br><span class="line">    <span class="keyword">if</span>(ifile)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> buf;</span><br><span class="line">            <span class="keyword">while</span>(getline(ifile, buf))</span><br><span class="line">                <span class="comment">//读取文件的一行数据</span></span><br><span class="line">            vec.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream ifile;</span><br><span class="line">    ifile.open(name);</span><br><span class="line">    <span class="keyword">if</span>(ifile)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> buf;</span><br><span class="line">            <span class="keyword">while</span>(ifile &gt;&gt; buf)</span><br><span class="line">                <span class="comment">//读取文件的一个单词</span></span><br><span class="line">            vec.push_back(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    func1(<span class="string">&quot;demo.txt&quot;</span>,vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; str : vec)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func2(<span class="string">&quot;demo.txt&quot;</span>,vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; str : vec)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文件模式</strong></p>
<p>每个流都有关联的文件模式，用来指出如何使用文件。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201028204356.png" alt="image-20201028204349249"></p>
<p>无论使用哪种方式打开文件，我们都可以指定文件模式。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201028211905.png" alt="image-20201028204844631"></p>
<p>以<code>out</code>模式打开文件会丢失已有的数据。</p>
<p>保留被<code>ofstream</code>打开的文件中已有数据的唯一方法是显式指定<code>app</code>或者<code>in</code>模式。</p>
<p>每次打开文件时，都需要指定默认值。</p>
<h4 id="8-3-string流"><a href="#8-3-string流" class="headerlink" title="8.3 string流"></a>8.3 string流</h4><p><code>sstring</code>头文件定义了三种类型来支持内存IO，这类类型可以向<code>string</code>写数据，也可以向其读数据，就像一个IO流一样。<code>istringstream</code>读数据，<code>ostringstream</code>写数据，<code>stringstream</code>既可以读数据，也可以写数据。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201028211852.png" alt="image-20201028211852354"></p>
<p><strong>istringstream</strong></p>
<p>demo.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line,word;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PersonInfo&gt; people;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,line))&#123;</span><br><span class="line">        PersonInfo info;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">        record &gt;&gt; info.name;</span><br><span class="line">        <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">            info.phones.push_back(word);</span><br><span class="line">        people.push_back(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;over&quot;</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义<code>istringstream</code>对象不同位置的不同写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">istringstream</span> record;</span><br><span class="line"><span class="keyword">while</span>()</span><br><span class="line">&#123;</span><br><span class="line">    record.str(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ostringstream</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; person : people)&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> formatted, badNums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : person.phones)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!valid(num))</span><br><span class="line">        &#123;</span><br><span class="line">            badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(badNums.str().emptr())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;input error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断每个<code>person</code>的电话号码是否合法。</p>
<h3 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h3><h4 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h4><p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201108103426.png" alt="image-20201108103419545"></p>
<p><code>string</code>和<code>vector</code>将元素保存在连续的内存空间，但是，在这种容器的中间位置添加或者删除元素就会非常耗时；在一次插入或删除操作之后，需要移动插入或者删除位置以后的所有元素，来保持连续存储。</p>
<p><code>list</code>和<code>list_forward</code>两个容器的设计目的是令容器任何位置的添加和删除操作都很快速，作为代价这两个容器不支持元素的随机访问。而且，这两个容器的额外内存开销也很大。</p>
<p>一般而言，使用vector是最好的选择。</p>
<h4 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h4><p>顺序容器几乎可以保存任意类型的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; lines;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201108110813.png" alt="image-20201108110813215"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201108110906.png" alt="image-20201108110906238"></p>
<p><strong>迭代器</strong></p>
<p>迭代器范围</p>
<p><code>[begin, end)</code></p>
<p>如果<code>begin</code>和<code>end</code>相等，则范围为空。带<code>c</code>的版本返回<code>const</code>迭代器，带<code>r</code>的版本返回反向迭代器。</p>
<p>在迭代器指定的范围内查找给定的值，返回一个迭代器指向找到的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator beg, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = beg; iter != end; ++iter)</span><br><span class="line">        <span class="keyword">if</span> (*iter == value) <span class="keyword">return</span> iter;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>容器的定义和初始化</strong></p>
<p>除<code>array</code>之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</p>
<ul>
<li>直接拷贝</li>
</ul>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201216144624.png" alt="image-20201216144624260"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">forward_list&lt;<span class="built_in">string</span>&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br><span class="line"><span class="comment">// 正确，可以将const char*元素转化为string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型必须相同。</p>
</blockquote>
<ul>
<li>迭代器拷贝</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器it表示authors中的一个元素</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; <span class="title">authList</span><span class="params">(authors.begin(), it)</span></span>;</span><br><span class="line"><span class="comment">//拷贝元素，直到（但不包括）it指向的元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">&quot;MIlton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序容器大小相关的构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;hi!&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10个元素，每个都初始化为0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p>
</blockquote>
<p><strong>标准库array</strong></p>
<p>在定义一个标准库<code>array</code>时，除了指定元素类型，还要指定容器大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 42&gt;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 10&gt;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>为了使用<code>array</code>类型，我们必须指定元素类型和大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt;::size_type i;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201216152805.png" alt="image-20201216152804925"></p>
<p><strong>swap</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">swap(svec1, svec2);</span><br></pre></td></tr></table></figure>

<p>交换两个容器的操作会很快，元素本身并未交换，只是交换了两个容器的内部数据结构。</p>
<p>元素不会被移动意味着，除了<code>string</code>外，指向容器的迭代器、引用和指针在<code>swap</code>操作后都不会失效，他们仍指向操作之前所指向的那些元素，但是这些元素已经属于不同的容器了。与其他容器不同，对一个<code>string</code>调用<code>swap</code>会导致迭代器、引用和指针失效。</p>
<p>与其他容器不同，<code>swap</code>两个<code>array</code>会真正交换它们的元素，因为所需时间较长。</p>
<p><strong>容器大小操作</strong></p>
<p><code>size, emptr, max_size</code></p>
<p><code>forward_list</code>支持<code>max_size、emptr</code>但是不支持<code>size</code>。</p>
<h4 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h4><p>顺序容器和关联容器的不同之处在于两者组织关系的不同，本章主要介绍顺序容器所特有的操作。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201216160408.png" alt="image-20201216160408369"></p>
<blockquote>
<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是一个拷贝，而不对对象本身，对容器中元素的任何改变都不会影响到原始对象。</p>
</blockquote>
<p>通过使用<code>insert</code>的返回值，可以在容器中一个特定位置反复插入元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.begin();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    iter = lst.insert(iter, word);</span><br></pre></td></tr></table></figure>

<p>这个循环等价于调用<code>push_front</code></p>
<p><strong>emplace</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.emplace_back(<span class="string">&quot;911&quot;</span>,<span class="number">33</span>,<span class="number">222.2</span>);</span><br><span class="line">c.push_back(<span class="string">&quot;911&quot;</span>,<span class="number">33</span>,<span class="number">222.2</span>);<span class="comment">//错误，没有接受三个参数的push_back版本</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">&quot;911&quot;</span>,<span class="number">33</span>,<span class="number">222.2</span>));<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><code>emplace</code>函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。</p>
<blockquote>
<p>emplace函数在容器中直接构造元素，调用push则会创建一个局部临时对象，并将其压入容器中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_and_insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> some_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mid = [&amp;]&#123; <span class="keyword">return</span> v.begin() + v.size() / <span class="number">2</span>; &#125;;</span><br><span class="line">    <span class="comment">//mid相当于是动态的一个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> curr = v.begin(); curr != mid(); ++curr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*curr == some_val)</span><br><span class="line">            ++(curr = v.insert(curr, <span class="number">2</span> * some_val));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; *mid = &quot;</span> &lt;&lt; *mid() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    double_and_insert(iv, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : iv)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = iv.begin(), mid = iv.begin() + iv.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count = <span class="number">50</span>; count;   --count )</span><br><span class="line">    &#123;</span><br><span class="line">        iv.insert(iter, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity = &quot;</span> &lt;&lt; iv.capacity() &lt;&lt; <span class="string">&quot; *mid = &quot;</span> &lt;&lt; *mid &lt;&lt; <span class="string">&quot; iter = &quot;</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//新的容器大小如果大于原来的容器大小，会导致mid,iter的值改变</span></span><br><span class="line">        <span class="comment">//所以如果对容器进行插值操作，需要在每一步从新定义mid iter 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>访问元素</strong></p>
<p>每个顺序容器都有一个<code>front</code>函数，而除了<code>forward_list</code>之外的所有顺序容器都有一个<code>back</code>成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!c.emptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = *c.begin(), val2 = c.front();</span><br><span class="line">    <span class="comment">//都是c中第一个元素值的拷贝</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> val3 = *(--c.end()), val4 = c.back();</span><br><span class="line">    <span class="comment">//c中最后一个元素的拷贝</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要的是，在调用<code>front</code>和<code>back</code>之前，要确保<code>c</code>非空。</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201217145024.png" alt="image-20201217145024517"></p>
<p><strong>删除元素</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201217211015.png" alt="image-20201217211015755"></p>
<p><strong>特殊的forward_list操作</strong></p>
<p><code>forward_list</code>是单向链表，且没有定义<code>insert、emplace、erase</code>而是定义了如下的函数：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201217220019.png" alt="image-20201217212803293"></p>
<p>删除奇数的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> prev = flst.before_begin();</span><br><span class="line"><span class="keyword">auto</span> curr = flst.begin();</span><br><span class="line"><span class="keyword">while</span>(curr != flst.end())&#123;</span><br><span class="line">    <span class="keyword">if</span>(*curr % <span class="number">2</span>)</span><br><span class="line">        curr = flst.erase_after(prev);</span><br><span class="line">    	<span class="comment">//删除prev并移动curr</span></span><br><span class="line">    	<span class="comment">//因为prev原始位置的元素被删除了，所以curr仍然指向prev新位置的前一个元素</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        ++curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改变容器大小</strong></p>
<p>与往常一样，<code>array</code>不支持<code>resize</code>。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201217220009.png" alt="image-20201217220009387"></p>
<p><strong>容器操作可能使迭代器失效</strong></p>
<p>向容器添加元素后：</p>
<ul>
<li><p>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效，如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用会失效。</p>
</li>
<li><p>对于<code>deque</code>，插入到除首尾位置以外的任何位置都会导致迭代器、指针和引用失效。如果在首位位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</p>
</li>
<li><p>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效。</p>
</li>
</ul>
<p>当我们删除一个元素是，指向该元素的迭代器、指针和引用都会失效：</p>
<ul>
<li><p>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效。</p>
</li>
<li><p>对于<code>deque</code>，如果在首尾位置之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除<code>deque</code>的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</p>
</li>
<li><p>对于<code>vector</code>和<code>string</code>，指向被删除元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</p>
</li>
</ul>
<blockquote>
<p>如果循环中调用的是<code>insert</code>或<code>erase</code>,那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新。</p>
</blockquote>
<p><strong>不要保存end返回的迭代器</strong>，因为在循环中，原来的end返回的迭代器总是会失效，因此，添加或删除元素的循环程序必须反复调用end.</p>
<h4 id="9-4-vector对象时如何增长的"><a href="#9-4-vector对象时如何增长的" class="headerlink" title="9.4 vector对象时如何增长的"></a>9.4 vector对象时如何增长的</h4><p><strong>管理容器的成员函数</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201217232638.png" alt="image-20201217232638733"></p>
<p>调用<code>shrink_to_fit</code>只是一个请求，标准库并不保证退还内存。</p>
<p><img src="C:%5CUsers%5C4205%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201217233858380.png" alt="image-20201217233858380"></p>
<h4 id="9-5-额外的string操作"><a href="#9-5-额外的string操作" class="headerlink" title="9.5 额外的string操作"></a>9.5 额外的string操作</h4><p>除了与其他容器相同的构造函数，<code>string</code>类型还支持另外三个构造函数如下图：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201219160754.png" alt="image-20201219160754271"></p>
<p>从<code>const char*</code>创建<code>string</code>时，指针指向的数组必须以空字符技术。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> noNull[] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(nuNull)</span></span>; <span class="comment">//拷贝nuNull中的字符直到遇到空字符，但是nuNull不是以空字符结束，未定义</span></span><br></pre></td></tr></table></figure>

<p><strong>substr</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201219161406.png" alt="image-20201219161406697"></p>
<p><strong>其他方法</strong></p>
<p><code>string</code>类型支持顺序容器的赋值运算符以及<code>assign、insert和erase</code>操作。当然，还提供了接受下标的版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.insert(s.size(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="comment">//在s末尾插入5个感叹号</span></span><br><span class="line">s.erase(s.size() - <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//从s删除最后5个字符</span></span><br></pre></td></tr></table></figure>

<p>标准<code>string</code>类型还提供了接受C风格字符数组的<code>insert</code>和<code>assign</code>版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">&quot;Stately, plump Buck&quot;</span>;</span><br><span class="line">s.assign(cp, <span class="number">7</span>); <span class="comment">//s == &quot;Stately&quot;</span></span><br><span class="line">s.insert(s.size(), cp + <span class="number">7</span>); <span class="comment">// s == &quot;Stately, plump Buck&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>append和replace函数</strong></p>
<p><code>string</code>类定义了两种额外的成员函数：<code>append</code>和<code>replace</code>。</p>
<p>在调用<code>replace</code>时，插入的文本和删除的文本可以不一样长。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201219163159.png" alt="image-20201219163159106"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201219163216.png" alt="image-20201219163216311"></p>
<p>并不是每一种函数都支持所有形式的参数，例如，<code>insert</code>就不支持初始化列表参数。</p>
<p><strong>string搜索操作</strong></p>
<p><code>string</code>提供了6个不同的搜索函数，每个函数都有4个重载版本。如果搜索失败，则返回一个名为<code>string::npos</code>的<code>static</code>成员。标准库将<code>npos</code>定义为一个<code>const string::size_type</code>，并初始化为-1，此初始值意味着<code>npos</code>等于任何<code>string</code>最大的可能大小。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201225212720.png" alt="image-20201225212720315"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201225212734.png" alt="image-20201225212734192"></p>
<p>寻找第一个数字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string numbers(&quot;123456789&quot;), name(&quot;r2d2&quot;);</span><br><span class="line"><span class="keyword">auto</span> pos = name.find_first_of(numbers);</span><br><span class="line"><span class="comment">//每步循环查找name中每一个数</span></span><br><span class="line"><span class="built_in">string</span>::size_type pos1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((pos1 = name.find_first_of(numbers,pos)) </span><br><span class="line">      ! = <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found number at index: &quot;</span> &lt;&lt; pos</span><br><span class="line">        &lt;&lt; <span class="string">&quot; element is &quot;</span> &lt;&lt; name[pos] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>compare函数</strong></p>
<p>和C标准库的<code>strcmp</code>函数类似，根据s是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回0、正数或负数。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201225215153.png" alt="image-20201225215153112"></p>
<p><strong>数值转换</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201225215546.png" alt="image-20201225215546639"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;pi = 3.14&quot;</span>;</span><br><span class="line">d = stod(s2.substr(s2.find_first_of(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<code>string</code>不能转换为一个数组，这些函数抛出一个<code>invalid_argument</code>异常，如果转换得到的数值无法用任何类型来表示，则抛出一个<code>out_of_range</code>异常。</p>
</blockquote>
<h4 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h4><p>除了顺序容器外，标准库还定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_quene</code>，适配器是标准库中的一个通用概念。本质上，一个适配器就是一种机制，一个适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201226103702.png" alt="image-20201226103655229"></p>
<p>每个适配器都有两个构造函数：默认的构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下：<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br></pre></td></tr></table></figure>

<p><strong>栈适配器</strong></p>
<p><code>stack</code>类型定义在<code>stack</code>头文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; intStack;<span class="comment">//空栈</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> ix = <span class="number">0</span>; ix !=<span class="number">10</span>; ++ix)</span><br><span class="line">    intStack.push(ix);</span><br><span class="line"><span class="keyword">while</span>(intStack.emptr())&#123;</span><br><span class="line">    <span class="keyword">int</span> value = intStack.top();</span><br><span class="line">    intStack.pop();<span class="comment">//弹出栈顶元素，继续循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201226104820.png" alt="image-20201226104820819"></p>
<p>每个容器适配器都基于底层容器的操作定义了自己的特殊操作，我们只可以使用适配器操作，而不能使用底层容器类型的操作。</p>
<p><strong>队列适配器</strong></p>
<p><code>queue</code>和<code>priority_queue</code>适配器定义在<code>queue</code>头文件中。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201226110424.png" alt="image-20201226110424856"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20201226110434.png" alt="image-20201226110434634"></p>
<h3 id="第10章-泛函算法"><a href="#第10章-泛函算法" class="headerlink" title="第10章 泛函算法"></a>第10章 泛函算法</h3><h4 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h4><p>​        大多数算法都定义在头文件<code>algorithm</code>中，标准库还在头文件<code>numeric</code>中定义了一组数值泛函算法。</p>
<blockquote>
<p>泛函算法本身不会执行容器的操作，他们只会运行与迭代器之上，也就是说：算法永远不会改变底层容器的大小，算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>
</blockquote>
<h4 id="10-2-初识泛函算法"><a href="#10-2-初识泛函算法" class="headerlink" title="10.2 初识泛函算法"></a>10.2 初识泛函算法</h4><p>附录A按照操作方式列出了所有算法。</p>
<p><strong>只读算法</strong></p>
<p>在头文件<code>numeric</code>中，定义了一种只读算法<code>accumulate</code>，前两个指出了需要求和的元素的范围 ，第三个参数是和的初值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = accumlate(vec.cbegin(), vec.cend(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">string</span> sum  = accumlate(vec.cbegin(), vec.cend(), <span class="built_in">string</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="built_in">string</span> sum  = accumlate(vec.cbegin(), vec.cend(), <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>原因在于如果我们传递了一个字符串字面值，运用保存和的对象的类型将是const char*， 由于<code>const char*</code>没有＋操作，此调用将产生编译错误。</p>
<p><strong>写容器元素的算法</strong></p>
<p>注意确保容器序列原大小至少不小于我们要求算法写入的元素数目。</p>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。</p>
<p><strong>back_inserter</strong></p>
<p>定义在头文件<code>iterator</code>。接受一个指向容器的引用，返回一个与容器绑定的插入迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span> ,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//灾难：修改vec中的10个不存在的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec);</span><br><span class="line">*it = <span class="number">42</span>;<span class="comment">//vec中有一个元素，值为42</span></span><br><span class="line"></span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span> ,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>由于我们传递的是<code>back_inserter</code>返回的迭代器，因此每次赋值都会在<code>vec</code>上调用<code>push_back</code>。</p>
<p>对于标准算法不会改变它们所操作的容器的大小，而<code>back_inserter</code>不会使这一断言失效的解释：</p>
<p>Cause the <code>back_inserter</code> is a <strong>insert iterator</strong>, what iterator adaptor that generates an iterator that <strong>uses a container operation</strong> to add elements to a given container.</p>
<p>the algorithms don’t change the size, but the iterator can change it by using the container operation.</p>
<p><strong>拷贝算法</strong></p>
<p><code>copy</code>算法接受三个迭代器，前两个表示输入范围，第三个表示目标序列的起始位置。所以目标序列至少要包含于输入序列一样多的元素。</p>
<p><code>replace</code>算法：代替不保留</p>
<p><code>replace</code>算法：代替保留原容器</p>
<p><strong>重排容器元素的算法</strong></p>
<p>消除重复单词</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(word.begin(), word.end());</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> end_unique = unique(words.begin(),word.end());</span><br><span class="line">    <span class="comment">//使得每个单词出现一次</span></span><br><span class="line">    <span class="comment">//返回指向不重复区域之后一个位置的迭代器</span></span><br><span class="line">    </span><br><span class="line">    words.erase(end_unique, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用完<code>unique</code>后，<code>words</code>的大小并没有改变，并不删除任何元素，返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。</p>
<blockquote>
<p>标准库算法对迭代器而不是容器进行操作，因为算法不能（直接）添加或者删除元素。为了真正的删除无用元素，我们必须使用容器操作。</p>
</blockquote>
<h4 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h4><p><strong>谓词</strong>：是一个可调用的表达式，其返回结果是一个能用作条件的值。</p>
<p>标准库算法所使用的谓词分为两类：一元谓词（接受单一参数）和二元谓词（接受两个参数）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照长度排序words</span></span><br><span class="line">sort(words.begin(), words.end(), isShorter);</span><br><span class="line"><span class="comment">//按大小排序的同时，还希望相同长度的元素按字典序排列</span></span><br><span class="line">stable_sort(words.begin(), words.end(), isShorter);</span><br></pre></td></tr></table></figure>

<p><strong>lambda表达式</strong></p>
<p>我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。</p>
<p>一个<code>lambda</code>表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。其表达式如下：</p>
<p><code>[capture list](parameter list) -&gt;return type &#123;function body&#125;</code></p>
<p>其中<code>[capture list]</code>(捕获列表)是一个<code>lambda</code>所在函数中定义的局部变量的列表，通常为空。返回类型，参数列表和函数体与普通函数一样。但是，与普通函数不同的是，<code>lambda</code>必须使用尾置返回。</p>
<p>我们可以忽略参数列表和返回类型，但是必须永远包含捕获列表和函数体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//打印42</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<code>lambda</code>的函数体包含任何单一<code>return</code>语句以外的内容，且未指定返回类型，则返回<code>void</code>。</p>
</blockquote>
<p>与普通函数不同，<code>lambda</code>调用的实参数目永远与形参数目相等。</p>
<p>作为一个带参数的<code>lambda</code>的例子，我们可以编写一个与<code>isShorter</code>函数完全相同功能的<code>lambda</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span><br><span class="line">&#123;<span class="keyword">return</span> a.size() &lt; b.size()&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>lambda</code>表达式，我们可以给一元谓词的函数传递一个可调用的表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), </span><br><span class="line">              [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="keyword">return</span> a.size() &gt;= sz;&#125;);</span><br></pre></td></tr></table></figure>

<p>利用此<code>lambda</code>，我们就可以查找第一个长度大于等于<code>sz</code>的元素。</p>
<p>问题的最后一部分是打印<code>words</code>中长度大于等于<code>sz</code>的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(wc, words.end(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s )&#123;<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>捕获列表只能用于局部非<code>static</code>变量，<code>lambda</code>可以直接使用局部<code>static</code>变量和他所在函数之外声明的名字。</p>
</blockquote>
<p><strong>lambda 捕获和返回</strong></p>
<p>当定义一个<code>lambda</code>时，编译器生成一个<code>lambda</code>对应的新的类类型。</p>
<p><strong>值捕获</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]&#123;<span class="keyword">return</span> v1;&#125;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j为42</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于捕获的变量是在<code>lambda</code>创建时拷贝，因此随后对其修改不会影响到<code>lambda</code>内对应的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1]&#123;<span class="keyword">return</span> v1;&#125;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j为0</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用捕获与返回引用有着相同的问题与限制，如果我们采用引用方式捕获一个变量，就需要确保被引用的对象在<code>lambda</code>执行的时候是存在的。<code>lambda</code>捕获的都是局部变量，这些变量在函数结束后就不复存在了。</p>
<p><strong>隐式捕获</strong></p>
<p>可以让编译器根据<code>lambda</code>中的代码来推断我们要使用的变量。在捕获列表中写一个&amp;或=，&amp;表示引用捕获，=表示值捕获。</p>
<p>当然也可以采用混合捕获：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(words.begin(), words.end(), </span><br><span class="line">         [&amp;, c](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;os &lt;&lt; s &lt;&lt; c;&#125;);</span><br><span class="line"><span class="comment">//os隐式捕获，引用；c显式捕获，值捕获</span></span><br><span class="line">for_each(words.begin(), words.end(), </span><br><span class="line">         [=, &amp;os](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;os &lt;&lt; s &lt;&lt; c;&#125;);</span><br><span class="line"><span class="comment">//c隐式捕获，值；os显式捕获，引用捕获</span></span><br></pre></td></tr></table></figure>

<p>当使用了混合捕获的时候，捕获列表中的第一个元素必是一个&amp;或=。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210104225137.png" alt="image-20210104225130553"></p>
<p><strong>可变lambda</strong></p>
<p>如果我们希望改变一个被捕获的变量的值，就必须在参数列表首加上关键字<code>mutable</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j为43</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变引用捕获</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j为1</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定返回类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transform(vi.begin(),vi.end(),vi.begin(),</span><br><span class="line">         [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i:i;&#125;);</span><br><span class="line"><span class="comment">//返回绝对值，第三个参数为目的位置</span></span><br><span class="line">transform(vi.begin(),vi.end(),vi.begin(),</span><br><span class="line">         [](<span class="keyword">int</span> i)&#123;<span class="keyword">if</span>( i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br><span class="line"><span class="comment">//错误。不能推断出返回类型</span></span><br><span class="line">transform(vi.begin(),vi.end(),vi.begin(),</span><br><span class="line">         [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span></span><br><span class="line">          &#123;<span class="keyword">if</span>( i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br><span class="line"><span class="comment">//规定返回类型</span></span><br></pre></td></tr></table></figure>

<p><strong>参数绑定</strong></p>
<p>对于只在一两个地方使用的简单操作，<code>lambda</code>表达式是最有用的。</p>
<p>或者对于接受一元谓词的函数，传递给函数的可调用对象必须接受单一参数时，一般选用<code>lambda</code>表达式。</p>
<p><strong>标准库bind函数</strong></p>
<p><code>bind</code>函数定义在头文件<code>functional</code>中，可以将<code>bind</code>函数看作一个通用的函数适配器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>

<p>其中，<code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个逗号分隔的参数列表。对应给定的<code>callable</code>的参数。即，当我们调用<code>newCallable</code>时，<code>newCallable</code>会调用<code>callable</code>，并传递给它<code>arg_list</code>中的参数。</p>
<p><code>arg_list</code>中的参数可能会包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数，这些参数是占位符：<code>_1</code>为<code>newCallable</code>的第一个参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> check6 = bind(check_size, _1, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>占位符出现在第一个位置，因此调用<code>check6</code>必须传递给它一个<code>string</code>类型的参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">bool</span> b1 = check6(s);</span><br></pre></td></tr></table></figure>

<p>使用<code>bind</code>，我们可以将之前的基于<code>lambda</code>的<code>find_if</code>调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(word.begin(), word.end(), </span><br><span class="line">                  [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a));</span><br></pre></td></tr></table></figure>

<p>替换为如下版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(word.begin(), word.end(), </span><br><span class="line">                  bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>

<p>名字<code>_n</code>都定义在一个名为<code>placeholders</code>的命名空间中，而这个命名空间本身定义</p>
<p>在std命名空间。</p>
<p>声明如下；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br></pre></td></tr></table></figure>

<p>对于每个占位符，我们都必须提供一个单独的<code>using</code>声明。这样编写程序很麻烦，所以一般使用如下方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br></pre></td></tr></table></figure>

<p>与<code>bind</code>函数一样，<code>placeholders</code>命名空间也定义在<code>functional</code>头文件中。</p>
<p><strong>bind的参数</strong></p>
<p>更一般的使用方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _2, c, _1);</span><br></pre></td></tr></table></figure>

<p><code>f</code>是一个可调用对象，有5个参数；</p>
<p><code>g</code>是一个新的可调用对象，有两个参数。这两个参数分别作为第三个、第五个参数传递给<code>f</code>.</p>
<p>譬如：<code>g(X,Y)</code>相当于调用<code>f(a, b, Y, c, X)</code></p>
<p><strong>重排参数顺序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按单词长度由短至长排序</span></span><br><span class="line">sort(words.begin(), words.end(), isShorter);</span><br><span class="line"><span class="comment">//按单词长度由长至短排序</span></span><br><span class="line">sort(words.begin(), words.end(), bind(isShorter, _2, _1)) ;</span><br></pre></td></tr></table></figure>

<p><strong>绑定引用参数</strong></p>
<p>如下程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(word.begin(), word.end(), </span><br><span class="line">         bind(print, os, _1, &#x27;&#x27;));</span><br><span class="line"><span class="comment">//错误。不能拷贝一个ostream</span></span><br></pre></td></tr></table></figure>

<p>原因在于<code>bind</code>拷贝其参数，而我们不能拷贝一个<code>ostream</code>。如果我们希望传递给<code>bind</code>一个对而又不拷贝他，就必须使用标准库<code>ref</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for_each(word.begin(), word.end(), </span><br><span class="line">         bind(print, ref(os), _1, &#39;&#39;));</span><br></pre></td></tr></table></figure>

<p>标准库中还有一个<code>cref</code>函数，生成一个保存<code>const</code>引用的类。这两个函数定义在头文件<code>functional</code>中。</p>
<h4 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h4><p>除了为每个容器定义的迭代器，标准库在头文件<code>iterator</code>中还定义了额外几种迭代器。</p>
<ul>
<li><strong>插入迭代器</strong>：这些迭代器被绑定在一个容器上，可用来向容器中插入元素。</li>
<li><strong>流迭代器：</strong>这些迭代器被绑定在输入或输出流上，可用来遍历所有关联的IO流。</li>
<li><strong>反向迭代器：</strong>这些迭代器向后而不是向前移动，除了<code>forward_list</code>之外的标准库容器都有反向迭代器。</li>
<li><strong>移动迭代器：</strong>这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li>
</ul>
<p><strong>插入迭代器</strong></p>
<p>插入器</p>
<p>是一种迭代器适配器，它接受一个容器，生成一个迭代器。</p>
<p>插入器有三种，差异在于元素插入的位置：</p>
<ul>
<li><strong>back_inserter</strong> 创建一个使用<code>push_back</code>的迭代器。</li>
<li><strong>front_inserter</strong> 创建一个使用<code>push_front</code>的迭代器。</li>
<li><strong>inserter</strong>创建一个使用<code>insert</code>的迭代器，此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器，元素将被插入到给定迭代器所表示的元素之前。</li>
</ul>
<p>差别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// uses inserter</span></span><br><span class="line"><span class="comment">// 1 2 3 4 ..</span></span><br><span class="line">   <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst1;</span><br><span class="line">   copy(vec.cbegin(), vec.cend(), inserter(lst1, lst1.begin()));</span><br><span class="line">   print(lst1);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// uses back_inserter</span></span><br><span class="line"><span class="comment">// 1 2 3 4 ..</span></span><br><span class="line">   <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lit2;</span><br><span class="line">   copy(vec.cbegin(), vec.cend(), back_inserter(lit2));</span><br><span class="line">   print(lit2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// uses front_inserter</span></span><br><span class="line"><span class="comment">// 9 8 7 6 ..</span></span><br><span class="line">   <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst3;</span><br><span class="line">   copy(vec.cbegin(), vec.cend(), front_inserter(lst3));</span><br><span class="line">   print(lst3);</span><br></pre></td></tr></table></figure>

<p>当我们使用<code>front_inserter</code>时，元素总是插入到容器的第一个元素之前。因此，<code>front_inserter</code>生成的迭代器会将插入的元素序列的顺序颠倒过来，而<code>inserter</code>和<code>back_inserter</code>则不会。</p>
<p><strong>iosteam迭代器</strong></p>
<p>虽然<code>iostream</code>不是容器，但是标准库定义了可以用于这类IO类型对象的迭代器。</p>
<p><code>istream_iterator</code>操作</p>
<p>当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。当创建一个<code>istream_iterator</code>时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当尾后值使用的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">//绑定流</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">//尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span>(int_it != int_eof) <span class="comment">//当有数据可供读取时</span></span><br><span class="line">    vec.push_back(*in_iter++);</span><br></pre></td></tr></table></figure>

<p>我们可以把程序改写为如下形式，这体现<code>istream_iterator</code>更有用的地方。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(int_it,int_eof)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210118211314.png" alt="image-20210118211314493"></p>
<p><strong>使用算法操作流迭代器</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in(cin), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>惰性求值</strong></p>
<p>标准库并不保证迭代器立即从流读取数据，具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读值。</p>
<p>对于大多数程序而言，立即读取还是推迟读取没什么差别，但是，如果我们创建了一个<code>istream_iterator</code>，没有使用就销毁了，或者我们正在从两个不同的对象同步读取一个流，那么读取可能就很重要了。</p>
<p><code>ostream_iterator</code>操作</p>
<p>我们可以对任何具有输出运算符（&lt;&lt;运算符）的类型定义<code>ostream_iterator</code>。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210118212852.png" alt="image-20210118212852166"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e: vec)</span><br><span class="line">    	*out_iter ++ = e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>此程序将<code>vec</code>中的每个元素写到<code>cout</code>,每个元素后加一个空格。</p>
<p>值得注意的是，当我们向<code>out_iter</code>赋值时，可以忽略解引用和递增运算。即、如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e: vec)</span><br><span class="line">    out_iter = e;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>但是，一般推荐使用第一种形式，这样的循环的行为更为清晰。</p>
<p><strong>反向迭代器</strong></p>
<p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。递增一个反向迭代器会移动到前一个元素，递减迭代器会移动到下一个元素。除了<code>forward_list</code>之外，其他容器都支持反向迭代器。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210118215202.png" alt="image-20210118215202352"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(vec.begin(), vec.end()); <span class="comment">//按正常顺序排序vec</span></span><br><span class="line">sort(vec.rbegin(), vec.rend());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流迭代器不支持递减运算。</p>
</blockquote>
<p>下面思考这样的一个问题，有一个为为：<code>line</code>的<code>string</code>，保存着一个逗号分隔的单词列表。我们希望打印<code>line</code>中的第一个单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> comma = find(line.cbegin(), line.cend(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.cbegin(), comma) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>希望打印最后一个单词</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> rcomma = find(line.crbegin(), line.crend(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.crbegin(), rcomma) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>上述程序会生成错误的结果：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210118215746.png" alt="image-20210118215746099"></p>
<p>我们需要调用<code>reverse_iterator</code>的<code>base</code>成员函数来完成这一转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(rcomma.base(), line.cend()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。</p>
</blockquote>
<h4 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h4><p>算法需要的迭代器操作可以分为5个迭代器类别。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210120205055.png" alt="image-20210120205055525"></p>
<p><strong>五类迭代器</strong></p>
<p>C++标准库指明了泛型和数值算法的每个迭代器参数的最小类别。对于每个迭代器参数来说，其能力必须与规定的最小类别至少相当，向算法传递一个能力更差的迭代器会产生错误。</p>
<p><strong>输入迭代器</strong></p>
<p>一个输入迭代器必须支持：</p>
<ul>
<li>用于比较两个迭代器的相等和不相等运算符（==，！=）</li>
<li>用于推进迭代器的前置和后置递增运算（++）</li>
<li>用于读取元素的解引用运算符（*）：解引用运算符只会出现在赋值运算符的右侧。</li>
<li>箭头运算符（-&gt;），等价于<code>(*it).member</code>即，解引用迭代器，并提取对象的成员。</li>
</ul>
<p>算法<code>find</code>和<code>accumulate</code>要求输入迭代器；而<code>istream_iterator</code>是一种输入迭代器。</p>
<p><strong>输出迭代器</strong></p>
<p>必支持：</p>
<ul>
<li>用于推进迭代器的前置和后置递增运算（++）</li>
<li>用于读取元素的解引用运算符（*）：解引用运算符只会出现在赋值运算符的左侧。</li>
</ul>
<p>我们只能向一个输出迭代器赋值一次，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如：<code>copy</code>函数的第三个参数就是输出迭代器。<code>ostream_iterator</code>类型也是输出迭代器。</p>
<p><strong>前向迭代器</strong></p>
<p>可以读写元素，这类迭代器只能在序列中沿一个方向移动。支持所有输入输出迭代器的操作，并且可以多次读写一个元素，因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。</p>
<p>算法<code>replace</code>要求前向迭代器，<code>forward_list</code>上的迭代器是前向迭代器。</p>
<p><strong>双向迭代器</strong></p>
<p>可以正向反向读写序列中的元素。支持所有前向迭代器的操作。还支持前置和后置递减运算符(–)。算法<code>reverse</code>要求双向迭代器，除了<code>forward_list</code>之外，其他标准库都提供符合双向迭代器要求的迭代器。</p>
<p><strong>随机访问迭代器</strong></p>
<p>支持双向迭代器的所有功能。还支持：</p>
<ul>
<li>用于比较两个迭代器相对位置的关系运算符（&lt;,&lt;=,&gt;,&gt;=）</li>
<li>迭代器和一个整数值得加减运算（+，+=，-，-=），计算结果是迭代器在序列中前进或后退给定整数个元素后的位置。</li>
<li>用于两个迭代器上的减法运算符（-），得到两个迭代器的距离。</li>
<li>下标运算符<code>(iter[n])</code>,与<code>*(iter[n])</code>等价。</li>
</ul>
<p>算法<code>sort</code>要求随机访问迭代器，<code>array,deque,string,vector</code>的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p>
<p><strong>算法形参模式</strong></p>
<p>一般而言，算法具有如下四种类型：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210120213449.png" alt="image-20210120213449516"></p>
<p><code>dest</code>参数表示算符可以写入的目的位置的迭代器，算法假定：按其需要写入数据，不管写入多少个元素都是安全的。</p>
<p>接受第二输入序列的算法，这类算法接受两个完整指定的范围：<code>[beg,end)</code>和<code>[beg2,end2)</code></p>
<p><strong>算法命名规范</strong></p>
<p><code>_if</code>版本算法</p>
<p>该版本接受一个谓词：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">find(beg, end, val); <span class="comment">// 查找输入范围内val第一次出现的位置</span></span><br><span class="line">find_if(beg,end, pred);<span class="comment">//查找第一个令pred为真的元素</span></span><br></pre></td></tr></table></figure>

<p>区分拷贝元素版本和不拷贝元素版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reverse(beg,end); <span class="comment">// 反转输入范围中元素的顺序</span></span><br><span class="line">reverse_copy(beg, end, dest); <span class="comment">//将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure>

<p>混合版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">remove_if(v1.begin(), v1.end(), </span><br><span class="line">         [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;);</span><br><span class="line"><span class="comment">//将v1中删除奇数元素</span></span><br><span class="line"></span><br><span class="line">remove_copy_if(v1.begin(), v1,end(), back_inserter(v2),</span><br><span class="line">		[](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;);</span><br><span class="line"><span class="comment">//将偶数元素从v1拷贝到v2；v1不变</span></span><br></pre></td></tr></table></figure>



<h4 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h4><p>链表类型<code>list</code>和<code>forward_list</code>定义了几个成员函数的算法。</p>
<blockquote>
<p>对于<code>list</code>和<code>forward_list</code>，优先使用成员函数版本的算法而不是通用算法。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210120215115.png" alt="image-20210120215115438"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210120215142.png" alt="image-20210120215142486"></p>
<p>链表类型还定义了<code>splice</code>算法，这是链表数据结构特有的，因此不需要通用版本。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210120215239.png" alt="image-20210120215239144"></p>
<p>链表特有版本与通用版本间的一个重要区别是链表版本会该表底层的容器。例如：<code>remove</code>的链表版本会删除指定的元素，<code>unique</code>的链表版本会删除第二个和后继的重复元素。</p>
<h3 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h3><p>关联容器和顺序容器有着根本的区别：关联容器中的元素是按关键字来保存访问的。两种主要的关联容器类型是<code>map</code>和<code>set</code>。</p>
<p>标准库提供8个关键容器。允许重复关键字的容器名字中都带包含单词<code>multi</code>;不保持关键字按顺序存储的容器名字都以单词<code>unordered</code>开头。</p>
<p>类型<code>map</code>和<code>multimap</code>定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p>
<h4 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h4><p><strong>使用map</strong></p>
<p>一个经典的使用关联数组计数程序:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">//从string到size_t的空map</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line">wwhile(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">		++ word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">&quot;occurs&quot;</span> &lt;&lt; w.second &lt;&lt; </span><br><span class="line">    ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot;times&quot;</span> : <span class="string">&quot;time&quot;</span> ) &lt;&lt; <span class="built_in">endl</span>; </span><br></pre></td></tr></table></figure>

<p><strong>使用set</strong></p>
<p>对上一个示例一个合理的拓展是：忽略常见单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count; <span class="comment">//从string到size_t的空map</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">&quot;the&quot;</span>, <span class="string">&quot;The&quot;</span>&#125;;</span><br><span class="line">wwhile(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="keyword">if</span> (exclude.find(word) == exclude.end())</span><br><span class="line">		++ word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">&quot;occurs&quot;</span> &lt;&lt; w.second &lt;&lt; </span><br><span class="line">    ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot;times&quot;</span> : <span class="string">&quot;time&quot;</span> ) &lt;&lt; <span class="built_in">endl</span>; </span><br></pre></td></tr></table></figure>



<h4 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h4><p>关联容器（有序的和无序的）都支持9.2节中介绍的普通容器操作。但不支持顺序容器的位置相关的操作。例如<code>push_front</code>，这些操作对关联容器没有意义。</p>
<p>关联容器的迭代器都是双向的。</p>
<p><strong>定义关联容器</strong></p>
<p>当定义一个<code>map</code>是，必须指明关键字类型和值类型，而定义<code>set</code>时，只需要指明关键字类型即可。</p>
<p>我们可以对关联容器进行值初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; authors = &#123;&#123;<span class="string">&quot;Joyce&quot;</span>,<span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">                               &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>初始化multimap和multiset</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出20</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.cbegin(), ivec.cend())</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出10，iset中包含了不重复的元素</span></span><br><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span><span class="params">(ivec.cbegin(), ivec.cend())</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; miset.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出20，保存了重复元素</span></span><br></pre></td></tr></table></figure>

<p><strong>使用关键字类型的比较函数</strong></p>
<p>用尖括号指出要定义那种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn) *&gt;</span><br><span class="line">    bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>

<p>当用<code>decltype</code>来获取一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。用<code>compareIsbn</code>来初始化<code>bookstore</code>对象，这表示当我们向<code>bookstore</code>中添加元素时，通过调用<code>compareIsbn</code>来为这些元素排序。</p>
<p><strong>pair类型</strong></p>
<p><code>pair</code>标准库定义在头文件<code>utility</code>中。</p>
<p>当创建一个<code>pair</code>时，我们需要提供两种类型名。</p>
<p><code>pair</code>的数据成员是<code>public</code>的，两个成员分别命名为<code>first</code>和<code>second</code>，我们用普通的成员访问符号来访问他。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">&quot;occurs&quot;</span> &lt;&lt; w.second  &lt;&lt; ((w.second) &gt; <span class="number">1</span> ? <span class="string">&quot;times&quot;</span> : <span class="string">&quot;time&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102012.png" alt="image-20210303102905596"></p>
<p><strong>创建pair对象的函数</strong></p>
<p>如果一个函数需要返回一个<code>pair</code>，在新标准下，我们可以对返回值进行列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">    process(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v.emptr())</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;; <span class="comment">//列表初始化</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(); <span class="comment">//隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在较早的C++版本中，不允许用花括号对<code>pair</code>这种类型的对象进行初始化，必须使用显示构造返回值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(v.back(), v.back().size());</span><br></pre></td></tr></table></figure>

<p>我们也可以使用如下方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(v.back(), v.back().size());</span><br></pre></td></tr></table></figure>

<h4 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h4><p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102006.png" alt="image-20210303114417979"></p>
<p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。在<code>map</code>中，每个元素是一个<code>pair</code>对象，包含一个关键字和一个关键的值。由于我们不能改变一个元素的关键字，因此这个<code>pair</code>的关键字部分是<code>const</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> map_it = word_count.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new_key&quot;</span>; <span class="comment">//错误：关键字是const的</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">//正确，可以通过迭代器改变元素</span></span><br></pre></td></tr></table></figure>

<p><strong>set的迭代器是const的</strong></p>
<p>虽然set类型同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种类型都只允许访问<code>set</code>中的元素，一个<code>set</code>中的关键字也是<code>const</code>的。</p>
<p><code>map</code>和<code>set</code>都支持表9.2中的<code>begin</code>和<code>end</code>操作。</p>
<p><strong>关键容器和算法</strong></p>
<p>我们通常不对关联容器使用泛型算法，关键字是<code>const</code>这一特性意味着不能将关联容器传递给修改或者重排容器的函数。</p>
<p>在实际编程中，可以用泛函<code>copy</code>函数将元素从一个关联容器拷贝到另一个序列，类似的，可以调用<code>inserter</code>将一个插入器绑定到另一个关联容器，通过使用<code>inserter</code>，我们可以将关联容器当做一个目的位置来调用另一个算法。</p>
<p><strong>添加元素</strong></p>
<p>关联容器的<code>insert</code>成员，向容器中添加一个元素或者一个元素范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set2;</span><br><span class="line">set2.insert(ivec.cbegin(), ivec.cend());</span><br><span class="line">set2.insert(&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;);<span class="comment">//添加不重复的元素。</span></span><br></pre></td></tr></table></figure>

<p><code>insert</code>有两个版本，分别接受一对迭代器，或者是一个初始化器列表，这两个版本的行为类似对应的构造函数。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102029.png" alt="image-20210304101400945"></p>
<p><strong>insert的返回值</strong></p>
<p>添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，告诉我们插入操作是否成功，<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值，指出元素是插入成功还是已经存在与容器之中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count ;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(!ret.second)</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ret.first</code>是<code>pair</code>的第一个成员，是一个<code>map</code>迭代器，指向具有给定关键字的元素。</p>
<p><strong>删除元素</strong></p>
<p>与顺序容器一样，我们可以通过传递给<code>erase</code>一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。</p>
<p>关联容器提供一个额外的<code>erase</code>操作，接受一个<code>key_type</code>参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102051.png" alt="image-20210304104032786"></p>
<p><strong>map的下标操作</strong></p>
<p><code>map</code>和<code>unordered_map</code>容器提供了下标运算符和一个对应的<code>at</code>函数。<code>set</code>类型不支持下标，因为<code>set</code>中没有与关键字相关联的”值”。</p>
<p>由于使用下标运算符可能插入一个新的元素，我们只可以对非<code>const</code>的<code>map</code></p>
<p>使用下标操作。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102055.png" alt="image-20210305101401047"></p>
<blockquote>
<p>使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到map中。</p>
</blockquote>
<p>通常情况下，解引用一个迭代器返回的类型与下标运算符返回的类型是一样的，但对<code>map</code>则不然，当对一个<code>map</code>进行下标操作时，会获得一个<code>mapped_type</code>对象；担当解引用一个<code>map</code>迭代器时，会得到一个<code>value_type</code>对象。</p>
<p><strong>访问元素</strong></p>
<p>对于不允许重复关键字的容器，可能使用<code>find</code>还是<code>count</code>没什么区别，但对于允许重复关键字的容器，<code>count</code>还会做更多的工作。如果元素在容器中，它还会统计有多少个元素有相同的关键字。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102059.png" alt="image-20210305101442535"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210305102101.png" alt="image-20210305101507406"></p>
<p><strong>在multimap和multiset中查找元素</strong></p>
<p>如果一个<code>multimap</code>或者<code>multiset</code>中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> entries = authors.count(search_item);</span><br><span class="line"><span class="keyword">auto</span> iter = author.find(search_item);</span><br><span class="line"><span class="keyword">while</span>(entries)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++ iter;</span><br><span class="line">    -- entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.lower_bound(search_item),</span><br><span class="line">   end = authors.upper_bound(search_item);</span><br><span class="line">   beg != end; ++beg)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.equal_range(search_item);</span><br><span class="line">   pos.first != pos.second; ++pos.first)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first -&gt; second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>



<h4 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h4><p>新标准定义了4个无序关联容器，这些容器使用一个哈希函数和关键字类型的==运算符。</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210306104457.png" alt="image-20210306104456892"></p>
<h3 id="第12章-动态内存"><a href="#第12章-动态内存" class="headerlink" title="第12章 动态内存"></a>第12章 动态内存</h3><h4 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h4><p>为了更容器更安全的使用动态指针，新的标准库提供了两种智能指针类型来管理动态对象。</p>
<p><code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>则独占所指向对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象，这三种类型都定义在<code>memory</code>头文件中。</p>
<p><strong>shared_ptr</strong></p>
<p>定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; p2;</span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;emptr())	<span class="comment">//如果p1不为空，检查他是否指向一个空string</span></span><br><span class="line">    *p1 = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210309094726.png" alt="image-20210309094726069"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210309094759.png" alt="image-20210309094759229"></p>
<p><strong>make_shared函数</strong></p>
<p>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>，也定义在头文件<code>memory</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p4 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当然，我们通常用<code>auto</code>定义一个对象来保存<code>make_shared</code>的结果，这样的方法较为简单。</p>
<p><strong>shared_ptr的拷贝和赋值</strong></p>
<p>当进行拷贝或赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code>指向相同的对象。我们可以认为其有一个关联的计数器，通常称其为引用计数。</p>
<p>一旦一个<code>shared_ptr</code>的计数器变为0，它会自动释放自己所管理的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p = factory(arg);</span><br><span class="line">&#125;	<span class="comment">//离开了作用域，p指向的内存会被自动释放掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Foo&gt; p = factory(arg);</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回p时，引用计数进行了递增操作</span></span><br><span class="line">&#125;	<span class="comment">//离开了作用域，p指向的内存不会被自动释放掉</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你将<code>shared_ptr</code>存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用<code>erase</code>删除不在需要的那些元素。</p>
</blockquote>
<p><strong>使用动态内存的一个常见原因是允许多个对象共享相同的状态</strong></p>
<p>动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>; <span class="comment">//初始化空string</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//指向一个未初始化的int</span></span><br></pre></td></tr></table></figure>

<p>只需要在类型名之后跟一对空括号即可进行值初始化。</p>
<p>只有当括号中仅有单一初始化器时才可以使用<code>auto</code>；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>(a,b,c); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>const对象</strong></p>
<p>用<code>new</code>分配<code>const</code>对象是合法的；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>动态分配的<code>const</code>对象必须进行初始化。</p>
<p><strong>指针值和delete</strong></p>
<p>如果<code>new</code>不能分配所要求的内存空间，会抛出一个<code>bad_alloc</code>的异常， 我们可以改变使用<code>new</code>的方式来阻止它抛出的异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">int</span>; <span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p><code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中。</p>
<p><strong>释放和delete</strong></p>
<p>释放一块并非<code>new</code>分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p>
<p>在<code>delete</code>之后，指针就变成了人们所说的空悬指针。如果我们需要保留指针，可以在<code>delete</code>之后将<code>nullptr</code>赋予指针，这样就清楚地指出指针不指向任何对象。</p>
<p><strong>shared_ptr和new结合使用</strong></p>
<p>我们可以通过<code>new</code>返回的是指针来初始化智能指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//p2指向一个值为42的int</span></span><br></pre></td></tr></table></figure>

<p>我们不能将一个内置指针隐式转化为一个智能指针，必须使用直接初始化形式来初始化一个智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">//错误。必须使用直接初始化</span></span><br></pre></td></tr></table></figure>

<p>一个返回<code>shared_ptr</code>的函数不能在其返回语句中隐式转化为一个普通指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>(p); <span class="comment">//错误：隐式转化为shared_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p)); <span class="comment">//正确。显式转化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210310163422.png" alt="image-20210310163421929"></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210310163458.png" alt="image-20210310163458388"></p>
<p><strong>不要混合使用普通指针和智能指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="comment">//ptr离开作用域，被销毁</span></span><br></pre></td></tr></table></figure>

<p>当局部变量被销毁时， <code>ptr</code>指向的内存不会被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">//引用计数为1</span></span><br><span class="line">process(p); <span class="comment">//拷贝p会递增他的引用计数</span></span><br><span class="line"><span class="keyword">int</span> i = *p; <span class="comment">//正确，引用计数为1</span></span><br></pre></td></tr></table></figure>

<p>虽然不能传递给<code>process</code>一个内置指针，但是可以传递给它一个临时的<code>process</code>，这个指针时显式构造的，但是，这样做很可能会导致错误；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line">process(x); <span class="comment">//错误</span></span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">//合法，但是内存会被释放</span></span><br><span class="line"><span class="keyword">int</span> j = *x; <span class="comment">//未定义的，x是一个空悬指针</span></span><br></pre></td></tr></table></figure>

<p><code>get</code>用来将指针的访问权限传递给代码，你只有在确定代码不会<code>delete</code>指针的情况下，才能使用<code>get</code>，特别是，永远不要用<code>get</code>初始化另一个智能指针或者为另一个智能指针幅值。</p>
<p><strong>其他操作</strong></p>
<p>可以用<code>reset</code>来将一个新的指针赋予一个<code>shared_ptr</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>

<p><code>reset</code>会更新引用计数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())</span><br><span class="line">    p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">//我们不是唯一用户：分配新的拷贝</span></span><br><span class="line">*p += newVal; <span class="comment">//我们是唯一用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>



<p><strong>智能指针和异常</strong></p>
<p>如果使用智能指针， 即使程序块过早结束，智能指针也能确保在内存不在需要时将其释放。</p>
<p>但是我们直接管理的内存是不会自动释放的，如果使用内置指针管理内存，且在<code>new</code>之后在对应的<code>delete</code>之前发生了异常，则内存不会被释放。</p>
<p><strong>智能指针陷阱</strong></p>
<ul>
<li>不使用相同的内置指针初始化（或者<code>reset</code>）多个智能指针。</li>
<li>不<code>delete get()</code>返回的指针</li>
<li>如果使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器。</li>
</ul>
<p><strong>unique_ptr</strong></p>
<p>某时刻只能有一个<code>unique_ptr</code>指向一个给定对象。</p>
<p><code>unique_ptr</code>没有类似<code>make_shared</code>的标准库函数，当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上，与<code>shared_ptr</code>相似，初始化时必须采用直接初始化的方式。</p>
<p><code>unique_ptr</code>不支持普通拷贝或赋值操作。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210310163242.png" alt="image-20210310163242151"></p>
<p>但是可以通过调用<code>release</code>或者<code>reset</code>将指针的所有权从一个（非<code>const</code>）<code>unique_ptr</code>转一个另一个<code>unique_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1.release)</span></span>;<span class="comment">//将p1的所有权转移给p2</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line">p2.reset(p3.release());<span class="comment">//reset释放了p2原来只想的内存</span></span><br></pre></td></tr></table></figure>

<p>如果我们不用另一个智能指针来保存<code>release</code>返回的指针，我们的程序就要负责资源的释放。</p>
<p>我们可以拷贝或者赋值一个将要被销毁的<code>unique_ptr</code>。最常见的例子是从函数返回一个<code>unique_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; (<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(p))</span></span></span><br><span class="line"><span class="function">	<span class="keyword">return</span> ret</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>向unique_ptr传递删除器</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;objT, delT&gt; p (new objT, fcn);</span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">	<span class="built_in">unique_ptr</span>&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt;</span><br><span class="line">    	p(&amp;c, end_conection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>weak_ptr</strong></p>
<p><code>weak_ptr</code>是一种不控制指向对象生存周期的智能指针，它指向由一个<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。即使有<code>weak_ptr</code>指向对象，对象还是会被释放。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210325152927.png" alt="image-20210325152920325"></p>
<p>当我们创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_share&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;<span class="comment">//wp若共享p</span></span><br></pre></td></tr></table></figure>



<p>由于对象可能不存在，我们不能使用<code>weak_ptr</code>直接访问对象，而必须调用<code>lock</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock())&#123;</span><br><span class="line">    <span class="comment">//在if中，np与p共享对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h4><p><strong>new和数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()];</span><br></pre></td></tr></table></figure>

<p>方括号中的大小必须是整型，但不必是常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="comment">//arrT表示42个int的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//未初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">//默认初始化</span></span><br></pre></td></tr></table></figure>

<p>在新标准中，我们还可以提供一个元素初始化器的花括号列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *psa3 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">2</span>]&#123;<span class="string">&quot;a&quot;</span>, <span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>释放动态数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;	<span class="comment">//p必须指向一个动态分配的对象或者为空</span></span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//p必须指向一个动态分配的数组或者为空</span></span><br></pre></td></tr></table></figure>

<p><strong>智能指针和动态数组</strong></p>
<p>标准库提供了一个可以管理<code>new</code>分配的数组的<code>unique_ptr</code>版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int []&gt; up(new int[10]);</span><br><span class="line">up.release();</span><br></pre></td></tr></table></figure>

<p>当一个<code>unique_ptr</code>指向一个数组时，我们不能使用点和箭头成员运算符。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210325160327.png" alt="image-20210325160327373"></p>
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不支持管理动态数组，如果希望使用<code>shared_ptr</code>管理一个动态数组，必须提供自己定义的删除器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br><span class="line">sp.reset();</span><br></pre></td></tr></table></figure>

<p><code>shared_ptr</code>未定义下标运算符，并且不支持指针的算数运算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i!=<span class="number">10</span>; ++i)</span><br><span class="line">    *(sp.get() + i) = i;</span><br></pre></td></tr></table></figure>

<p><strong>allocator类</strong></p>
<p>标准库<code>allocator</code>类定义在头文件<code>memory</code>中。</p>
<p>类似<code>vector</code>，<code>allocator</code>是一个模板。为了定义一个<code>allocator</code>，我们必须指明这个<code>allocator</code>可以分配的对象类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210325163004.png" alt="image-20210325163004593"></p>
<p><code>allocator</code>分配的内存是未构造的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">alloc.construct(q++);<span class="comment">//空字符</span></span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);<span class="comment">//cccccccccc</span></span><br></pre></td></tr></table></figure>

<p>还未构造对象的情况下就使用原始内存是错误的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>销毁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(q != p)</span><br><span class="line">    alloc.destroy(--q);</span><br></pre></td></tr></table></figure>

<p>我们只能对真正构造了的元素进行<code>destroy</code>操作。一旦元素被销毁后，我们可以重新使用这部分内存，也可以将其归还给系统，释放内存通过调用<code>deallocate</code>来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">alloc.deallocate(p, n);</span><br></pre></td></tr></table></figure>

<p>其中<code>n</code>必须与调用<code>allocated</code>分配内存时提供的大小参数具有一样的值。</p>
<p>标准库还为<code>allcator</code>类定义了两种伴随算法。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210325164427.png" alt="image-20210325164427620"></p>
<p>假定有一个<code>int</code>的<code>vector</code>，希望将其内容拷贝到动态内存中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = alloc.allocate(vi.size() * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> q = uninitialized_copy(vi.begin(), vi.end(), p);</span><br><span class="line">uninitialized_fill_n(q, vi.size(), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>



<h4 id="12-3-使用标准库：文本查询程序"><a href="#12-3-使用标准库：文本查询程序" class="headerlink" title="12.3 使用标准库：文本查询程序"></a>12.3 使用标准库：文本查询程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> line_no = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">make_plural</span><span class="params">(<span class="keyword">size_t</span> ctr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ctr &gt; <span class="number">1</span>) ? word + ending : word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        TextQuery(ifstream&amp;);</span><br><span class="line">        <span class="function">QueryResult <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,</span><br><span class="line">            <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt;&gt; wm;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TextQuery::TextQuery(ifstream &amp;is): file(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> text;</span><br><span class="line">    <span class="keyword">while</span>(getline(is, text))</span><br><span class="line">    &#123;</span><br><span class="line">        file-&gt;push_back(text);</span><br><span class="line">        <span class="keyword">int</span> n = file-&gt;size() - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">line</span><span class="params">(text)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line">        <span class="keyword">while</span>(line &gt;&gt; word)&#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;lines = wm[word];</span><br><span class="line">            <span class="keyword">if</span>(!lines)<span class="comment">//指针为空</span></span><br><span class="line">                lines.reset(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;);</span><br><span class="line">            lines-&gt;insert(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    QueryResult(<span class="built_in">string</span> s,</span><br><span class="line">                <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; p,</span><br><span class="line">                <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; f):</span><br><span class="line">        sought(s), lines(p), file(f)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> sought;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; lines;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QueryResult</span><br><span class="line">TextQuery::query(<span class="keyword">const</span> <span class="built_in">string</span> &amp;sought) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; <span class="title">nodata</span><span class="params">(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">    <span class="keyword">if</span>(loc == wm.end())</span><br><span class="line">        <span class="keyword">return</span> QueryResult(sought, nodata, file);</span><br><span class="line">        <span class="comment">//返回一个指向空的行号set的shared_ptr</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> QueryResult &amp;qr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; qr.sought &lt;&lt; <span class="string">&quot; occurs&quot;</span> &lt;&lt; qr.lines-&gt;size()</span><br><span class="line">    &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; make_plural(qr.lines-&gt;size(), <span class="string">&quot;time&quot;</span>, <span class="string">&quot;s&quot;</span>)</span><br><span class="line">    &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num: *qr.lines)</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;\t(line&quot;</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; <span class="string">&quot;) &quot;</span></span><br><span class="line">        &lt;&lt;*(qr.file-&gt;begin() + num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runQueries</span><span class="params">(ifstream&amp; infile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TextQuery <span class="title">tq</span><span class="params">(infile)</span></span>; <span class="comment">//保存文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;enter word to look for, or q to qiut:&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">cin</span> &gt;&gt;s) || s == <span class="string">&quot;q&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">        print(<span class="built_in">cout</span>, tq.query(s)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> file_name = <span class="string">&quot;demo.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(file_name)</span></span>;</span><br><span class="line">    runQueries(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ primer 第四部分 (C++基础)</title>
    <url>/2021/09/17/C++Primer%20%EF%BC%88%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>这两年真的发生太多事，尤其是昨天晚上，精准破防。但现在人还是懵逼的，好好学习吧，放下七情六欲。</p>
<p>2021年9月8日07:54:33</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/511221.jpg" alt="511221"></p>
<a id="more"></a>





<h2 id="第四部分-高级主题"><a href="#第四部分-高级主题" class="headerlink" title="第四部分 高级主题"></a>第四部分 高级主题</h2><h3 id="第17章-标准库特殊设施"><a href="#第17章-标准库特殊设施" class="headerlink" title="第17章 标准库特殊设施"></a>第17章 标准库特殊设施</h3><h4 id="17-1-tuple类型"><a href="#17-1-tuple类型" class="headerlink" title="17.1 tuple类型"></a>17.1 tuple类型</h4><p>​    <strong>tuple</strong>是类似<strong>pair</strong>的模板。每个<code>pair</code>的成员类型都不相同，但每个<code>pair</code>都恰好有两个成员。不同<code>tuple</code>类型的成员类型也不相同，但一个<code>tuple</code>可以有任意数量的成员。</p>
<p>​    <code>tuple</code>类型及其伴随类型和函数都定义在<code>tuple</code>头文件中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210908095905232.png" alt="image-20210908095905232"></p>
<blockquote>
<p>我们可以将<code>tuple</code>看作一个“快速而随意”的数据结构</p>
</blockquote>
<p><strong>定义和初始化tuple</strong></p>
<p>​    当我们定义一个<code>tuple</code>时，需要指出每个成员的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD; <span class="comment">//三个成员都设置为0</span></span><br><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;</span><br><span class="line">    someVal(<span class="string">&quot;constants&quot;</span>, (<span class="number">3.14</span>, <span class="number">2.718</span>), <span class="number">42</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><code>tuple</code>的这个构造函数是<code>explicit</code>的，因此我们必须使用直接初始化语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;	<span class="comment">//错误</span></span><br><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;		<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>标准库定义了<code>make_tuple</code>函数，我可以用它来生成<code>tuple</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="string">&quot;0-999-X&quot;</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>



<p><strong>访问tuple的成员</strong></p>
<p>要访问一个<code>tuple</code>的成员，就要使用一个名为<code>get</code>的标准库函数模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> book = get&lt;<span class="number">0</span>&gt;(item);</span><br><span class="line"><span class="keyword">auto</span> cnt = get&lt;<span class="number">1</span>&gt;(item);</span><br></pre></td></tr></table></figure>

<p>如果不知道一个<code>tuple</code>准确的类型细节信息，可以用两个辅助类模板来查询<code>tuple</code>成员的数量和类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(item)</span> trans</span>; <span class="comment">//trans是item的类型</span></span><br><span class="line"><span class="keyword">size_t</span> sz = tuple_size&lt;trans&gt;::value; <span class="comment">//返回trans类型对象中成员的数量</span></span><br><span class="line">tuple_element&lt;<span class="number">1</span>, trans&gt;::type cnt = get&lt;<span class="number">1</span>&gt;(item);</span><br></pre></td></tr></table></figure>



<p><strong>关系和相等运算符</strong></p>
<p>只有两个<code>tuple</code>具有相同数量的成员时，我们才能比较它们。而且，为了使用<code>tuple</code>的相同或不等运算符，对每对成员使用==运算符必须都是合法的；为了使用关系运算符，对每对成员使用&lt;必须都是合法的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;string, string&gt; duo(&quot;1&quot;, &quot;2&quot;);</span><br><span class="line">tuple&lt;size_t, size_t&gt; twoD(1, 2);</span><br><span class="line"><span class="keyword">bool</span> b = (duo == twoD); <span class="comment">// 错误，不能比较size_t和string</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于<code>tuple</code>定义了&lt;和==运算符，我们可以将<code>tuple</code>序列传递给算法，并且可以在无序容器中将<code>tuple</code>作为关键字类型。</p>
</blockquote>
<p><strong>使用tuple返回多个值</strong></p>
<p>每个书店创建一个<code>vector&lt;Sales_data&gt;</code>，并将这些<code>vector</code>保存在<code>vector</code>的<code>vector</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt; files;</span><br></pre></td></tr></table></figure>

<p>对每个有匹配销售记录的书店，我们将创建一个<code>tuple</code>来保存这家书店的索引和两个迭代器。</p>
<p><strong>返回tuple的函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;::size_type,</span><br><span class="line">			  <span class="built_in">vector</span>&lt;Sales_data&gt;::const_iterator,</span><br><span class="line">			  <span class="built_in">vector</span>&lt;Sales_data&gt;::const_iterator&gt; matches;</span><br><span class="line"><span class="comment">//files保存每家书店的销售记录</span></span><br><span class="line"><span class="built_in">vector</span>&lt;matches&gt;</span><br><span class="line">findBook(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt; &amp;files,</span><br><span class="line">         <span class="keyword">const</span> <span class="built_in">string</span> &amp;book)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;matches&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = files.cbegin(); it != files.cend(); ++it)&#123;</span><br><span class="line">        <span class="comment">//查找相同ISBN的Sales_data范围</span></span><br><span class="line">        <span class="keyword">auto</span> found = equal_range(it-&gt;cbegin(), it-&gt;cend(),</span><br><span class="line">                                book, vompareIsbn);</span><br><span class="line">        <span class="keyword">if</span>(found.first != found.second)</span><br><span class="line">            <span class="comment">//记住此书店的索引及匹配范围</span></span><br><span class="line">            ret.push_back(make_tuple(it - files.cbegin(),</span><br><span class="line">                                    found.first, found.second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;<span class="comment">//如果为找到匹配记录的话，ret为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equal_range</code>的前两个实参是表示输入序列的迭代器，第三个参数是一个值。默认情况下，<code>equal_range</code>使用<code>&lt;</code>运算符来比较元素。由于<code>Sales_data</code>没有<code>&lt;</code>运算符，因此我们传递给它一个指向<code>compareIsbn</code>函数的指针。</p>
<p><code>equal_range</code>算法返回一个迭代器<code>pair</code>，表示元素的范围。如果未找到<code>book</code>，则两个迭代器相等，表示空范围。否则，返回的<code>pair</code>的<code>first</code>成员将表示第一条匹配的记录，<code>second</code>则表示匹配的尾后位置。</p>
<p><strong>使用函数返回的tuple</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportResults</span><span class="params">(istream &amp;in, ostream &amp;os,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt; &amp;files)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; s)&#123;</span><br><span class="line">        <span class="keyword">auto</span> trans = findBook(files, s);</span><br><span class="line">        <span class="keyword">if</span>(trans.empty())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;not found in any stores&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;store : trans)</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;store&quot;</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(store) &lt;&lt; <span class="string">&quot; sales: &quot;</span></span><br><span class="line">            &lt;&lt; accumlate(get&lt;<span class="number">1</span>&gt;(store), get&lt;<span class="number">2</span>&gt;(store),</span><br><span class="line">                        Sales_data(s))</span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="17-2-bitset类型"><a href="#17-2-bitset类型" class="headerlink" title="17.2 bitset类型"></a>17.2 <code>bitset</code>类型</h4><p><code>bitset</code>类定义在头文件<code>bitset</code>中。</p>
<p><strong>定义和初始化<code>bitset</code></strong></p>
<p><code>bitset</code>类是一个类模板，它类似<code>array</code>类，具有固定的大小，当我们定义一个<code>bitset</code>时，需要声明它包含多少个二进制位：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bitvec</span><span class="params">(<span class="number">1U</span>)</span></span>;<span class="comment">//32位，定位为1，其他位为0</span></span><br></pre></td></tr></table></figure>

<p>编号从0开始的二进制位被称为<strong>低位</strong>，编号到31结束的二进制位被称为<strong>高位</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210908201403357.png" alt="image-20210908201403357"></p>
<p><strong>用unsigned值初始化<code>bitset</code></strong></p>
<p>当我们使用一个整型值来初始化<code>bitset</code>时，此值将被转化为<code>unsigned long long </code>类型并被当作位模式来处理。</p>
<p>如果<code>bitset</code>的大小大于一个<code>unsigned long long</code>中的二进制位数，则剩余的高位被置为0。如果<code>bitset</code>的大小小于一个<code>unsigned long long</code>中的二进制位数，则只使用给定值中的低位，超出<code>bitset</code>大小的高位被丢弃：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;13&gt; <span class="title">bitvec1</span><span class="params">(<span class="number">0xbeef</span>)</span></span>;</span><br><span class="line"><span class="comment">//二进制位序列为1111011101111</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;20&gt; <span class="title">bitvec1</span><span class="params">(<span class="number">0xbeef</span>)</span></span>;</span><br><span class="line"><span class="comment">//二进制位序列为00001111011101111</span></span><br></pre></td></tr></table></figure>



<p><strong>从string初始化<code>bitset</code></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bitvec4</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>string</code>包含的字符数比<code>bitset</code>少，则<code>bitset</code>的高位被置为0。</p>
<blockquote>
<p>string的下标编号习惯于<code>bitset</code>恰好相反，要记住这个差别。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">&quot;11111110000000011001101&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bitvec5</span><span class="params">(str, <span class="number">5</span>, <span class="number">4</span>)</span></span>; <span class="comment">//从str[5]开始的四个二进制位，1100</span></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;32&gt; <span class="title">bitvec5</span><span class="params">(str, str.size() - <span class="number">4</span>)</span></span>; <span class="comment">//使用最后四个字符</span></span><br></pre></td></tr></table></figure>



<p><strong><code>bitset</code>操作</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210908202903289.png" alt="image-20210908202903289"></p>
<p><strong>提取<code>bitset</code>的值</strong></p>
<p><code>to_ulong</code>和<code>to_ullong</code>操作都返回一个值，保存了与<code>bitset</code>对象相同的位模式。只有当<code>bitset</code>的大小小于等于对应的大小（<code>to_ulong</code>为<code>unsigned long</code>，<code>to_ullong</code>为<code>unsigned long long</code>）时，我们才能使用这两个操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulong = bitvec3.to_ulong();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ulong = &quot;</span> &lt;&lt; ulong &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<code>bitset</code>不能放入给定类型中，则这两个操作会抛出一个<code>overflow_error</code>异常。</p>
</blockquote>
<p><strong>使用<code>bitset</code></strong></p>
<p>用<code>bitset</code>代替<code>unsigned long</code>表示30个学生的测验结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> status;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> quizA = <span class="number">0</span>;</span><br><span class="line">quizA |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>; <span class="comment">//指出第27个学生通过了测验</span></span><br><span class="line">status = quizA &amp; (<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>); <span class="comment">//检查第27个学生是否通过了测验</span></span><br><span class="line">quizA &amp;= ~(<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>); <span class="comment">//第27个学生未通过测验</span></span><br><span class="line"><span class="comment">// 使用标准库类bitset完成等价的工作</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;30&gt; quizB; <span class="comment">//每个学生分配一位</span></span><br><span class="line">quizB.<span class="built_in">set</span>(<span class="number">27</span>);	<span class="comment">//指出第27个学生通过了测验</span></span><br><span class="line">status = quizB[<span class="number">27</span>];	<span class="comment">//检查第27个学生是否通过了测验</span></span><br><span class="line">quizB.reset(<span class="number">27</span>);	<span class="comment">//第27个学生未通过测验</span></span><br></pre></td></tr></table></figure>



<h4 id="17-3-正则表达式"><a href="#17-3-正则表达式" class="headerlink" title="17.3 正则表达式"></a>17.3 正则表达式</h4><p><strong>正则表达式</strong>是一种描述字符序列的方法。</p>
<p>它是新标准库的一部分，RE库定义在头文件<code>regex</code>中，它包含多个组件，列于下表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909171843763.png" alt="image-20210909171843763"></p>
<p>​    函数<code>regex_match</code>和<code>regex_search</code>确定一个给定字符序列与一个给定<code>regex</code>是否匹配。如果整个输入序列与表达式匹配。则<code>regex_match</code>函数返回<code>true</code>；如果输入序列中一个子串与表达式匹配，则<code>regex_match</code>函数返回<code>true</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909172202198.png" alt="image-20210909172202198"></p>
<p><strong>使用正则表达式库</strong></p>
<p>查找“i除非在c之后，否则必须在e之前”的单词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">&quot;[^c]ei&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//查找不在字符c之后的字符串ei</span></span><br><span class="line">pattern = <span class="string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="string">&quot;[[:alpha:]]*&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern)</span></span>;</span><br><span class="line">smatch results; <span class="comment">//定义一个对象保存搜索结果</span></span><br><span class="line"><span class="built_in">string</span> test_str = <span class="string">&quot;receipt freind theif receive&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(regex_search(test_str, results, r))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result.str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>正则表达式<code>[^c]</code>表明我们希望匹配任意不是<code>c</code>的字符。</p>
<p><code>&quot;[[:alpha:]]&quot;</code>匹配任意字母，符号<code>+</code>和<code>*</code>分别表示我们希望“一个或多个”或“零个或多个”匹配。因此<code>&quot;[[:alpha:]]*</code>将匹配零个或多个字母。</p>
<p>我们还定义了一个名为<code>results</code>的<code>smatch</code>对象，它将传递给<code>regex_search</code>。如果找到匹配子串，<code>results</code>将会保存匹配位置的细节信息。</p>
<p>函数<code>regex_search</code>在输入序列中只要找到一个匹配子串就会停止查找。因此，程序的输出将是：</p>
<p><code>freind</code></p>
<p><strong>指定regex对象的选项</strong></p>
<p>标志位控制<code>regex</code>对象的处理过程。下表列出了最后6个标志指出编写正则表达式所用的语言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909174542920.png" alt="image-20210909174542920"></p>
<p>我们可以编写一个正则表达式来识别C文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;[[:alpha:]]+\\.(cpp|cxx|cc)$&quot;</span>, regex::icase)</span></span>;</span><br><span class="line">smatch results;</span><br><span class="line"><span class="built_in">string</span> filename;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; filename)</span><br><span class="line">    <span class="keyword">if</span>(regex_search(filename, results, r))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>字符点<code>(.)</code>通常匹配任意字符。与C++一样，我们可以在字符之前放置一个反斜杠来去掉其特殊含义。由于反斜杠也是C++中的一个特殊字符，我们在字符串字面常量中必须连续使用两个反斜杠来告诉C++我们想要一个普通反斜杠字符。</p>
<p><strong>指定或使用正则表达式时的错误</strong></p>
<blockquote>
<p>需要意识到的非常重要的一点是，一个正则表达式的语法是否正确是在运行是解析的。</p>
</blockquote>
<p>如果我们编写的正则表达式存在问题，则在运行时标准库会抛出一个类型为<code>regex_error</code>的异常，类似标准库异常，<code>regex_error</code>有一个<code>what</code>操作描述发生了什么错误。<code>regex_error</code>还有一个名为<code>code</code>的成员，用来返回某个错误类型对应的数值编码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;[[:alpha:]]+\\.(cpp|cxx|cc)$&quot;</span>, regex::icase)</span></span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (regex_error e)</span><br><span class="line">&#123;<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">&quot;\ncode: &quot;</span> &lt;&lt; e.code() &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909180643253.png" alt="image-20210909180643253"></p>
<p>我们编译器定义了<code>code</code>成员，返回上表列出的错误类型的编号。与往常一样，编号从0开始。</p>
<blockquote>
<p>正则表达式的编译是一个非常慢的操作，特别是你使用了扩展的正则表达式语法或是复杂的正则表达式。特别是，如果你在一个循环中使用正则表达式，应该在循环外创建他，而不是在每部迭代是都编译它。</p>
</blockquote>
<p><strong>正则表达式类和输入序列类型</strong></p>
<p>​    例如，<code>regex</code>类保存类型<code>char</code>的正则表达式。标准库还定义了一个<code>wregex</code>类保存类型<code>wachar_t</code>，其操作与<code>regex</code>完全相同。两者唯一的差别是<code>wregex</code>的初始值必须使用<code>wchar_t</code>而不是<code>char</code>。</p>
<p>​    匹配和迭代器类型更为特殊。这些类型的差异不仅在于字符类型，还在于序列是在标准库<code>string</code>中还是在数组中：<code>smatch</code>表示<code>string</code>类型的输入序列；<code>cmatch</code>表示字符串数组序列；<code>wsmatch</code>表示宽字符串<code>wstring</code>输入；而<code>wcmatch</code>表示宽字符数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;[[:alpha:]]+\\.(cpp|cxx|cc)$&quot;</span>, regex::icase)</span></span>;</span><br><span class="line">smatch results;</span><br><span class="line"><span class="keyword">if</span>(regex_search(<span class="string">&quot;myfile.cc&quot;</span>, results, r))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码会编译失败，因为<code>match</code>参数的类型与输入序列的类型不匹配。如果我们希望搜索一个字符数组，就必须使用<code>cmatch</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cmatch results;</span><br><span class="line"><span class="keyword">if</span>(regex_search(<span class="string">&quot;myfile.cc&quot;</span>, results, r))</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909200536937.png" alt="image-20210909200536937"></p>
<p><strong>匹配与<code>Regex</code>迭代器类型</strong></p>
<p>我们可以使用<code>sregex_iterator</code>来获取所有匹配。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909201932306.png" alt="image-20210909201932306"></p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909201951650.png" alt="image-20210909201951650"></p>
<p><strong>使用sregex_iterator</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">&quot;[^c]ei&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//查找不在字符c之后的字符串ei</span></span><br><span class="line">pattern = <span class="string">&quot;[[:alpha:]]*&quot;</span> + pattern + <span class="string">&quot;[[:alpha:]]*&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern, regex::icase)</span></span>;</span><br><span class="line"><span class="comment">//反复调用regex_search来寻找文件中的所有匹配</span></span><br><span class="line"><span class="keyword">for</span>(sregex_iterator it(file.begin(), file.end(), r), end_it; </span><br><span class="line">   					it != end_it; ++it)</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><code>end_it</code>是一个空<code>sregex_iterator</code>，起到尾后迭代器的作用。</p>
<p><strong>使用匹配数据</strong></p>
<p>匹配类型有两个名为<code>prefix</code>和<code>suffix</code>的成员，分别返回表示输入序列中当前匹配之前和之后部分的<code>ssub_match</code>对象。一个<code>ssub_match</code>对象有两个名为<code>str</code>和<code>length</code>的成员，分别返回匹配的<code>string</code>和该<code>string</code>的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找匹配单元，并输出前后部分</span></span><br><span class="line"><span class="keyword">for</span>(sregex_iterator it(file.begin(), file.end(), r), end_it; </span><br><span class="line">   					it != end_it; ++it)&#123;</span><br><span class="line">	<span class="keyword">auto</span> pos = it-&gt;prefix().length();</span><br><span class="line">    pos = pos &gt; <span class="number">40</span> ? pos - <span class="number">40</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it -&gt; prefix().str().substr(pos) <span class="comment">//前缀的最后一部分</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n\t\t &gt;&gt;&gt;&quot;</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="string">&quot; &lt;&lt;&lt;\n&quot;</span></span><br><span class="line">        &lt;&lt; it-&gt;suffix().str().substr(<span class="number">0</span>, <span class="number">40</span>) <span class="comment">//后缀的第一部分</span></span><br><span class="line">        &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909203159288.png" alt="image-20210909203159288"></p>
<p><strong>使用子表达式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;([[:alpha:]]+)\\.(cpp|cxx|cc)$&quot;</span>, regex::icase)</span></span>;</span><br></pre></td></tr></table></figure>

<p>现在我们的模式包含两个括号括起来的子表达式：</p>
<ul>
<li><code>([[:alpha:]]+)</code>匹配一个或多个字符的序列</li>
<li><code>(cpp|cxx|cc)</code>，匹配文件扩展名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(regex_search(filename, results, r))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; results.str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//打印第一个子表达式</span></span><br></pre></td></tr></table></figure>

<p>第一个自匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。因此，本例模式中第一个子表达式，即表示文件名的子表达式，其位置为1，而文件扩展名对应的子表达式位置为2。</p>
<p>例如，如果文件名为<code>foo.cpp</code>，则<code>str(0)</code>将保存<code>foo.cpp</code>;</p>
<p><strong>子表达式用于数据验证</strong></p>
<p><code>\&#123;d&#125;</code>表示单个数字而<code>\&#123;d&#125;&#123;n&#125;</code>则表示一个n个数字的序列。</p>
<p>在方括号中的字符集合表示匹配这些字符中任意一个。</p>
<p>后接<code>?</code>的组件是可选的。</p>
<p>由于我们的模式包括括号。而括号是特殊字符，因此我们必须用<code>\(</code>和<code>\)</code>来表示括号使我们的模式的一部分而不是特殊字符。</p>
<p>美国的电话号码有十位数字，一个区号（通常放在括号里）和一个七位的本地号码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ]?)(\\d&#123;4&#125;)&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>(\\()?</code>表示区号部分可选的左括号。</li>
<li><code>(\\d&#123;3&#125;)</code>表示区号</li>
<li><code>(\\))?</code>表示区号部分可选的右括号</li>
<li><code>([-. ])?</code>表示区号部分可选的分隔符</li>
<li><code>(\\d&#123;3&#125;)</code>表示号码的下三位数字</li>
<li><code>([-. ]?)</code>表示可选的分隔符</li>
<li><code>(\\d&#123;4&#125;)</code>表示号码的最后四位数字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> phone = </span><br><span class="line">    <span class="string">&quot;(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ]?)(\\d&#123;4&#125;)&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;</span><br><span class="line">smatch m;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, s))&#123;</span><br><span class="line">    <span class="keyword">for</span>(sregex_iterator it(file.begin(), file.end(), r), end_it; </span><br><span class="line">   					it != end_it; ++it)</span><br><span class="line">        <span class="keyword">if</span>(valid(*it))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;valid:&quot;</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not valid:&quot;</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909212130136.png" alt="image-20210909212130136"></p>
<p>在一个合法的电话号码中，区号要么是完整的括号包围的，要么就是没有括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">const</span> smatch&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[<span class="number">1</span>].matched)</span><br><span class="line">        <span class="comment">//则区号后必须有一个右括号</span></span><br><span class="line">        <span class="keyword">return</span> m[<span class="number">3</span>].matched</span><br><span class="line">        		&amp;&amp; (m[<span class="number">4</span>].matched == <span class="number">0</span> || m[<span class="number">4</span>].str() == <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> !m[<span class="number">3</span>].matched</span><br><span class="line">        		&amp;&amp; m[<span class="number">4</span>].str() == m[<span class="number">6</span>].str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用regex_replace</strong></p>
<p>当我们希望在输入序列中查找并替换一个正则表达式时，可以调用<code>regex_replace</code>，类似搜索函数，它接受一个输入字符序列和一个<code>regex</code>对象，不同的是，它还接受一个描述我们想要的输出形式的字符串。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909213315550.png" alt="image-20210909213315550"></p>
<p>我们用一个符号<code>$</code>后跟子表达式的索引号来表示一个特定的子表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> fmt = <span class="string">&quot;$2.$5.$7&quot;</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;</span><br><span class="line"><span class="built_in">string</span> number = <span class="string">&quot;(908) 555-1800&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_replace(number, r, fmt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 908.555.1800</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> phone = </span><br><span class="line">    	<span class="string">&quot;(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ]?)(\\d&#123;4&#125;)&quot;</span>;</span><br><span class="line">	<span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;</span><br><span class="line">	smatch m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">string</span> fmt = <span class="string">&quot;$2.$5.$7&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, s))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;regex_replace(s, r, fmt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>用来控制匹配和格式的标志</strong></p>
<p>标准库还定义了用来替换过程中控制匹配或格式的标志。这些标志可以传递给函数<code>regex_search</code>或<code>regex_match</code>或是类<code>smatch</code>的<code>format</code>成员。</p>
<p>匹配和格式化标志的类型为<code>match_flag_type</code>。这些值都定义在名为<code>regex_constants</code>的命名空间中。<code>regex_constants</code>也是定义在命名空间<code>std</code>中的命名空间。为了使用<code>regex_constants</code>中的名字，我们必须在名字前同时加上两个命名空间的限定符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::regex_constants::format_no_copy;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210909214654229.png" alt="image-20210909214654229"></p>
<h4 id="17-4-随机数"><a href="#17-4-随机数" class="headerlink" title="17.4 随机数"></a>17.4 随机数</h4><p>在新标准出来之前，C和C++都依赖与一个简单的C库函数<code>rand</code>来生成随机数。</p>
<p>定义在头文件<code>random</code>中的随机数库通过一组协作的类来解决这些问题：随机数引擎类和随机数分布类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210915223720295.png" alt="image-20210915223720295"></p>
<p><strong>随机数引擎和分布</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">default_random_engine e; <span class="comment">//生成随机无符号数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210915224318567.png" alt="image-20210915224318567"></p>
<p><strong>分布类型和引擎</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成0到9之间（包含）均匀分布的随机数</span></span><br><span class="line"><span class="function">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">default_random_engine e; <span class="comment">//生成无符号随机整数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，我们传递给分布对象的是引擎对象本身，即<code>u(e)</code>。如果我们将调用写成<code>u(e())</code>，含义就变为将<code>e</code>生成的下一个值传递给<code>u</code>，会导致一个编译错误。我们传递的是引擎本身，而不是它生成的下一个值，原因是某些分布可能需要调用引擎多次才能得到一个值。</p>
<blockquote>
<p>当我们说随机数发生器时，是指分布对象和引擎对象的组合。</p>
</blockquote>
<p><strong>引擎生成一个数值序列</strong></p>
<p>即使生成的数看起来是随机的，但对一个给定的发生器，每次运行程序它都会返回相同的数值序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">bad_randVec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    default_random_engine e;</span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">        ret.push_back(u(e));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用这个函数都会返回相同的<code>vector</code>;</p>
<p>编写此函数的正确方法是将引擎和关联的分布对象定义为<code>static</code>的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">bad_randVec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> default_random_engine e;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">        ret.push_back(u(e));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>e</code>和<code>u</code>是<code>static</code>的，因此他们在函数调用之间会保持住状态。第一次调用会使用<code>u(e)</code>生成的序列中前100个随机数，第二次调用会获得接下来100个，以此类推。 </p>
<p><strong>设置随机数发生器种子</strong></p>
<p>为引擎设置种子有两种方式：再创将引擎对象时提供种子，或者调用引擎的<code>seed</code>成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">default_random_engine e1; <span class="comment">//使用默认种子</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">2147</span>)</span></span>;</span><br><span class="line">default_random_engine e3;</span><br><span class="line">e3.seed(<span class="number">32676</span>);</span><br></pre></td></tr></table></figure>

<p>最常用的方法是调用系统函数<code>time</code>。这个函数定义在头文件<code>ctime</code>中，它返回一个特定时刻到当前经历过多少秒。函数<code>time</code>接受单个指针函数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e1</span><span class="params">(time(<span class="number">0</span>))</span></span>; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果程序作为一个自动过程的一部分反复运行，将<code>time</code>的返回值作为种子的方式就无效了；它可能多次使用的都是相同的种子。</p>
</blockquote>
<p><strong>其他随机数分布</strong></p>
<p>程序常需要一个随机浮点数的源，特别是，程序经常需要0到1之间的随机数。</p>
<p>我们可以定义一个<code>uniform_real_distribution</code>类型的对象，并让标准库来处理从随机整数到随机浮点数的映射。与处理<code>uniform_int_distribution</code>一样，在定义对象时，我们指定最小值和最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line"><span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210918225327560.png" alt="image-20210918225327560"></p>
<p><strong>使用分布的默认结果类型</strong></p>
<p>每个分布模板都有一个默认模板实参，生成浮点值的分布类型默认生成<code>double</code>值，而生成整型值的分布默认生成<code>int</code>值。</p>
<p><strong>生成非均匀分布的随机数</strong></p>
<p>除了正确生成在指定范围内的数之外，新标准库的另一个优势是可以生成非均匀分布的随机数。实际上，新标准定义了20种分布类型，这些类型在附录A.3。</p>
<p>作为一个例子，我们生成一个正态分布的值的序列。</p>
<p>由于<code>normal_distribution</code>生成浮点值，我们的程序使用头文件<code>cmath</code>中的<code>lround</code>函数将每个随机数舍入到最接近的整数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="function">normal_distribution&lt;&gt; <span class="title">n</span><span class="params">(<span class="number">4</span>,<span class="number">1.5</span>)</span></span>; <span class="comment">//均值4，标准差1.5</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">vals</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">200</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v = lround(n(e)); </span><br><span class="line">    <span class="keyword">if</span>(v &lt; vals.size())</span><br><span class="line">        ++vals[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>bernouli_distribution类</strong></p>
<p>我们注意到有一个分布不接受模板参数，即<code>bernouli_distribution</code>，因为它是一个普通类，而非模板。此分布总是返回一个<code>bool</code>值。它返回<code>true</code>的概率是一个常数，此概率的默认值是0.5；</p>
<blockquote>
<p>由于引擎返回相同的随机数序列，所以我们必须在循环外声明引擎对象。否则，每步循环都会创建一个新的引擎，从而每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外定义。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bernouli_distribution <span class="title">b</span><span class="params">(<span class="number">.55</span>)</span></span>; <span class="comment">//改变概率</span></span><br></pre></td></tr></table></figure>



<h4 id="17-5-IO库再探"><a href="#17-5-IO库再探" class="headerlink" title="17.5 IO库再探"></a>17.5 IO库再探</h4><p>在本节中，我们将介绍三个更为特殊的IO库特性：格式控制、未格式化IO和随机访问。</p>
<p><strong>格式化输入与输出</strong></p>
<p>除了条件状态外，每个<code>iostream</code>对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整形值是几进制，浮点值的精度、一个输出元素的宽度等。</p>
<p>标准库定义了一组<strong>操纵符</strong>来修改流的格式状态，一个操作符是一个函数或是一个对象，会影响流的状态，并能用作输入货输出运算符的运算对象。</p>
<p>我们已经在程序中使用多一个操作符——<code>endl</code>，但是<code>endl</code>不是普通值，而是一个操作：它输出一个换行符并刷新缓冲区。</p>
<p><strong>很多操作符改变格式状态</strong></p>
<p>操作符用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。大多数改变格式状态的操作符都是设置、复原成对的：一个操作符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格式。</p>
<blockquote>
<p>当操作符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>
</blockquote>
<p><strong>控制布尔值的格式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="literal">false</span> </span><br><span class="line">    &lt;&lt; boolalpha </span><br><span class="line">    &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//程序输出 1 0 ture false</span></span><br></pre></td></tr></table></figure>

<p>一旦向<code>cout</code>写入了<code>boolalpha</code>，我们就改变了<code>cout</code>打印<code>bool</code>值的方式。后续打印<code>bool</code>值得操作都会打印<code>true</code>或者<code>false</code>。</p>
<p>为了取消<code>cout</code>格式状态的改变，我们使用<code>noboolalpha</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bool_val = get_status();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha</span><br><span class="line">    &lt;&lt; bool_val</span><br><span class="line">    &lt;&lt; noboolalpha;</span><br></pre></td></tr></table></figure>



<p><strong>指定整形值的进制</strong></p>
<p>我们可以通过操作符<code>hex</code>、<code>oct</code>和<code>dec</code>将其改为十六进制、八进制或是改回十进制。</p>
<blockquote>
<p>上述操作符只影响整形运算符，浮点值的表示形式不受影响。</p>
</blockquote>
<p><strong>在输出中指出进制</strong></p>
<p>当对流应用<code>showbase</code>操作符时，会在输出结果中显示进制。</p>
<ul>
<li>前导<code>0x</code>表示十六进制。</li>
<li>前导<code>0</code>表示八进制。</li>
<li>无前导字符表示十进制。</li>
</ul>
<p>操作符<code>noshowbase</code>恢复<code>cout</code>的状态，从而不再显示整形值的进制。</p>
<p>默认情况下，十六进制会以小写打印，前导字符也是小写的<code>x</code>。我们可以通过使用<code>uppercase</code>操作符来输出大写的<code>X</code>并将十六进制数字<code>a-f</code>大写输出。</p>
<p><strong>指定打印精度</strong></p>
<p>我们可以通过调用IO对象的<code>precision</code>成员或使用<code>setprecision</code>操纵符来改变精度。<code>precision</code>成员是重载的。一个版本接受一个<code>int</code>值，将精度设置为此值，并返回久精度值。另一版本不接受参数，返回当前精度值。<code>setprecision</code>操作符接受一个参数，用来设置精度。</p>
<blockquote>
<p>操作符<code>setprecision</code>和其他接受参数的操纵符都定义在头文件<code>iomanip</code>中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.precision(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//另一种方法</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; precision(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210924220703276.png" alt="image-20210924220703276"></p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210924220730225.png" alt="image-20210924220730225"></p>
<p>操纵符<code>scientific</code>改变流的状态来使用科学计数法。操纵符<code>fixed</code>改变流的状态流使用定点十进制。</p>
<p>在执行<code>scientific、fixed</code>或<code>hexfloat</code>后，精度值控制的时小数点后面的数字位数，而默认情况下精度值指定的事数字的总位数——既包括小数点之后的数字也包括小数点之前的数字。</p>
<p><strong>打印小数点</strong></p>
<p><code>showpoint</code>操纵符强制打印小数点</p>
<p><strong>输出旁白</strong></p>
<p>我们常常需要非常精细地控制数据格式。</p>
<ul>
<li><code>setw</code>指定下一个数字或字符串值的最小空间。</li>
<li><code>left</code>表示左对齐输出。</li>
<li><code>right</code>表示右对齐输出，右对齐是默认格式。</li>
<li><code>internal</code>控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间。</li>
<li><code>setfill</code>允许指定一个字符代替默认的空格来补白输出。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210924222145673.png" alt="image-20210924222145673"></p>
<p><strong>控制输入格式</strong></p>
<p>输入运算符会忽略空白符（空格符、制表符、换行符、换纸符和回车符）</p>
<p>操纵符<code>noskipws</code>会令输入运算符读取空白符，而不是跳过他们。为了恢复默认行为，我们可以使用<code>skipws</code>操纵符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; noskipws; <span class="comment">//设置cin读取空白符</span></span><br></pre></td></tr></table></figure>



<p><strong>未格式化的输入输出操作</strong></p>
<p>标准库还提供了一组底层操作，支持未格式化IO。这些操作允许我们将一个流当做一个无解释的字节序列来处理。</p>
<p><strong>单字节操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>.get(ch))</span><br><span class="line">    <span class="built_in">cout</span>.put(ch);</span><br></pre></td></tr></table></figure>

<p>此程序保留输入中的空白符，其输出与输入完全相同。它的执行过程与前一个使用<code>noskipws</code>的程序完全相同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210924222931921.png" alt="image-20210924222931921"></p>
<p><strong>将字符放回输入流</strong></p>
<p><code>peek</code>返回输入流中下一个字符的副本，但不会将它从流中删除，<code>peek</code>返回的值仍然留在流中。</p>
<p><code>unget</code>使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用<code>unget</code>。</p>
<p><code>putback</code>是更特殊版本的<code>unget</code>;它退回从流中读取的最后一个值。但它接受一个参数，此参数必须与最后读取的值相同。</p>
<p><strong>从输入操作返回的int值</strong></p>
<p>头文件<code>cstdio</code>定义了一个名为<code>EOF</code>的<code>const</code>，这样我们可以用它来检测从<code>get</code>返回的值是否是文件尾，而不必记忆表示文件尾的实际数值。对我们而言，重要的是，用一个<code>int</code>来保存从这些函数返回的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">cin</span>.get()) != EOF)</span><br><span class="line">    <span class="built_in">cout</span>.put(ch);</span><br><span class="line"><span class="comment">//循环并输出所有数据</span></span><br></pre></td></tr></table></figure>



<p><strong>多字节操作</strong></p>
<p>一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话。这些操作是重要的，但类似其他底层操作，这些操作也容易出错。特别是，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210928224341429.png" alt="image-20210928224341429"></p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210928224402125.png" alt="image-20210928224402125"></p>
<p><code>get</code>和<code>getline</code>函数接受相同的参数，他们的行为类似但不相同。两个函数都一直读取数据，直到下面条件之一发生：</p>
<ul>
<li>已读取了<code>size</code>个字符</li>
<li>遇到了文件尾</li>
<li>遇到了分隔符</li>
</ul>
<p>两个函数的差异是处理分隔符的方式：<code>get</code>将分隔符留作<code>istream</code>中的下一个字符，而<code>getline</code>则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在<code>sink</code>中。</p>
<blockquote>
<p>常见的错误是本想从流中删除分隔符，但却忘了做。</p>
</blockquote>
<p><strong>确定读取了多少个字符</strong></p>
<p>某些操作从输入读取末知个数的字节。我们可以调用<code>gcount</code>来确定最后一个未格式化输入操作读取了多少个字符。应该在任何后续未格式化输入操作之前调用<code>gcount</code>。特别是，将字符退回流的单字符操作也属于末格式化输入操作。如果在调用<code>gcount</code>之前调用了<code>peek、unget</code>或<code>putback</code>则<code>gcount</code>的返回值为 0。</p>
<p>一个常见的错误是将<code>get</code>或<code>peek</code>的返回值赋予一个<code>char</code>而不是<code>int</code>。</p>
<p>例如，下面的循环永远不会停止：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">cin</span>.get()) != EOF)</span><br><span class="line">    <span class="built_in">cout</span>.put(ch);</span><br><span class="line"><span class="comment">//循环并输出所有数据</span></span><br></pre></td></tr></table></figure>

<p>问题出在当<code>get</code>返回<code>EOF</code>时，此值会被转换为一个<code>unsigned char</code>。转换得到的值与<code>EOF</code>的<code>int</code>值不在相等，因此循环永远不会停止。</p>
<p><strong>流随机访问</strong></p>
<p>​    各种流类型通常都支持对流中数据的随机访问，标准库提供了一对函数，来定位<code>seek</code>到流中给定的位置，以及告诉<code>tell</code>我们当前位置。</p>
<p>​    在大多数系统中，绑定到<code>cin、cout、cerr</code>和<code>clog</code>的流不支持随机访问。对于这些流我们可以调用<code>seek</code>和<code>tell</code>函数，但在运行时会出错，将流置于一个无效状态。</p>
<blockquote>
<p>由于<code>istream</code>和<code>ostream</code>类型通常不支持随机访问，所以本节剩余内容只适用于<code>fstream</code>和<code>sstream</code>类型。</p>
</blockquote>
<p><strong><code>seek</code>和<code>tell</code>函数</strong></p>
<p>​    标准库实际上定义了两对<code>seek</code>和<code>tell</code>函数，一对用于输入，一对用于输出流。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210929093234112.png" alt="image-20210929093234112"></p>
<p><strong>重定位标记</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seekg(new_position); <span class="comment">// 将读标记移动到指定的pos_type类型的位置</span></span><br><span class="line">seekg(offset, from); <span class="comment">//将读标记移动到距from 偏移量为offset的位置</span></span><br></pre></td></tr></table></figure>

<p>参数<code>new_position</code>和<code>offset</code>的类型分别是<code>pos_type</code>和<code>off_type</code>，这两个类型都是机器相关的，他们定义在头文件<code>istream</code>和<code>ostream</code>中。</p>
<p><strong>访问标记</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> writeStr; <span class="comment">//输出stringstream</span></span><br><span class="line"><span class="built_in">ostringstream</span>::pos_type mark = writeStr.tellp();</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(cancelEntry)</span><br><span class="line">    writeStr.seekp(mark);</span><br></pre></td></tr></table></figure>



<p><strong>读写同一个文件</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">inOut</span><span class="params">(<span class="string">&quot;copyOut&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 fsteam::ate | fstream::in | fstream::out)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!inOut)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Unable to open file!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inOut 以 ate模式打开，因此一开始就定义到文件尾部</span></span><br><span class="line">    <span class="keyword">auto</span> end_mark = inOut.tellg();</span><br><span class="line">    inOut.seekg(<span class="number">0</span>, fstream::beg); <span class="comment">//重新定义到文件开始</span></span><br><span class="line">    <span class="keyword">size_t</span> cnt = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span>(inOut &amp;&amp; inOut.tellg() != end_mark</span><br><span class="line">         &amp;&amp; getline(inOut, line))&#123; <span class="comment">//且还可获得一行输入</span></span><br><span class="line">        cnt += line.size() + <span class="number">1</span>; <span class="comment">//+1表示换行符</span></span><br><span class="line">        <span class="keyword">auto</span> mark = inOut.tellg(); <span class="comment">//记录读取位置</span></span><br><span class="line">        inOut.seekp(<span class="number">0</span>, fstream::end);</span><br><span class="line">        inOut &lt;&lt; cnt;</span><br><span class="line"> 		<span class="comment">//如果读取位置不是最后一行，打印一个分隔符</span></span><br><span class="line">        <span class="keyword">if</span>(mark != end_mark) inOut &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        inOut.seekg(mark);</span><br><span class="line">    &#125;</span><br><span class="line">    inOut.seek(<span class="number">0</span>, fstream::end);</span><br><span class="line">    inOut &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们的程序向输入文件写入数据，因此不能通过文件尾来判断是否停止读取，而是应该在达到原数据的末尾时停止。</p>
<h3 id="第18章-用于大型程序的工具"><a href="#第18章-用于大型程序的工具" class="headerlink" title="第18章 用于大型程序的工具"></a>第18章 用于大型程序的工具</h3><h4 id="18-1-异常处理"><a href="#18-1-异常处理" class="headerlink" title="18.1 异常处理"></a>18.1 异常处理</h4><p><strong>异常处理</strong>机制允许程序中独立开发的部分能够就运行时出现的问题进行通信并作出相应的处理。</p>
<p><strong>抛出异常</strong></p>
<p>在C++语言中，我们通过<code>throw</code>一条表达式来引发一个异常。</p>
<p>当执行一个<code>throw</code>时，跟在<code>throw</code>后面的语句将不再被执行。相反，程序的控制权从<code>throw</code>转移到与之匹配的<code>catch</code>模块。该<code>catch</code>可能是同一个函数中的局部<code>catch</code>，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义：</p>
<ul>
<li>沿着调用链的函数可能会提早退出。</li>
<li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。</li>
</ul>
<blockquote>
<p>一个异常如果没有被捕获，则它将终止当前的程序。</p>
</blockquote>
<p><strong>异常对象</strong></p>
<p>异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，<code>throw</code>语句中的表达式必须拥有完全类型。</p>
<p>当异常处理完毕后，异常对象被销毁。</p>
<p>当我们抛出一条表达式后，该表达式的静态编译时类型决定了异常对象的类型，牢记这一点，因为很多情况下程序抛出的表达式类型来自于某个继承体系，如果一条<code>throw</code>表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出对象将被切掉一部分，只有基类部分被抛出。</p>
<blockquote>
<p>抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。</p>
</blockquote>
<p><strong>捕获异常</strong></p>
<p>​    在搜索<code>catch</code>语句的过程中，我们最终找到的是<code>catch</code>未必是异常的最佳匹配。相反，挑选出来的的应该是第一个与异常匹配的<code>catch</code>语句。因此，越是专门的<code>catch</code>越应该置于整个<code>catch</code>列表的前端。</p>
<p><strong>重新抛出</strong></p>
<p>​    有时，一个单独的<code>catch</code>语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的<code>catch</code>可能会决定由调用链更上一层的函数接着处理异常。一条<code>catch</code>语句通过<strong>重新抛出</strong>的操作将异常传递给另外一个<code>catch</code>语句。这里的重新抛出仍然是一条<code>throw</code>语句，只不过不包含任何表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure>

<p>空的<code>throw</code>语句只能出现在<code>catch</code>语句或<code>catch</code>语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空<code>throw</code>语句，编译器将调用<code>terminate</code>。</p>
<p>很多时候，<code>catch</code>语句会改变其参数的内容。如果在改变了参数的内容后<code>catch</code>语句重新抛出异常，则只有当<code>catch</code>异常声明是引用类型时我们对参数所做的改变才会被保留并继续传播：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (my_error &amp;eObj)&#123;</span><br><span class="line">    eObj.status = errCodes::severeErr; <span class="comment">//修改了异常对象</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (other_error eObj)&#123;</span><br><span class="line">    eObj.status = errCodes::badErr; <span class="comment">//只修改了异常对象的局部副本</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>捕获所有异常的处理代码</strong></p>
<p>为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理称为<strong>捕获所有异常</strong>。</p>
<p><code>catch(...)</code>通常与重新抛出语句一起使用，其中<code>catch</code>执行当前局部能完成的工作，随后重新抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 这里的操作将引发并抛出一个异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<code>catch(...)</code>与其他几个<code>catch</code>语句一起出现，则<code>catch(...)</code>必须放在最后的位置。出现在捕获所有异常语句后面的<code>catch</code>语句将永远不会被匹配。</p>
</blockquote>
<p><strong>函数try语句块与构造函数</strong></p>
<p>要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数try语句块。函数<code>try</code>语句块使得一组<code>catch</code>语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il) <span class="keyword">try</span>:</span><br><span class="line">	data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(il))&#123;</span><br><span class="line">        <span class="comment">/*空函数体*/</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc &amp;e)&#123;handle_out_of_meory(e);&#125;</span><br></pre></td></tr></table></figure>

<p>与这个<code>try</code>关联的<code>catch</code>既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。</p>
<blockquote>
<p>处理构造函数初始值异常的唯一方法是将构造函数写成函数<code>try</code>语句块。</p>
</blockquote>
<p><strong>noexcept异常说明</strong></p>
<p>我们可以通过提供<code>noexcept</code>说明指定某个某个函数不会抛出异常，其形式是关键字<code>noexcept</code>紧跟在函数的参数列表后面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 可能抛出异常</span></span><br></pre></td></tr></table></figure>

<p>对于一个函数而言，<code>noexcept</code>说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定<code>noexcept</code>。在<code>typedef</code>或类型别名中则不能出现<code>noexcept</code>。在成员函数中，<code>noexcept</code>说明符需要跟在<code>const</code>及引用限定符之后，而在<code>final、override</code>或虚函数的=0之前。</p>
<p><strong>异常说明的实参</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>; <span class="comment">//不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;<span class="comment">// 可能抛出异常</span></span><br></pre></td></tr></table></figure>



<p><strong><code>noexcept</code>运算符</strong></p>
<p><code>noexcept</code>运算符是一个一元运算符，返回值是一个<code>bool</code>类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。</p>
<p>因为我们声明<code>recoup</code>时使用了<code>noexcept</code>说明符，所以下面的表达式的返回值为<code>true</code>；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noexcept</span>(recoup(i));</span><br></pre></td></tr></table></figure>

<p>更为普遍的形式是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noexcept</span>(e)</span><br></pre></td></tr></table></figure>

<p>当<code>e</code>调用的所有函数都做了不抛出说明且<code>e</code>本身不含有<code>throw</code>语句时，上述表达式为<code>true</code>；否则<code>noexcept(e)</code>返回<code>false</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>; <span class="comment">//f和g的异常说明一致。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>noexcept</code>有两层含义：当跟在函数参数列表后面时它时异常说明符；而当作为<code>noexcept</code>异常说明的<code>bool</code>实参出现时，它是一个运算符。</p>
</blockquote>
<p><strong>异常说明与指针、虚函数和拷贝控制</strong></p>
<p>函数指针及指针所指的函数必须具有一致的异常说明。如果为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。如果我们显示或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>) <span class="keyword">noexcept</span> = recoup; <span class="comment">//都不会抛出异常</span></span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) = recoup; <span class="comment">//正确，pf2可能抛出异常，两者互补干扰</span></span><br><span class="line"></span><br><span class="line">pf1 = alloc; <span class="comment">//错误</span></span><br><span class="line">pf2 = alloc; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚西数也必须做出同样的<br>承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应两数既可以允许拋出<br>异常，也可以不允许抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//不会抛出异常</span></span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">//错误</span></span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">//正确</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>异常类层次</strong></p>
<p>标准库异常类的继承体系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20211025225929926.png" alt="image-20211025225929926"></p>
<p><strong>书店应用程序的异常类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">out_of_stock</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::runtime_error&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="title">out_of_stock</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>:</span></span><br><span class="line"><span class="function">    		<span class="title">std::runtime_error</span><span class="params">(s)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">isbn_mismatch</span>:</span><span class="keyword">public</span> <span class="built_in">std</span>::logic_error&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="title">isbn_mismatch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>:</span></span><br><span class="line"><span class="function">    		<span class="title">std::logic_error</span><span class="params">(s)</span> </span>&#123;&#125;</span><br><span class="line">    	isbn_mismatch(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s,</span><br><span class="line">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;rhs):</span><br><span class="line">    <span class="built_in">std</span>::logic_error(s), left(lhs), right(rhs)&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> left, right;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>exception</code>划分为两个大的类别：运行时错误和逻辑错误。</p>
<p><strong>使用我们自己的异常类型</strong></p>
<p>我们可以为<code>Sales_data</code>类定义一个复合加法运算符，当检测到参与加法的两个<code>ISBN</code>编号不一致时抛出名为<code>isbn_mismatch</code>的异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data&amp;</span><br><span class="line">    Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isbn != rhs.isbn())</span><br><span class="line">        <span class="keyword">throw</span> isbn_mismatch(<span class="string">&quot;wrong isbns&quot;</span>, isbn(), rhs.isbn());</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="18-2-命名空间"><a href="#18-2-命名空间" class="headerlink" title="18.2 命名空间"></a>18.2 命名空间</h4><p>多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>。</p>
<p><strong>命名空间定义</strong></p>
<p>一个命名空间的定义包含两部分：首先是关键字<code>namespace</code>，随后是命名空间的名字。</p>
<blockquote>
<p>命名空间作用域后面无需分号。</p>
</blockquote>
<p><strong>命名空间可以是不连续的</strong></p>
<p>命名空间可以定义在几个不同的部分，这一点与其他作用域不太一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp&#123;</span><br><span class="line">    <span class="comment">//相关声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能是定义了一个名为<code>nsp</code>的新命名空间，也可能为已经存在的命名空间添加一些新成员。</p>
<p><strong>定义命名空间成员</strong></p>
<p>假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义的名字的简写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> cpluscplus_primer&#123;</span><br><span class="line">    <span class="built_in">std</span>::istream&amp;</span><br><span class="line">    <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; in, Sales_data&amp; s)</span><br><span class="line">    &#123;<span class="comment">/**/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpluscplus_primer::Sales_data</span><br><span class="line">cpluscplus_primer::<span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Sales_data&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Sales_data <span class="title">ret</span><span class="params">(lhs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命名空间<code>cplusplus_primer</code>内部，我们可以直接使用该命名空间的其他成员，比如在上面的代码中，可以直接使用<code>Sales_data</code>定义函数的形参。</p>
<p><strong>模板特例化</strong></p>
<p>模板特例化必须定义在原始模板所属的命名空间中。</p>
<p>我们在命名空间中声明了特例化，就能在命名空间外部定义它了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Sales_data&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>全局空间命名</strong></p>
<p>因为全局空间作用域是隐式的，所以它并没有名字。下面的形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::member_name</span><br></pre></td></tr></table></figure>

<p>表示全局命名空间中的一个成员。</p>
<p><strong>嵌套的命名空间</strong></p>
<p>嵌套命名空间指定义在其他命名空间中的命名空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer&#123;</span><br><span class="line">    <span class="keyword">namespace</span> QueryLib &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span>&#125;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在嵌套的命名空间<code>QueryLib</code>中声明的类别名是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cplusplus_primer::QueryLib::Query</span><br></pre></td></tr></table></figure>



<p><strong>内联命名空间</strong></p>
<p>新标准引入了一种新的嵌套命名空间，称为内联命名空间。</p>
<p>内联命名空间中的名字可以被外层命名空间直接使用。</p>
<p>定义内联命名空间的方式是在关键字<code>namespace</code>前添加关键字<code>inline</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> FifthEd&#123;</span><br><span class="line">    <span class="comment">//该命名空间表示本书第5版的代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> FifthEd&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字<code>inline</code>必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写<code>inline</code>，也可以不写。</p>
<p>当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。例如，我们可以把当前版本的所有代码都放在一个内联命名空间中，而之前版本的代码都放在一个非内联命名空间中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FourthEd&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Item_base</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Query_base</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="comment">// 本书第4版用到的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假定每个命名空间都定义在同名的头文件中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpluscplus_primer&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FifthEd.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;FourthEd.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为<code>FifthEd</code>是内联的，所以形如<code>cpluscplus_primer::</code>的代码可以直接获得<code>FifthEd</code>的成员。而<code>cpluscplus_primer::FourthEd::Query_base</code>则使用早期版本的代码。</p>
<p><strong>未命名的命名空间</strong></p>
<p><strong>未命名的命名空间</strong>是指关键字<code>namespace</code>后紧接花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：他们在第一次使用前创建，并且直到程序结束才销毁。</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件夹。</p>
<p>定义在未命名的命名空间中的名字可以直接使用，如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二义性问题</span></span><br><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。</p>
</blockquote>
<p><strong>使用命名空间成员</strong></p>
<p>​    <strong>命名空间的别名</strong>使得我们可以为命名空间的名字设定一个短得多的同义词。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primer = cpluscplus_primer;</span><br></pre></td></tr></table></figure>

<p>​    命名空间的别名也可以指向一个嵌套的命名空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qlib = cpluscplus_primer::QueryLib;</span><br><span class="line">Qlib::Query q;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p>
</blockquote>
<p><strong><code>using</code>声明</strong></p>
<p>​    一条<code>using</code>声明语句一次只引入命名空间的一个成员。在此过程中，外层作用域的同名实体将被隐藏。</p>
<p><strong><code>using</code>指令</strong></p>
<p>​    <code>using</code>指令和<code>using</code>声明类似的地方是，我们可以通过使用命名空间名字的简写形式；和<code>using</code>声明不同的地方是，我们无法控制哪些名字是可见的，因此，所有名字都是可见的。</p>
<p>​    <code>using</code>指令以关键字<code>using</code>开始，后面是关键字<code>namespace</code>以及命名空间的名字。</p>
<p><strong><code>using</code>指令示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> blip&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">16</span>, j = <span class="number">15</span>, k = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//正确：blip的j隐藏在命名空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> blib; <span class="comment">// using 指令</span></span><br><span class="line">    ++i; </span><br><span class="line">    ++j; <span class="comment">//二义性错误</span></span><br><span class="line">    ++::j; <span class="comment">//正确，全局j</span></span><br><span class="line">    ++blip::j; <span class="comment">//正确</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">97</span>; <span class="comment">//隐藏了blip::k</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>using</code>指令一次性注入了某个命名空间的所有名字，这种做法充满了风险，可能会导致命名空间的污染问题，也会引发二义性错误。</p>
</blockquote>
<p><strong>类、命名空间与作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C1</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        	C1(): i(<span class="number">0</span>), j(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> k;&#125; </span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> h;&#125; <span class="comment">//错误：h未定义</span></span><br><span class="line">        	<span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        	<span class="keyword">int</span> i;</span><br><span class="line">        	<span class="keyword">int</span> j;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> h = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::C1::f3() &#123;<span class="keyword">return</span> h;&#125; <span class="comment">//正确，返回A::h</span></span><br></pre></td></tr></table></figure>

<p>名字必须先声明后使用，因此<code>f2</code>的<code>return</code>语句无法通过编译。</p>
<p><strong>友元声明与实参相关的查找</strong></p>
<p>当类声明了一个友元时，该友元声明并没有使得友元本身可见。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">        <span class="comment">// 两个友元，在友元声明之前没有其他的声明</span></span><br><span class="line">        <span class="comment">// 这些函数隐式的成为命名空间A的成员</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">//除非另有声明，否则不会被找到</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>; <span class="comment">//根据实参相关的查找规则可以被找到</span></span><br><span class="line">        </span><br><span class="line">    &#125;；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::C cobj;</span><br><span class="line">    f(cobj); <span class="comment">//正确</span></span><br><span class="line">    f2(); <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>f</code>接受一个类类型的实参，而且<code>f</code>在<code>C</code>所属的命名空间进行了隐式的声明，所以<code>f</code>能被找到，相反，因为<code>f2</code>没有形参，所以它无法被找到。</p>
<p><strong>重载与命名空间</strong></p>
<p><strong>重载与using声明</strong></p>
<p><code>using</code>声明语句声明的是一个名字，而不是一个特定的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">NS::print</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//错误：不能指定形参列表</span></span><br><span class="line"><span class="keyword">using</span> NS::print; <span class="comment">//正确：using声明只声明一个名字</span></span><br></pre></td></tr></table></figure>

<p>当我们为函数书写<code>using</code>声明时，该函数的所有版本都被引入到当前作用域中。</p>
<p><strong>重载与using指示</strong></p>
<p><code>using</code>指示将命名空间的成员提升到外层作用域，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> libs_R_us&#123;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> libs_R_us;</span><br><span class="line"><span class="comment">// print调用此时的候选函数有三个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;Value: &quot;</span>);  <span class="comment">//调用全局函数print(const string &amp;)</span></span><br><span class="line">    print(ival); <span class="comment">// 调用 libs_R_us::print(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于using指示来说，引入一个与已有函数形参列表完全一样的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。</p>
<p><strong>跨越多个using指示的重载</strong></p>
<p>如果存在多个<code>using</code>指示，则来自每个命名空间的名字都会成为候选函数集的一部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AW&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Primer&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> AW;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Primer;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">//此时的print有三个候选函数</span></span><br></pre></td></tr></table></figure>





<h4 id="18-3-多重继承与虚继承"><a href="#18-3-多重继承与虚继承" class="headerlink" title="18.3 多重继承与虚继承"></a>18.3 多重继承与虚继承</h4><p><strong>多重继承</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> ： <span class="title">public</span> <span class="title">Bear</span>, <span class="title">public</span> <span class="title">Endangered</span> &#123;</span><span class="comment">/*...*/</span>&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>派生类构造函数初始化所有基类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20211208121223940.png" alt="image-20211208121223940"></p>
<p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象。多重继承的派生类的构造函数初始值也只能初始化它的直接基类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">    : Bear(name, onExitbit, <span class="string">&quot;Panda&quot;</span>),</span><br><span class="line">	  Endangered(Endangered::critical) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Panda::Panda()</span><br><span class="line">    : Endangered(Endangered::critical) &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承的构造函数与多重继承</strong></p>
<p>允许派生类从它的一个或几个基类中继承构造函数，但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//错误：D1试图从两个基类中都继承 D1::D1(const string&amp;)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义他自己的版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    <span class="comment">// D2必须自定义一个接受string的构造函数</span></span><br><span class="line">    D2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s): Base1(s), Base2(s)&#123;&#125;</span><br><span class="line">    D2() = <span class="keyword">default</span>; <span class="comment">//一个D2定义了它自已的构造函数，则必须出现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>析构函数与多重继承</strong></p>
<p>​    和往常一样，派生类的析构函数只负责清楚派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>
<p><strong>类型转换与多个基类</strong></p>
<p>​    在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针或引用。例如，一个<code>ZooAnimal</code>、<code>Bear</code>或<code>Endangered</code>类型的指针或引用可以绑定到<code>Panda</code>对象上。</p>
<p>​    编译器不会在派生类向基类的几种转换中进行比较和选择，因为它在看起来任意一种基类都一样好。例如，如果存在如下所示的<code>print</code>重载形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Endangered&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则通过<code>panda</code>对象对不带前缀限定符的<code>print</code>函数进行调用将产生编译错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">&quot;ying_yang&quot;</span>)</span></span>;</span><br><span class="line">print(ying_yang); <span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>



<p><strong>基于指针类型或引用类型的查找</strong></p>
<p>当我们通过<code>Endangered</code>的指针或引用访问一个<code>Panda</code>对象时，<code>Panda</code>接口中<code>Panda</code>特有的部分以及属于<code>Bear</code>的部分都是不可兼得：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Endangered *pe = <span class="keyword">new</span> Panda(<span class="string">&quot;ying_yang&quot;</span>);</span><br><span class="line">pe-&gt;print();</span><br><span class="line">pe-&gt;toes(); <span class="comment">//错误，不属于Endangered的接口</span></span><br><span class="line">pe-&gt;cuddle(); <span class="comment">//错误</span></span><br><span class="line">pe-&gt;highlight(); <span class="comment">//正确，Panda::highlight()</span></span><br><span class="line"><span class="keyword">delete</span> pe;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20211216223153582.png" alt="image-20211216223153582"></p>
<p><strong>多重继承下的类作用域</strong></p>
<p>对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本。</p>
<p>例如，如果<code>ZooAnimal</code>和<code>Endangered</code>都定义了名为<code>max_weight</code>的成员，并且<code>Panda</code>没有定义该成员，则下面的调用是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = ying_yang.max_weight();</span><br></pre></td></tr></table></figure>

<p>要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Panda::max_weight</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(ZooAnimal::max_weight(),</span><br><span class="line">                   Endangered::max_weight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>虚继承</strong></p>
<p>​    在C++语言中我们定义了虚继承，虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象成为虚基类。在这种机制下，无论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20211217112459267.png" alt="image-20211217112459267"></p>
<blockquote>
<p>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</p>
</blockquote>
<p><strong>使用虚基类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;&#125;</span><br><span class="line"><span class="comment">// public 和 virtual 的顺序随意</span></span><br></pre></td></tr></table></figure>



<p><code>virtual</code>说明符表明了一种愿望，即在后续的派生类当中共享基类的同一份实例，至于什么样的类能够作为虚基类并没有特殊规定。</p>
<p><strong>虚基类成员的可见性</strong></p>
<p>假定类<code>B</code>定义了一个名为<code>x</code>的成员，<code>D1</code>和<code>D2</code>都是从<code>B</code>虚继承得到的，<code>D</code>继承了<code>D1</code>和<code>D2</code>，则在<code>D</code>的作用域中，<code>x</code>通过<code>D</code>的两个基类都是可见的。如果我们通过<code>D</code>的对象使用<code>x</code>，有三种可能性：</p>
<ul>
<li>如果在<code>D1</code>和<code>D2</code>中都没有<code>x</code>的定义，此时不存在问题。</li>
<li>如果<code>x</code>是<code>D1</code>或<code>D2</code>中的某一个成员，则同样不存在问题。</li>
<li>如果在<code>D1</code>和<code>D2</code>中都有<code>x</code>的定义，则直接访问<code>x</code>将产生二义性问题。</li>
</ul>
<p>与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义新的实例。</p>
<p><strong>构造函数与虚继承</strong></p>
<p>在虚派生中，虚基类是由最底层的派生类初始化的。例如，由<code>Panda</code>的构造函数独自控制<code>ZooAniaml</code>的初始化过程。</p>
<p><strong>虚基类的对象的构造方式</strong></p>
<p>创建一个<code>Panda</code>对象时：</p>
<ul>
<li>首先使用<code>Panda</code>的构造函数初始值列表中提供的初始值构造虚基类<code>ZooAnimal</code>部分。</li>
<li>接下来构造<code>Bear</code>部分。</li>
<li>然后构造<code>Raccoon</code>部分。</li>
<li>然后构造第三个直接基类<code>Endangered</code>。</li>
<li>最后构造<code>Panda</code>部分。</li>
</ul>
<blockquote>
<p>虚基类总是先于非基类构造，与它们在继承体系中的次序和位置无关。</p>
</blockquote>
<h3 id="第19章-特殊工具与技术"><a href="#第19章-特殊工具与技术" class="headerlink" title="第19章 特殊工具与技术"></a>第19章 特殊工具与技术</h3><h4 id="19-1-控制内存分配"><a href="#19-1-控制内存分配" class="headerlink" title="19.1 控制内存分配"></a>19.1 控制内存分配</h4><p><strong>重载new和delete</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;a value&quot;</span>); </span><br><span class="line"><span class="built_in">string</span> *arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当自定义了全局的<code>operator new</code>函数和<code>operator delete</code>函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的；因为他们是程序整个处理过程中至关重要的一部分。</p>
</blockquote>
<p><strong><code>operator new</code>接口和<code>operator delete</code>接口</strong></p>
<p>标准库定义了<code>operator new</code>函数和<code>operator delete</code>函数的8个重载版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; <span class="comment">//分配一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);<span class="comment">//分配一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//释放一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>; <span class="comment">//释放一个数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这些版本不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局作用域或者类作用域中，当我们将上述运算符函数定义成类的成员时，它们是隐式静态的，我们无需显式地声明<code>static</code>，当然这么做也不会引发错误。</p>
<p>尽管在一般情况下我们可以自定义具有任何形参的<code>operator new</code>，但是下面这个函数却无论如何不能被用户重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当我们将<code>operator delete</code>或<code>operator delete[]</code>定义成类的成员时，该函数可以包含另一个类型为<code>size_t</code>的形参，此时，该形参的初始值是第一个形参所指向对象的字节数。</p>
<blockquote>
<p>这两个函数并没有重载<code>new</code>表达式或者<code>delete</code>表达式。事实上，我们根本无法自定义<code>new</code>表达式或者<code>delete</code>表达式的行为。</p>
</blockquote>
<p><strong>malloc函数和free函数</strong></p>
<p>C++ 从 C语言中继承了这些函数，并且将其定义在<code>cstdlib</code>头文件中。</p>
<p>如下是编写<code>operator new</code>和<code>delete</code>的一种简单方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">        <span class="keyword">return</span> mem;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="built_in">free</span>(mem);&#125;</span><br></pre></td></tr></table></figure>



<p><strong>显式的析构函数调用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;a value&quot;</span>);</span><br><span class="line">sp-&gt;<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用析构函数会销毁对象，但是不会释放内存。</p>
</blockquote>
<h4 id="19-2-运行时类型识别"><a href="#19-2-运行时类型识别" class="headerlink" title="19.2 运行时类型识别"></a>19.2 运行时类型识别</h4><p><strong>运行时类型识别（RTTI）</strong>的功能由两个运算符实现：</p>
<p><code>typeid</code>运算符，用于返回表达式的类型。</p>
<p><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</p>
<p><strong>dynamic_cast运算符</strong></p>
<p>dynamic_cast运算符的使用形式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e);</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>其中，<code>type</code>必须是一个类类型，并且通常情况下该类型应该含有虚函数，在第一种形式中，<code>e</code>必须是一个有效的指针；在第二种形式中，<code>e</code>必须是一个左值；在第三种形式中，<code>e</code>不能是一个左值。</p>
<p>在上面的所有形式中，必须符合三个条件中的任意一个：<code>e</code>的类型是目标<code>type</code>的公有派生类、<code>e</code>的类型是目标<code>type</code>的公有基类或者<code>e</code>的类型就是目标<code>type</code>的类型。如果符合，则类型转型可以成功。否则，转换失败。如果一条<code>dynamic_cast</code>语句的转型目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则<code>dynamic_cast</code>运算符将抛出一个<code>bad_cast</code>异常。</p>
<p><strong>指针类型的dynamic_cast</strong></p>
<p>举个简单的例子，假定<code>Base</code>类至少含有一个虚函数，<code>Derived</code>是<code>Base</code>的公有派生类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Derived *dp = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用dp指向的Derived对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//使用bp指向的Base对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p>
</blockquote>
<p>我们在条件部分定义了<code>dp</code>，这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务。而且，指针<code>dp</code>在<code>if</code>语句外部都是不可访问的。一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到这个未绑定的指针，从而确保程序是安全的。</p>
<blockquote>
<p>在条件部分执行<code>dynamic_cast</code>操作可以确保类型转换和结果检查在同一条表达式中完成。</p>
</blockquote>
<p><strong>引用类型的dynamic_cast</strong></p>
<p>引用类型的<code>dynamic_cast</code>与指针类型的<code>dynamic_cast</code>在表示错误发生的方式上略有不同。因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针完全相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为<code>std::bad_cast</code>的异常，该异常定义在<code>typeinfo</code>标准库头文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> Derived &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(bad_cast)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>typeid 运算符</strong></p>
<p><code>typeid</code>运算符允许程序向表达式提问：你的对象是什么类型。</p>
<p><code>typeid</code>操作的结果是一个常量对象的引用，该对象的类型是标准库类型<code>type_info</code>或者<code>type_info</code>的公有派生类型。<code>type_info</code>类定义在<code>typeinfo</code>头文件中。</p>
<p>​    如果表达式是一个引用，则<code>typeid</code>返回该引用所引对象的类型。不过当<code>typeid</code>作用于数组或者函数时，并不会执行向指针的标准库类型转换。也就是说，如果我们对数组<code>a</code>执行<code>typeid(a)</code>，则所得的结果是数组类型而非指针类型。</p>
<p>​    当运算对象不属于类类型或者是一个不包含任何虚函数的类时，<code>typeid</code>运算符指示的是运算符对象的静态类型。而当运算符对象是定义了至少一个虚函数的类的左值时，<code>typeid</code>的结果直到运行时才会求得。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived *dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp = dp;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(*dp))&#123;</span><br><span class="line">	<span class="comment">// bp 和 dp指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(Derived))&#123;</span><br><span class="line">	<span class="comment">// bp 实际指向Derived对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一个条件语句中，我们比较<code>bp</code>和<code>dp</code>所指的对象的动态类型是否相同。</p>
<p>以上两个条件满足。</p>
<p>注意，<code>typeid</code>应该作用于对象，因此我们使用<code>*bp</code>而非<code>bp</code>;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(bp) == <span class="keyword">typeid</span>(Derived))&#123;</span><br><span class="line">    <span class="comment">//此处代码永远不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型<code>Base*</code>将在编译时求值，虽然它与<code>Derived</code>不同，因为无论<code>bp</code>所指向的对象到底是什么类型，上面的条件都不会满足。</p>
<blockquote>
<p>当<code>typeid</code>作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型。</p>
</blockquote>
<p><strong>使用RTTI</strong></p>
<p><code>RTTI</code>是<code>Runtime Type Information</code>的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。</p>
<p>在某些情况下，<code>RTTI</code>非常有用，比如我们当我们想为具有继承关系的类实现相等运算符时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Base&amp;, <span class="keyword">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Base 的接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> Base&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Derived 的其他接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> Base&amp;)</span> <span class="keyword">const</span></span>; </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>接下来定义整体的相等运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Base &amp;lhs, <span class="keyword">const</span> Base &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeid</span>(lhs) == <span class="keyword">typeid</span>(rhs) &amp;&amp; lhs.equal(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>虚equal函数</strong></p>
<p>继承体系中的每个类必须定义自己的<code>equal</code>函数。派生类的所有函数要做的第一件事都是相同的，那就是将实参的类型转换为派生类类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Derived::equal</span><span class="params">(<span class="keyword">const</span> Base &amp;rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(rhs);</span><br><span class="line">    <span class="comment">// 执行比较两个Derived对象的操作并返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>基类equal函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Base::equal</span><span class="params">(<span class="keyword">const</span> Base &amp;rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//执行比较Base对象的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>type_info类</strong></p>
<p><code>type_info</code>类的精确定义随着编译器的不同而略有差异。不过，C++标准规定了<code>type_info</code>类必须定义在<code>typeinfo</code>头文件中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20220110182823162.png" alt="image-20220110182823162"></p>
<p><code>type_info</code>类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义成删除的。因此，我们无法定义或拷贝<code>type_info</code>类型的对象。</p>
<h4 id="19-3-枚举类型"><a href="#19-3-枚举类型" class="headerlink" title="19.3 枚举类型"></a>19.3 枚举类型</h4><p><strong>枚举类型</strong>使我们可以将一组整型常量组织在一起。和类一样。每个枚举类型定义了一个新的类型。枚举属于字面值常量类型。</p>
<p>C++包含两种枚举：限定作用域的和不限定作用域的。C++新标准引入了限定作用域的枚举类型。定义限定作用域的枚举类型的一般形式是：首先是关键字<code>enum class</code>（或者等价地使用<code>enum struct</code>），随后是枚举类型名字以及花括号括起来的以逗号分隔的<strong>枚举成员</strong>列表，最后是一个分号：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> class <span class="title">open_modes</span><span class="params">(input, output, append)</span></span>;</span><br></pre></td></tr></table></figure>

<p>定义<strong>不限定作用域的枚举类型</strong>时省略掉关键字<code>class</code>，枚举类型的名字是可选的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span>red, yellow, green&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span>, double_doublePrec = <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>枚举成员</strong></p>
<p>在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>red, yellow, green&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">stoplight</span> &#123;</span>red, yellow, green&#125;; <span class="comment">//错误：重复定义了枚举成员</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">peppers</span>&#123;</span>red, yellow, green&#125;; <span class="comment">//正确：枚举成员被隐藏了</span></span><br><span class="line">color eyes = green; <span class="comment">//正确</span></span><br><span class="line">peppers p = green; <span class="comment">//错误，peppers的枚举成员不在有效的作用域中</span></span><br><span class="line">color hair = color::red; <span class="comment">//正确</span></span><br><span class="line">peppers p2 = peppers::red; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，枚举值从0开始，依次加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">intTypes</span>&#123;</span></span><br><span class="line">    charTyp = <span class="number">8</span>, shortTyp = <span class="number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举成员是<code>const</code>，因此在初始化枚举成员时提供的初始值必须是常量表达式，也就是说，每个枚举成员本身就是一条常量表达式，我们可以在任何需要常量表达式的地方使用枚举成员，例如，我们可以定义枚举类型的<code>constexpr</code>变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> intTypes charbits = intTypes::charType; </span><br></pre></td></tr></table></figure>



<p><strong>和类一样，枚举也定义新的类型</strong></p>
<p>​    只要<code>enum</code>有名字，我们就能定义并初始化该类型的成员，要想初始化<code>enum</code>对象或者为<code>enum</code>对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">open_modes om = <span class="number">2</span>; <span class="comment">//错误，2不属于类型</span></span><br><span class="line">om = open_modes::input; <span class="comment">//正确，input是open_modes的一个枚举成员</span></span><br></pre></td></tr></table></figure>

<p>​    一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。因此，我们可以在任何需要整形值的地方使用它们。</p>
<p><strong>指定enum的大小</strong></p>
<p>​    在新标准中，我们可以在enum的名字后加上冒号以及我们想在改<code>enum</code>中使用的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intValues</span>:</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&#123;</span><br><span class="line">    charTyp = <span class="number">255</span>, shortTyp = <span class="number">65535</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>枚举类型前置声明</strong></p>
<p>​    我们可以前置声明<code>enum</code>，<code>enum</code>前置声明必须指定其成员的大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">open_modes</span>;</span> <span class="comment">//限定作用域的枚举类型可以使用默认成员类型int</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intValues</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>; <span class="comment">//不限作用域的，必须指定成员类型</span></span><br></pre></td></tr></table></figure>



<h4 id="19-4-类成员指针"><a href="#19-4-类成员指针" class="headerlink" title="19.4 类成员指针"></a>19.4 类成员指针</h4><p><strong>成员指针</strong>指示的是类的成员，而非类的对象。类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针。</p>
<p>当初始化化成员指针时，我们令其指向类的某个成员，但不是指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。</p>
<p><strong>数据成员指针</strong></p>
<p>我们必须在*之前添加<code>classname::</code>以表示当前定义的指针可以指向<code>classname</code>的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Screen::*pdata;</span><br></pre></td></tr></table></figure>

<p>上述语句将<code>pdata</code>声明成：一个指向<code>Screen</code>类的<code>const string</code>成员的指针。我们只能</p>
<p>使用<code>pdata</code>读取它所指的成员，而不能向它写入内容。</p>
<p>当我们初始化一个成员指针时，需要指定它所指的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>

<p>当然最简单的方式是使用<code>auto</code>或<code>decltype</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>



<p><strong>使用数据成员指针</strong></p>
<p>当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时我们才提供对象的信息。</p>
<p>与成员访问运算符<code>.</code>和<code>-&gt;</code>类似，也有两种成员指针访问运算符：<code>.*</code>和<code>-&gt;*</code>，这两个运算符使得我们可以解应用指针并获取该对象的成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>



<p><strong>返回数据成员指针的函数</strong></p>
<p>常规的访问控制规则对成员指针同样有效。<code>Screen</code>的<code>contents</code>成员是私有的，因此之前对于<code>pdata</code>的使用必须位于<code>Screen</code>类的成员或友元内部，否则程序将发生错误。</p>
<p>因为数据成员一般情况下是私有的，所以我们通常不能直接获得数据成员的指针。如果一个像<code>Screen</code>这样的类希望我们可以访问它的<code>contents</code>成员，最好定义一个函数，令其返回值是指向该成员的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//data是一个静态成员，返回一个成员指针</span></span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*data()</span><br><span class="line">        &#123;<span class="keyword">return</span> &amp;Screen::contents;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>成员函数指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pmf = &amp;Screen::get_cursor;</span><br></pre></td></tr></table></figure>

<p>我们可以声明一个指针，令其指向含有两个形参的<code>get</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line">pmf2 = &amp;Screen::get;</span><br></pre></td></tr></table></figure>

<p>处于优先级的考虑，上述声明中<code>Screen::*</code>两端的括号必不可少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> Screen::*p(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">//错误，非成员函数p不能使用const限定符</span></span><br><span class="line">pmf = &amp;Screen::get; <span class="comment">//必须显式地使用取地址运算符</span></span><br><span class="line">pmf = Screen::get; <span class="comment">//错误 </span></span><br></pre></td></tr></table></figure>



<p><strong>使用成员函数指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="keyword">char</span> c1 = (pScreen-&gt;*pmf)();</span><br><span class="line"><span class="keyword">char</span> c2 = (pScreen-&gt;*pmf2)(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>上面两个式子中的括号必不可少，如果去掉:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myScreen.*pmf() <span class="comment">//其含义等同于</span></span><br><span class="line">myScreen.*(pmf())</span><br></pre></td></tr></table></figure>



<blockquote>
<p>因为函数调用的运算符优先级比较高，所以在声明指向成员函数的指针并使用这样的指针进行函数调用时，括号必不可少：<code>(C::*p)(parms)</code>和<code>(obj.*p)(args)</code></p>
</blockquote>
<p><strong>使用成员指针的类型别名</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Action 是一种可以指向Screen成员函数的指针，接受两个pos实参，返回一个char</span></span><br><span class="line"><span class="keyword">using</span> Action = </span><br><span class="line">    <span class="keyword">char</span> (Screen::*)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>Action</code>我们可以简化<code>get</code>的指针定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Action get = &amp;Screen::get;</span><br></pre></td></tr></table></figure>

<p>我们可以将指向成员函数的指针作为某个函数的返回类型或形参类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Screen&amp; <span class="title">action</span><span class="params">(Screen&amp;, Action = &amp;Screen::get)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>action</code>是包含两个形参的函数，其中一个形参是<code>Screen</code>对象的引用，另一个形参是指向<code>Screen</code>成员函数的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Screen myScreen;<span class="comment">//等价的调用</span></span><br><span class="line">action(myScreen);</span><br><span class="line">action(myScreen, get);</span><br><span class="line">action(myScreen, &amp;Screen::get);<span class="comment">//显式传入地址</span></span><br></pre></td></tr></table></figure>



<p><strong>将成员函数用作可调用对象</strong></p>
<p>与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fp = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(svec.begin(), svec.end(), fp); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>使用function生成一个可调用对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">bool</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; fcn = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(svec.begin(), svec.end(), fcn);</span><br></pre></td></tr></table></figure>

<p>我们告诉<code>function</code>一个事实，即<code>empty</code>是一个接受<code>string</code>参数并返回<code>bool</code>值得函数。</p>
<p><strong>使用<code>mem_fn</code>生成一个可调用对象</strong></p>
<p>和<code>function</code>不同的是，<code>mem_fn</code>可以根据成员指针的类型推断可调用对象的类型，而无需用户显式地指定；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">find_if(svec.begin(), svec.end(), mem_fn(&amp;<span class="built_in">string</span>::empty));</span><br></pre></td></tr></table></figure>

<p>我们使用<code>mem_fn(&amp;string::empty)</code>生成一个可调用对象，该对象接受一个<code>string</code>实参，返回一个<code>bool</code>值。</p>
<p><code>mem_fn</code>生成的可调用对象可以通过对象调用，也可以通过指针调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = mem_fn(&amp;<span class="built_in">string</span>::empty);</span><br><span class="line">f(*svec.begin()); <span class="comment">//接受一个string对象，f使用.*调用empty</span></span><br><span class="line">f(&amp;svec[<span class="number">0</span>]); <span class="comment">//接受一个string指针，f使用-&gt;*调用empty</span></span><br></pre></td></tr></table></figure>

<p>事实上，我们可以认为<code>mem_fn</code>生成的可调用对象含有一对重载的函数调用运算符：一个接受<code>string*</code>，另一个接受<code>string&amp;</code>。</p>
<p><strong>使用bind生成一个可调用对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = find_if(svec.begin(), svec.end(), bind(&amp;<span class="built_in">string</span>::empty, _1));</span><br></pre></td></tr></table></figure>

<p>和<code>mem_fn</code>类似的是，<code>bind</code>生成的可调用对象的第一个实参既可以是<code>string</code>的指针，也可以是<code>string</code>的引用。</p>
<h4 id="19-5-嵌套类"><a href="#19-5-嵌套类" class="headerlink" title="19.5 嵌套类"></a>19.5 嵌套类</h4><p>一个类可以定义在另一个类的内部，前者称为<strong>嵌套类</strong>。</p>
<p>嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套类的对象是相互独立的。在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层类的对象中也不包含任何嵌套类定义的成员。</p>
<p>外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。</p>
<p><strong>声明一个嵌套类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextQuery</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>;</span></span><br><span class="line">    <span class="comment">//嵌套类可以直接使用外层类的成员，无需对该成员的名字进行限定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在嵌套类在其外层类之外完全真正的定义之前，它都是一个不完整类型。</p>
</blockquote>
<p><strong>定义嵌套类的成员</strong></p>
<p>要想为其定义构造函数，必须指明<code>QueryResult</code>是嵌套在<code>TextQuery</code>的作用域之内的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TextQuery::QueryResult::QueryResult(<span class="built_in">string</span> s,</span><br><span class="line">                                   <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; p,</span><br><span class="line">                                   ....):</span><br><span class="line">	sought(s), lines(p), ....&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌套类和外层类是相互独立的</strong><br>尽管嵌套类定义在其外层类的作用域中，但是读者必须道记外层类的对象和嵌套类的对象没有任何关系。嵌套类的对象只包含嵌套类定义的成员；同样，外层类的对象只包含外层类定义的成员，在外层类对象中不会有任何嵌套类的成员。</p>
<h4 id="19-6-union-一种节省空间的类"><a href="#19-6-union-一种节省空间的类" class="headerlink" title="19.6 union:一种节省空间的类"></a>19.6 <code>union:</code>一种节省空间的类</h4><p>​    联合 <code>union</code>是一种特殊的类。一个 <code>union</code>可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给 <code>union</code>的某个成员赋值之后，该 <code>union</code>的其他成员就变成末定义的状态了。分配给一个 <code>union</code>对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个 <code>union</code>定义了一种新类型。</p>
<p>​    类的某些特性对<code>union</code>同样适用，但并非所有特性都如此。<code>union</code>不能含有引用类<br>型的成员，除此之外，它的成员可以是绝大多数类型。在C++11 新标准中，含有构造函数<br>或析构函数的类类型也可以作为<code> union</code> 的成员类型。<code>union </code>可以为其成员指定 <code>public</code>、<code>protected</code>和<code>private</code>等保护标记。默认情况下，<code>union</code>的成员都是公有的，这一点与<code>struct</code>相同。</p>
<p>​    <code>union</code> 可以定义包括构造函数和析构函数在内的成员函数。但是由于 <code>union</code>既不能<br>继承自其他类，也不能作为基类使用，所以在 <code>union</code>中不能含有虛函数。</p>
<p><strong>定义union</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Token</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">    <span class="keyword">int</span>  ival;</span><br><span class="line">    <span class="keyword">double</span> dval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>使用<code>union</code>类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Token first_token = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">Token last_token; <span class="comment">// 未初始化</span></span><br><span class="line">Token *pt = <span class="keyword">new</span> Token; <span class="comment">//指向一个未初始化的Token对象</span></span><br></pre></td></tr></table></figure>

<p>我们使用通用的成员访问运算符访问一个<code>union</code>对象的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">last_token.cval = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">pt-&gt;ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>



<p><strong>匿名union</strong></p>
<p>匿名<code>union</code>是一个未命名的<code>union</code>，并且在右花括号和分号之间没有任何声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">    <span class="keyword">int</span>  ival;</span><br><span class="line">    <span class="keyword">double</span> dval;</span><br><span class="line">&#125;;</span><br><span class="line">ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>在匿名<code>union</code>的定义所在的作用域内该<code>union</code>的成员都是可以直接访问的。</p>
<blockquote>
<p>匿名<code>union</code>不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
</blockquote>
<p><strong>使用类管理<code>union</code>成员</strong></p>
<p>为了追踪<code>union</code>中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为<code>union</code>的判别式子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Token() : tok(INT), ival&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">        Token (<span class="keyword">const</span> Token &amp;t) : tok(t.tok)	&#123;	copyUnion(t);	&#125;</span><br><span class="line">        Token &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> Token&amp;);</span><br><span class="line">        <span class="comment">//如果union 含有一个string成员，则我们必须销毁它，</span></span><br><span class="line">        ~Token() &#123;<span class="keyword">if</span> (tok == STR) sval.~<span class="built_in">string</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        Token <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">std</span>: :<span class="built_in">string</span>&amp;);</span><br><span class="line">        Token <span class="keyword">operator</span>=(<span class="keyword">char</span>);</span><br><span class="line">        Token <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">        Token <span class="keyword">operator</span>=(<span class="keyword">double</span>);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> (<span class="title">INT</span>, <span class="title">CHAR</span>, <span class="title">DBL</span>, <span class="title">STR</span>) <span class="title">tok</span>;</span> <span class="comment">// 判别式</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">// 匿名union</span></span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="keyword">double</span> dual;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sval;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//每个Token对象含有一个该未命名inion 类型的未命名成员</span></span><br><span class="line">	<span class="comment">//检查判别式，然后的情拷贝 union 成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyUnion</span> <span class="params">(<span class="keyword">const</span> Tokens)</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>管理判别式并销毁string</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Token &amp;Token::<span class="keyword">operator</span>= (<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tok == STR) sval.~<span class="built_in">string</span>();</span><br><span class="line">    ival = i;</span><br><span class="line">    tok = INT:</span><br><span class="line">    <span class="comment">//如果当前存儲的是string，择放它</span></span><br><span class="line">    <span class="comment">//为成员賦值</span></span><br><span class="line">    <span class="comment">//更新判别式</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>double</code>和<code>int</code>版本赋值运算类似，<code>string</code>的有所差异。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Token &amp;Token::<span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tok == STR) sval = s;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span>(&amp;sval) <span class="built_in">string</span>(s);<span class="comment">//先构造一个string</span></span><br><span class="line">    tok = STR:</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>管理需要拷贝控制的联合成员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Token::copyUnion</span><span class="params">(<span class="keyword">const</span> Token &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(t.tok)&#123;</span><br><span class="line">        <span class="keyword">case</span> Token::INT: ival = t.ival; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Token::CHAR: ival = t.cval; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Token::STR: <span class="keyword">new</span>(&amp;sval) <span class="built_in">string</span>(t.sval); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="19-7-局部类"><a href="#19-7-局部类" class="headerlink" title="19.7 局部类"></a>19.7 局部类</h4><p>类可以定义在某个函数的内部，我们称为这样的类为局部类，局部类型定义的类型只在定义它的作用域内可见，和嵌套类不同，局部类的成员受到严格限制。</p>
<blockquote>
<p>局部类的所有成员（包括函数在内）都必须完整定义在类的内部。</p>
</blockquote>
<p>在局部类中也不允许声明静态数据成员。</p>
<p><strong>局部类不能使用函数作用域中的变量</strong></p>
<p>如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,val;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> si;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Loc</span>&#123;</span> a = <span class="number">1024</span>, b&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line">        Loc locVal;</span><br><span class="line">        <span class="keyword">int</span> barVal;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(Loc l = a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            barVaL = val;	<span class="comment">//错误:val是foo的局部变量</span></span><br><span class="line">            varVal = ::val;</span><br><span class="line">            barVal = si;	<span class="comment">//正确：使用一个静态局部对象</span></span><br><span class="line">            locVal = b;		<span class="comment">//正确：使用一个枚举成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="19-8-固有的不可移植的特性"><a href="#19-8-固有的不可移植的特性" class="headerlink" title="19.8 固有的不可移植的特性"></a>19.8 固有的不可移植的特性</h4><p><strong>位域</strong></p>
<p>​    类可以将其（非静态）数据成员定义成位域，在一个位域中含有一个数量的二进制位。</p>
<blockquote>
<p>位域在内存中的布局是与机器相关的。</p>
</blockquote>
<p>​    位域的类型必须是整型或枚举类型，位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Bit;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>&#123;</span></span><br><span class="line">	Bit mode: <span class="number">2</span>; <span class="comment">//mode占2位</span></span><br><span class="line">    Bit modified: <span class="number">1</span>; <span class="comment">//modified占1位</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">modes</span>&#123;</span> READ = <span class="number">01</span>, WRITE = <span class="number">02</span>&#125;;</span><br><span class="line">    <span class="function">File &amp;<span class="title">open</span><span class="params">(modes)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRead</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWrite</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    取地址运算符<code>（&amp;）</code>不能作用域位域，因此任何指针都无法指向类的位域。</p>
<blockquote>
<p>通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为因具体实现而定。</p>
</blockquote>
<p><strong>使用位域</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">File::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    modified = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">File::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(modified)</span><br><span class="line">        <span class="comment">// ..... 保存内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用内置的位运算符操作操过1位的位域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">File &amp;<span class="title">File::open</span><span class="params">(File::modes m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mode |= READ;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; WRITE)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">File::isRead</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mode &amp; READ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FIle::setWrite</span><span class="params">()</span> </span>&#123; mode |= WRITE; &#125;</span><br></pre></td></tr></table></figure>



<p><strong>volatile限定符</strong></p>
<blockquote>
<p><code>volatile</code>的确切含义与机器有关，只能通过阅读编译器文档来理解，要想让使用了<code>volatile</code>的程序在移植到新编译器后仍然有效，通常需要对该程序进行某些改变。</p>
</blockquote>
<p>​    直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控<br>制或检测之外被改变时，应该将该对象声明为<code>volatile</code>。关键字<code>volatile</code>告诉编译<br>器不应对这样的对象进行优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> display_register; <span class="comment">//该int值可能发生改变</span></span><br><span class="line"><span class="keyword">volatile</span> Task *curr_task; <span class="comment">//curr_tast 指向一个volatile对象</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> * <span class="keyword">volatile</span> vivp; <span class="comment">//vivp 是一个`volatile`指针，指向一个volatile int</span></span><br></pre></td></tr></table></figure>

<p>​        某种类型可能既是<code>const</code>的也是<code>volatile</code>的，因此它同时具有二者的属性。</p>
<p><strong>合成拷贝对<code>volatile</code>对象无效</strong></p>
<p>​        <code>const</code>和<code>volatile</code>的一个重要区别是我们不能使用合成的拷贝、移动构造函数及赋值运算符初始化<code>volatile</code>对象或从<code>volatile</code>对象赋值。</p>
<p><strong>链接指示：extern “C”</strong></p>
<p>C++ 使用<strong>链接指示</strong>指出任意非C++函数所用的语言。</p>
<p><strong>声明一个非C++的函数</strong></p>
<p>​        链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部，同样的链接指示必须在函数的每个声明中都出现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>; <span class="comment">//单句链接提示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合语句链接提示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>* )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>* )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>指向 <code>extern &quot;C&quot;</code>函数的指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">void</span> (*pf)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>



<p>指向C函数的指针与指向C++函数的指针是不一样的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>);</span><br><span class="line">pf1 = pf2; <span class="comment">//错误，pf1和pf2是不同类型</span></span><br></pre></td></tr></table></figure>



<p><strong>导出C++函数到其他语言</strong></p>
<p>​        值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，我们不太可能把一个C++类的对象传给 C 程序，因为C程序根本无法理解构造函数、析构函数以及其他类特有的操作。</p>
<blockquote>
<p><strong>对链接到c的预处理器的支持</strong><br>        有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C++版本的程序时预处理器定义cplusp1us（两个下画线）。利用这个变量，我们可以在编译C++程序的时候有条件地包含进来一些代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="comment">//正确：我们正在编译C++程序</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stremp</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ primer 第三部分 (C++基础)</title>
    <url>/2021/09/17/C++Primer%EF%BC%88%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>第三部分，开始！！！</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210327161629.jpg" alt="wallhaven_mdj218"></p>
<p>​    2021.3.27</p>
<a id="more"></a>

<h3 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="headerlink" title="第13章 拷贝控制"></a>第13章 拷贝控制</h3><p>一个类往往会定义五种特殊的成员函数来控制一些操作：包括拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数。</p>
<h4 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h4><p><strong>拷贝构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo();</span><br><span class="line">    	Foo(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数的第一个参数必须是一个<strong>引用类型</strong>。</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况也会发生：</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<p>当我们初始化标准库容器或是调用其<code>insert</code>或<code>push</code>成员时，容器会对其元素进行拷贝初始化，与之相对的是，用<code>emplace</code>成员创建的元素都进行直接初始化。</p>
<p>如果我们使用的初始化值要求通过一个<code>explicit</code>(指定构造函数或转换函数 (C++11起)为显式, 即它不能用于隐式转换和复制初始化)的构造函数来进行类型转化，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;<span class="comment">//错误，接受大小参数的构造函数是explicit的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br><span class="line">f(<span class="number">10</span>);<span class="comment">//错误</span></span><br><span class="line">f(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>



<p><strong>拷贝赋值运算符</strong></p>
<p>与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data&amp;</span><br><span class="line">    Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    bookNo = rhs.bookNo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于合成拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>



<p><strong>析构函数</strong></p>
<p>构造函数初始化对象的非<code>static</code>数据成员，析构函数释放对象使用的资源，并销毁对象的非<code>static</code>数据成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	~Foo();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个析构函数中，析构部分是隐式的，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。</p>
<blockquote>
<p>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。</p>
</blockquote>
<p>智能指针是类类型，所以具有析构函数，因此与普通指针不同，只能指针成员在析构函数阶段会被自动销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Sales_data *p = <span class="keyword">new</span> Sales_data;</span><br><span class="line">    <span class="keyword">auto</span> p2 = make_shared&lt;Sales_data&gt;();</span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Sales_data&gt; vec;</span><br><span class="line">    vec.push_back(*p2);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;<span class="comment">//退出局部作用域;对item、p2和vec调用析构函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
</blockquote>
<p>当一个类没有定义自己的析构函数时，编译器会为它定义一个合成析构函数。</p>
<p>析构函数体自身不直接销毁成员，成员是是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象的销毁过程中，析构函数体是作为成员销毁步骤之外的一部分而进行的。</p>
<p>我们可以通过将拷贝控制成员定位为<code>=default</code>来显式地要求编译器生成合成的版本。</p>
<p>当我们在类内用<code>=default</code>修饰成员的声明时，合成的函数将隐式地声明为内联的，如果我们不希望这样，应该在成员的类外定义使用<code>=default</code>，就像对拷贝赋值运算符所做的那样。</p>
<p><strong>阻止拷贝</strong></p>
<p><code>iostream</code>类阻止了拷贝，以避免多个对象写入或读入相同的IO缓冲。</p>
<p>我们可以通过定义删除的函数<code>=delete</code>来阻止拷贝。</p>
<p>与<code>=default</code>不同，<code>=delete</code>必须出现在函数第一次声明的时候。</p>
<p>值得注意的是，我们不能删除析构函数。</p>
<p>对于具有引用成员或无法默认构造的<code>const</code>成员的类，编译器不会为其合成默认构造函数。如果一个类有<code>const</code>成员，则它不能使用合成的拷贝赋值运算符。</p>
<blockquote>
<p>本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p>
</blockquote>
<h4 id="13-2-拷贝控制和资格管理"><a href="#13-2-拷贝控制和资格管理" class="headerlink" title="13.2 拷贝控制和资格管理"></a>13.2 拷贝控制和资格管理</h4><p><strong>行为像值的类</strong></p>
<p><code>HasPtr</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        HasPtr(<span class="keyword">const</span> HasPtr&amp; p):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i)&#123;&#125;</span><br><span class="line">        HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">        ~HasPtr() &#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类值拷贝赋值运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> temp = rhs.ps;</span><br><span class="line">    <span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">    ps = temp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是正确的写法，下面的编写会发生错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;<span class="comment">//释放旧内存</span></span><br><span class="line">    ps = rhs.ps;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>rhs</code>和本对象是同一对象，<code>delete</code>操作会释放这一对象指向的<code>string</code>，接下来，我们的赋值操作就会访问一个指向无效内存的指针。</p>
<blockquote>
<p>在程序实现中，发现了这样一个问题，在上面operator=重载函数中，如果调用方式为<code>HasPtr p2 = p1;</code>，改变<code>*p1.ps = &quot;ha&quot;;</code>但是，<code>p2.ps</code>中的值没有改变。</p>
<p>如果调用方式为：<code>HasPtr p1(ptr,10),p2;</code> 和<code>p2 = p1;</code>，改变<code>*p1.ps = &quot;ha&quot;;</code>，<code>p2.ps</code>中的值会发生改变。</p>
<p>具体原因不明。</p>
</blockquote>
<p><strong>行为像指针的类</strong></p>
<p>令一个类展现类似指针的行为的最好方法是使用<code>shared_ptr</code>来管理类中的资源。</p>
<p>或者使用引用计数就很有用。但是为了不同对象中计数器的统一，一般将计数器设为指针形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">        HasPtr(<span class="keyword">const</span> HasPtr&amp; p):</span><br><span class="line">            ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i)&#123;++*use;&#125;</span><br><span class="line">        HasPtr&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">        ~HasPtr() &#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HasPtr::~HasPtr() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">delete</span> ps;</span><br><span class="line">       <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use;</span><br><span class="line">    <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;<span class="comment">//递减本对象的引用次数</span></span><br><span class="line">        <span class="keyword">delete</span> ps;<span class="comment">//如果没有其他用户，释放成员</span></span><br><span class="line">        <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">    ps = rhs.ps;</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h4><p>这一章没有讲过多内容，主要介绍了<code>swap</code>函数。</p>
<p>在交换两个值的时候：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hasptr temp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = temp;</span><br></pre></td></tr></table></figure>

<p>这样的内存分配是不必要的，我们更希望是<code>swap</code>交换指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *temp = v1;</span><br><span class="line">v1.ps = v2.ps;</span><br><span class="line">v2.ps = temp;</span><br></pre></td></tr></table></figure>



<h4 id="13-4-拷贝控制示例"><a href="#13-4-拷贝控制示例" class="headerlink" title="13.4 拷贝控制示例"></a>13.4 拷贝控制示例</h4><p>这一小节主要介绍了一个<code>folder</code>和<code>message</code>的示例。</p>
<p>具体内容可以看书，在这里不做过多介绍。</p>
<h4 id="13-5-动态内存管理"><a href="#13-5-动态内存管理" class="headerlink" title="13.5 动态内存管理"></a>13.5 动态内存管理</h4><p>在这一小节，我们将实现一个类似<code>vector</code>的简化类。</p>
<p><code>StrVec</code>有三个指针成员：</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210329201718.png" alt="image-20210329201711585"></p>
<p>除了指针外，<code>StrVec</code>还有一个名为<code>alloc</code>的静态成员，其类型为<code>allocator&lt;string&gt;</code>。<code>alloc</code>成员会分配<code>StrVec</code>使用的内存，此外，我们的类还有四个工具函数。</p>
<p><strong>类定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec():</span><br><span class="line">            elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">        StrVec(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">        StrVec &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">        ~StrVec();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> first_free-elements;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> cap-elements;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> elements;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> first_free;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        	</span>&#123;<span class="keyword">if</span>(size() == capacity())  reallocate();&#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>* , <span class="built_in">std</span>::<span class="built_in">string</span>*&gt; alloc_n_copy</span><br><span class="line">        (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *elements;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *first_free;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> *cap;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>push_back函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>alloc_n_copy</code>成员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>*&gt;</span><br><span class="line">StrVec::alloc_n_copy(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> *b, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> *e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc.allocate(e-b);</span><br><span class="line">    <span class="keyword">return</span> &#123;data, uninitialized_copy(b,e,data)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的<code>pair</code>的<code>first</code>成员指向分配的内存的开始位置，第二个成员指向最后一个构造元素之后的位置。</p>
<p><strong>free成员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = first_free; p!= elements;)</span><br><span class="line">        alloc.destroy(--p);</span><br><span class="line">        alloc.deallocate(elements, cap - elements);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拷贝控制成员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec::StrVec(<span class="keyword">const</span> StrVec &amp;s )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc_n_copy(s.begin(), s.end());</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec::~StrVec()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>= (<span class="keyword">const</span> StrVec &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reallocate成员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span>*size():<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="keyword">auto</span> dest = newdata;</span><br><span class="line">    <span class="keyword">auto</span> elem = elements;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != size(); i++)</span><br><span class="line">        alloc.construct(dest++, <span class="built_in">std</span>::move(*elem++));</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    <span class="comment">//拷贝完数据，free旧内存空间，此时的三个指针还是指向旧的内存空间</span></span><br><span class="line"></span><br><span class="line">    elements = newdata;</span><br><span class="line">    first_free = dest;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h4><p>在某种情况下，对象拷贝后就立即被销毁了，此时，移动而非拷贝对象会大幅度提升性能。</p>
<p>使用移动而不是拷贝的另一个原因源于IO类或<code>unique_ptr</code>这样的类，这些类都包含不能被共享的资源（如指针或IO缓存）。因此，这些类型的对象不能拷贝但可以移动。</p>
<blockquote>
<p>标准库容器，<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。</p>
</blockquote>
<p><strong>右值引用</strong></p>
<p>新标准引入了一种新的引用类型，我们通过&amp;&amp;而不是&amp;来获取右值引用。</p>
<p>右值引用有一个重要的性质，只能绑定到一个将要销毁的对象。</p>
<p>对于常规引用，我们可以称之为左值引用，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">//错误：不能将右值引用绑定到左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i*<span class="number">42</span>; <span class="comment">//错误：i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i *<span class="number">42</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i*<span class="number">42</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><strong>左值持久；右值短暂</strong></p>
<p>由于右值引用只能绑定到临时对象上，我们可知：</p>
<ul>
<li>所引用的对象将要被销毁。</li>
<li>该对象没有其他用户。</li>
</ul>
<p>变量是左值，因为变量是持久的，离开作用域才被销毁。因此，我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p>
<p><strong>标准库move函数</strong></p>
<p>我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<code>move</code>的新标准库函数来获取绑定到左值上的右值引用，此函数定义在头文件<code>utility</code>中。</p>
<p>调用<code>move</code>就意味着承诺：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。</p>
<blockquote>
<p>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p>
</blockquote>
<p>与大多数标准库名字的使用不同，我们对<code>move</code>不提供<code>using</code>声明，我们直接调用<code>std::move</code>。</p>
<p><strong>移动构造函数和移动赋值运算符</strong></p>
<p>这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span></span><br><span class="line">    :elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">    &#123;</span><br><span class="line">        s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>noexcept</code>通知标准库我们的构造函数不抛出任何异常。</p>
<p>移动构造函数不分配任何新内存；他接管给定的<code>StrVec</code>中的内存。在接管内存之后，他将给定对象中的内存指针都置为<code>nullptr</code>。这样就完成了从给定对象的移动操作。此对象将继续存在。最终，移后源对象会被销毁。</p>
<p><code>vector</code>保证，如果调用<code>push_back</code>时发生异常，<code>vector</code>本身不会发生改变。</p>
<p>对<code>vector</code>调用<code>push_back</code>可能要求为<code>vector</code>重新分配内存空间，然后将元素从新就空间移动到新内存中。</p>
<p>如果重新分配过程中使用了移动构造函数，且移动了部分而不是全部元素后抛出一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。而拷贝构造函数可以避免这种问题。</p>
<p><strong>移动赋值函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">       <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cao = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>移动后源对象必须可析构</strong></p>
<p>从一个对象移动数据并不会销毁此对象，但有时在移动完成后，源对象会被销毁。因此，我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>
<p><strong>合成的移动操作</strong></p>
<p>与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值函数。</p>
<blockquote>
<p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认被定义为删除的。</p>
</blockquote>
<p><strong>移动右值，拷贝左值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec v1,v2;</span><br><span class="line">v1 = v1;	<span class="comment">//v2是左值，使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream &amp;)</span></span>;</span><br><span class="line">v2 = getVec(<span class="built_in">cin</span>);	<span class="comment">//getVec返回右值，使用移动赋值</span></span><br></pre></td></tr></table></figure>



<p>如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图调用<code>move</code>来移动它们是也是使用拷贝构造函数。</p>
<p><strong>移动迭代器</strong></p>
<p>通过标准库<code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size()?<span class="number">2</span>*size():<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="comment">//移动元素</span></span><br><span class="line">    <span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()),</span><br><span class="line">                                  make_move_iterator(end()),</span><br><span class="line">                                  first);</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = first;</span><br><span class="line">    first_free = last;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于一个移后源对象具有不确定的状态，对其调用<code>std::move</code>是危险的，当我们调用<code>move</code>时，必须绝对确定移动后源对象没有其他用户。</p>
<p><strong>右值引用和成员函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;<span class="comment">//拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;<span class="comment">//移动</span></span><br></pre></td></tr></table></figure>



<p>一个函数可以同时使用<code>const</code>和引用限定，在此情况下，引用限定符必须跟随在<code>const</code>限定符之后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="keyword">const</span></span>;	<span class="comment">//错误</span></span><br><span class="line">    	<span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;	<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重载和引用函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    	<span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span>&amp;</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//本对象为右值，因此可以原值排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(data.begin(), data.end());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本对象是const或是一个左值，因此不能进行原值排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;	<span class="comment">//拷贝副本</span></span><br><span class="line">    sort(ret.data.begin(), ret.data.end());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个成员函数有引用限定符，则其具有相同参数列表的所有版本都必须有引用限定符。</p>
</blockquote>
<h3 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="headerlink" title="第14章 重载运算与类型转换"></a>第14章 重载运算与类型转换</h3><h4 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h4><p>重载的运算符是具有特殊名字的函数：它们的名字有关键字<code>operator</code>和其后面定义的运算符号共同组成。</p>
<p>除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p>
<p>如果一个运算符函数是成员函数，则它的第一个运算对象绑定到隐式的<code>this</code>指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。</p>
<p>对于一个运算符函数来说，或者是类的成员，或者至少含有一个类类型的参数。</p>
<p><code>int operator+(int , int);</code></p>
<p>我们只能重载已有的运算符，而无权发明新的运算符号。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210415211206.png" alt="image-20210415211159342"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">data1 + data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);</span><br></pre></td></tr></table></figure>

<p><strong>某些运算符不应该被重载</strong></p>
<p>逻辑与运算符、或运算符和逗号逗号运算符，&amp;&amp;和||运算符不建议重载。</p>
<p><strong>成员函数</strong></p>
<p>赋值（=）、下标（[]）、调用（()）、和成员访问箭头（-&gt;）运算符必须是成员。</p>
<h4 id="14-2-输入和输出运算符"><a href="#14-2-输入和输出运算符" class="headerlink" title="14.2 输入和输出运算符"></a>14.2 输入和输出运算符</h4><p><strong>重载输出运算符&lt;&lt;</strong></p>
<p>输入运算符的第一个形参是一个非常量<code>ostream</code>对象的引用。该形参是引用是因为我们无法直接复制一个<code>ostream</code>对象。</p>
<p>第二个形参一般来说是一个常量的引用。</p>
<p>为了与其他输出运算符保持一致，<code>operator&lt;&lt;</code>一般要返回它的<code>ostream</code>形参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt;  <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出运算符尽量减少格式化操作</strong></p>
<blockquote>
<p>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
</blockquote>
<p><strong>输入输出运算符必须是非成员函数</strong></p>
<p>因此，如果我们希望为类自定义IO运算符，则必须将其定义为非成员函数（否则，左侧运算符对象将是我们的类的一个对象）。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。</p>
<p><strong>重载输入运算符&gt;&gt;</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream *is, Sales_data &amp;item )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span>(is)</span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        item = Sales_data();<span class="comment">//输入失败， 对象被赋予默认的状态</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</p>
</blockquote>
<p>通常情况下，输入运算符只设置<code>failbit</code>。除此之外，设置<code>eofbit</code>表示文件耗尽，而设置<code>badbit</code>表示流被破坏。最好的方式是由IO标准库自己来标示这些错误。</p>
<h4 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs; <span class="comment">//调用operator=</span></span><br><span class="line">    sum += rhs; <span class="comment">//调用+=</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相等运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">        	lhs.units_sold == rhs.units_sold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关系运算符</strong></p>
<blockquote>
<p>如果存在唯一一种逻辑可靠地&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p>
</blockquote>
<h4 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">v= &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，在创建一片新空间，不同之处是，这个运算符无需检查对象向自身的赋值。</p>
<blockquote>
<p>我们可以重载赋值运算符，无论形参的类型是什么，赋值运算符都必须定义为成员函数。</p>
</blockquote>
<h4 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h4><blockquote>
<p>下标运算符必须是成员函数。</p>
</blockquote>
<p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">        &#123;<span class="keyword">return</span> elements[n];&#125;</span><br><span class="line">    	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">        &#123;<span class="keyword">return</span> elements[n];&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> *elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h4><blockquote>
<p>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</p>
</blockquote>
<p>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果curr已经指向了容器的尾后位置，则无法递增</span></span><br><span class="line">    check(curr, <span class="string">&quot;increment past end of StrBlobPtr&quot;</span>);</span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    --curr;</span><br><span class="line">    <span class="comment">//如果curr是0，则继续递减它将产生一个无效下标</span></span><br><span class="line">    check(curr, <span class="string">&quot;decrement past end of StrBlobPtr&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>区分前置和后置运算符</strong></p>
<p>后置版本接受一个额外的（不被使用）int类型的形参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">    	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了和内置版本保持一致，后置运算符应该返回对象的原值（递增递减之前的值），返回的形式是一个值而非引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无须检查有效性</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//无须检查有效性</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>显式调用后置运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">//调用后置版本</span></span><br><span class="line">p.<span class="keyword">operator</span>++();<span class="comment">//调用前置版本</span></span><br></pre></td></tr></table></figure>



<h4 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = check(curr, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。</p>
</blockquote>
<h4 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h4><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象，因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;</span><br><span class="line"><span class="keyword">int</span> ui = absObj(i);</span><br></pre></td></tr></table></figure>

<p>我们将该类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">    		os(o), sep(c)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>&#123;os &lt;&lt; s&lt;&lt;sep;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	ostream &amp;os;</span><br><span class="line">    	<span class="keyword">char</span> sep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer;</span><br><span class="line">printer(s); <span class="comment">//在cout中打印s，后面跟一个空格</span></span><br><span class="line"><span class="function">PrintString <span class="title">errors</span><span class="params">(<span class="built_in">cerr</span>, <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br><span class="line">errors(s);  <span class="comment">// 在cerr中打印s，后面跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>函数对象常常作为泛型算法的实参，类似于<code>lambda</code>表达式的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(vs.begin(), vs.end(), PrintString(<span class="built_in">cerr</span>, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure>



<p><strong>标准库定义的函数对象</strong></p>
<p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类。例如<code>plus</code>类定义了一个函数调用运算符对一对运算对象执行+的操作。</p>
<p>这些类都被定义为模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intAdd; <span class="comment">//可执行int加法的函数对</span></span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; intNegate; <span class="comment">//可对int值取反的函数对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = intAdd(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">sum = intNegate(intAdd(<span class="number">10</span>,<span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p>此类定义在<code>functional</code>头文件中。</p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210429185207.png" alt="image-20210429185130236"></p>
<p><strong>在算法中使用标准库函数对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(svec.begin(), svec.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br></pre></td></tr></table></figure>

<p>传入一个临时的函数对象用于执行两个<code>string</code>对象的<code>&gt;</code>比较运算。 </p>
<p>+</p>
<p><strong>可调用对象与function</strong></p>
<p>C++语言中有几种可调用的对象：函数、函数指针、<code>lambda</code>表达式、<code>bind</code>创建的对象（10.3节）以及重载了函数调用运算符的类。</p>
<p>两个不同类型的可调用对象却可能共享同一种调用形式，调用形式指明了调用返回的类型以及传递给调用的实参类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>是一个函数类型，它接受两个<code>int</code>，返回一个<code>int</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+ j;&#125;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i , <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i%j;&#125;;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的可调用对象共享了同一种调用形式。</p>
<p>我们希望使用这些可调用对象构建一个简单的桌面计算器，为了实现这一功能，需要定义一个寒暑表用于存储指向这些可调用对象的指针。</p>
<p>我们可以将<code>map</code>定义为如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下形式将<code>add</code>指针添加到<code>binops</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, add&#125;);</span><br></pre></td></tr></table></figure>

<p>但是我们不能将<code>mod</code>或者<code>divide</code>存入<code>binops</code>；</p>
<p>问题在于<code>mod</code>是一个<code>lambda</code>表达式，每个表达式有自己的类类型，该类型与存储在<code>binops</code>中的值类型不匹配。</p>
<p><strong>标准库function类型</strong></p>
<p><img src="https://raw.githubusercontent.com/love-fanfan/cloudimg/main/img/20210429204530.png" alt="image-20210429204504257"></p>
<p>参考其他模板，我们在一对尖括号内指定类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以用这个新声明的类型表示任意一种桌面计算器用到的类型；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();</span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; f2(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; f3(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>利用这个<code>function</code>类型我们可以重新定义<code>map</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br></pre></td></tr></table></figure>

<p>我们可以把所有可调用对象，包括函数指针、lambda或者函数对象在内，头添加到这个<code>map</code>中、。</p>
<p><strong>重载的函数与function</strong></p>
<p>我们不能直接将重载函数的名字存入<code>function</code>类型的对象中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+ j;&#125;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>,add&#125;); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>上诉代码会导致二义性问题。解决方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span> , <span class="keyword">int</span>) = add;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;); </span><br></pre></td></tr></table></figure>

<p>存储函数指针而非函数的名字。</p>
<p>或者，也可以利用lambda表达式来指定我们希望使用的add版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>,[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> add(a, b); &#125;&#125;); </span><br></pre></td></tr></table></figure>



<h4 id="14-9-重载、类型转换和运算符"><a href="#14-9-重载、类型转换和运算符" class="headerlink" title="14.9 重载、类型转换和运算符"></a>14.9 重载、类型转换和运算符</h4><p><strong>类型转换运算符</strong></p>
<p>这是类的一种特殊成员函数，它负责将一个类类型的值转换为其他类型。类型转换函数的一般形式如下所示：</p>
<p><code>operator type() const;</code></p>
<p>其中<code>type</code>表示某种类型，类型转化运算符可以面向任意类型（除了<code>void</code>之外）进行定义，只要该类型能作为函数的返回类型，因此，我们不允许转换为数组或者函数类型，但匀速转换为指针或者引用类型。</p>
<p>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。</p>
<blockquote>
<p>一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空，类型转换函数通常应该是<code>const</code>。</p>
</blockquote>
<p>我们定义一个比较简单的类，令其表示0到255之间的一个整数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">&quot;Bad SamllInt Value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">operator</span> <span class="title">in</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数将算术类型的值转换成<code>SmallInt</code>对象，而类型转换运算符将<code>SmallInt</code>对象转换为<code>int</code>;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;</span><br><span class="line">si + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<p><strong>显式的类型转换运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line">si + <span class="number">3</span>; <span class="comment">//错误，此处需要隐式的类型转换，但类的运算符是显式的。</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;<span class="comment">//正确，显式地请求类型转换</span></span><br></pre></td></tr></table></figure>



<p><strong>避免有二义性的类型转化</strong></p>
<p>如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。</p>
<p>在下面的例子中，我们定义了两种将B转换为A的方法：一种使用B的类型转换运算符、另一个使用A的以B为参数的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">const</span> B&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = f(b);</span><br><span class="line"><span class="comment">//二义性错误：含义是f(B::operator A())，还是f(A::A(const B&amp;))</span></span><br></pre></td></tr></table></figure>

<p>如果我们想执行上述的调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A a1 = f(b.<span class="keyword">operator</span> A());</span><br><span class="line">A a2 = f(A(b));</span><br></pre></td></tr></table></figure>



<p><strong>函数匹配与重载运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line">        <span class="keyword">friend</span></span><br><span class="line">        SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	SmallInt(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br><span class="line">SmallInt s1,s2;</span><br><span class="line">SmallInt s3 = s1 + s2;</span><br><span class="line"><span class="keyword">int</span> i = s3 + <span class="number">0</span>;	<span class="comment">//二义性错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</p>
</blockquote>
<h3 id="第15章-面向对象程序设计"><a href="#第15章-面向对象程序设计" class="headerlink" title="第15章 面向对象程序设计"></a>第15章 面向对象程序设计</h3><h4 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h4><p><strong>继承</strong></p>
<p>先定义的一个<code>Quote</code>的类，表示按原价销售的书籍。<code>Quote</code>派生出另一个名为<code>Bulk_quote</code>的类，表示可以打折销售的书籍。</p>
<ul>
<li><code>isbn()</code>返回书籍的编号，只定义在<code>Quote</code>类中。</li>
<li><code>net_price(size_t)</code>返回书籍的实际销售价格，这个操作是类型相关的，基类和派生类都包含该函数。</li>
</ul>
<p>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>派生类必须通过类派生列表明确指出它是从哪个基类继承而来的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态绑定</strong></p>
<p>通过使用动态绑定，我们可以通过同一段代码分别处理<code>Quote</code>和<code>Bulk_quote</code>的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_total(<span class="built_in">cout</span>, basic, <span class="number">20</span>);</span><br><span class="line">print_total(<span class="built_in">cout</span>, bulk, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//分别调用基类对象和派生类对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p>
</blockquote>
<h4 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h4><p><strong>定义基类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):</span><br><span class="line">    		bookNo(book), price(sales_price)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> n*price;&#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基类通常定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
</blockquote>
<p><strong>成员函数与继承</strong></p>
<p>​    基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数，对于前者，基类通常将其定义为<strong>虚函数</strong>，当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p>​    和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员，而受保护的成员派生类有权访问，同时禁止其他用户访问。</p>
<p><strong>定义派生类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>; <span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">    	<span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *p = &amp;bulk;</span><br><span class="line">Quote &amp;r = bulk;</span><br></pre></td></tr></table></figure>

<p>这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方，同样的道理应用于指针。</p>
<p><strong>派生类构造函数</strong></p>
<p>派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p,</span><br><span class="line">          <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">		  Quote(book, p), min_qty(qty), discount(disc)&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>派生类对象不能直接初始化基类的成员，尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做，和使用基类的其他场合一样，派生类应该遵守基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
</blockquote>
<p><strong>继承与静态成员</strong></p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base::statmem();</span><br><span class="line">    Derived::statmen();</span><br><span class="line">    </span><br><span class="line">    derived_obj.statmen();</span><br><span class="line">    statmen();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不同的访问方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>派生类的声明</strong></p>
<p>派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span><span class="keyword">public</span> Quote; <span class="comment">//错误：派生列表不能出现在这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>	<span class="comment">//正确：声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>



<p><strong>防止继承的发生</strong></p>
<p>C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字<code>final</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>不存在从基类向派生类的隐式类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;	<span class="comment">//错误</span></span><br><span class="line">Bulk_quote&amp; bulkP = base;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;	<span class="comment">//使用Quote::Quote(const Quote&amp;)构造函数</span></span><br><span class="line">item = bulk;		<span class="comment">//使用Quote::operator=(const Quote&amp;)</span></span><br></pre></td></tr></table></figure>







<p>当构造<code>item</code>时，运行<code>Quote</code>的拷贝构造函数，该函数只能处理基类的两个成员，它负责拷贝<code>bulk</code>中<code>Quote</code>部分的成员，同时忽略掉<code>bulk</code>中<code>Bulk_quote</code>部分的成员，也就是说该部分被切掉了。</p>
<h4 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h4><p>当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。</p>
<p>当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。</p>
<p><strong>派生类中的虚函数</strong></p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被他覆盖的基类函数完全一致。</p>
<p>同样，派生类中虚函数的返回类型与必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用是，上述规则无效，也就是说，如果D由B派生得到，则基类的虚函数可以返回<code>B*</code>而派生类的对应函数可以返回<code>D*</code>，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。</p>
<p>如果我们使用<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p>
<blockquote>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
<p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>该代码强行调用<code>Quote</code>的<code>net_price</code>函数，而不管<code>baseP</code>实际指向的对象类型到底是什么。</p>
<h4 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h4><p>我们定义一个新的类来支持不同的折扣策略，<code>Disc_quote</code>负责保存购买量的值和折扣值。</p>
<p><strong>纯虚函数</strong></p>
<p>我们可以将<code>net_price</code>定义成纯虚函数，这样做可以告诉用户当前这个函数时没有实际意义的，我们通过在函数体的位置（即在声明语句的分号之间）书写=0就可以将一个虚函数说明为纯虚函数，其中，<code>=0</code>只能出现在类内部的虚函数声明语句处。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disc_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Disc_quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">                  <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">    				Quote(book, price),</span><br><span class="line">    				quantity(qty), discount(disc)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。</p>
<blockquote>
<p>我们不能创建抽象基类的对象。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    	Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line">                  <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">    			Disc_quote(book, price, qty, disc)&#123;&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h4><p>受保护的成员</p>
<p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</p>
<p>和公有成员类似，受保护的成员对于派生类的成员和友元是可访问的。</p>
<p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    protect:</span><br><span class="line">    	<span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;	</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>&#123;s.j = s.prot_mem = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>公有、私有受保护的继承</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="keyword">int</span> prot_mem;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>派生访问说明符的目的是控制派生类用户对于基类成员的访问权限：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Pub_Derv d1;</span><br><span class="line">d1.pub_mem(); <span class="comment">//正确</span></span><br><span class="line">Priv_Derv d2;</span><br><span class="line">d2.pub_mem(); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>并且，<code>Priv_Derv</code>的派生类无法执行类的访问，对于它们而言，继承自<code>Base</code>的所有成员都是私有的。</p>
<p>我的理解是，在派生类的定义时，派生访问说明符是没有特别作用的，只有在类使用时，比如类对象</p>
<blockquote>
<p>假定我们还定义了一个<code>Prot_Derv</code>的类，采用受保护继承，则<code>Base</code>的所有公有成员在新定义的类中都是受保护的。<code>Prot_Derv</code>的用户不能访问<code>pub_mem</code>，但是<code>Prot_Derv</code>的成员和友元可以访问那些继承而来的成员。</p>
</blockquote>
<p><strong>友元与继承</strong></p>
<p>就像友元关系不能传递一样，友元关系同样也不能继承，类似的，派生类的友元也不能随意访问基类的成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;<span class="keyword">return</span> b.prot_mem;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.j;&#125; <span class="comment">//错误: Pal 不是Sneaky的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.prot_mem;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Pal&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.prot_mem; <span class="comment">//错误，友元关系不能继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不能继承友元关系，每个类负责控制各自成员的访问权限。</p>
</blockquote>
<p><strong>改变个别成员的可访问性</strong></p>
<p>有时，我们需要改变派生类继承的某个名字的访问级别，通过使用<code>using</code>声明。</p>
<p><strong>继承保护级别</strong></p>
<p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的，而使用<code>struct</code>关键字定义的派生类是公有继承的。</p>
<h4 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h4><p>派生类的作用域位于基类作用域之内。</p>
<p>和其他作用域一样，派生类也能重新定义在其直接基类或间接基类中的名字，此时，定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域的名字。</p>
<blockquote>
<p>即，派生类的成员将隐藏同名的基类成员。</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
</blockquote>
<p><strong>虚函数与作用域</strong></p>
<p>如果基类与继承类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。</p>
<h4 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h4><p><strong>虚析构函数</strong></p>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Quote *item = <span class="keyword">new</span> Quote;</span><br><span class="line"><span class="keyword">delete</span> item; <span class="comment">//调用Quote的析构函数</span></span><br><span class="line">item = <span class="keyword">new</span> Bulk_quote;</span><br><span class="line"><span class="keyword">delete</span> item; <span class="comment">//调用Bulk_quote的析构函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</p>
</blockquote>
<p>之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并不需要上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法因此推断基类还需要赋值运算符或拷贝构造函数。</p>
<p><strong>析构函数将阻止合成移动操作</strong></p>
<p><strong>合成拷贝控制与继承</strong></p>
<p>基类和派生类对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或校会的操作。例如：</p>
<p>合成的<code>Bulk_quote</code>默认构造函数运行<code>Disc_quote</code>的默认构造函数，后者又运行<code>Quote</code>的默认构造函数。</p>
<p><strong>派生类中删除的拷贝控制与基类的关系</strong></p>
<p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问的，则派生类中对应的成员将是被删除的。</p>
<p><strong>派生类的拷贝控制成员</strong></p>
<p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类的赋值运算符也必须为其基类部分的成员赋值。</p>
<p>​    和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。</p>
<blockquote>
<p>派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分基类部分成员在内的整个对象。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	D(<span class="keyword">const</span> D&amp; d): Base(d)<span class="comment">//拷贝基类成员</span></span><br><span class="line">            </span><br><span class="line">        D(D&amp;&amp; d):Base(<span class="built_in">std</span>::move(d))<span class="comment">//移动基类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝（或移动）构造函数。</p>
</blockquote>
<p><strong>派生类赋值运算符</strong></p>
<p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);<span class="comment">//为基类赋值</span></span><br><span class="line">    <span class="comment">//按照过去的方式为派生类成员赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>派生类析构函数</strong></p>
<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数。</p>
<p><strong>继承的构造函数</strong></p>
<p>一个类也只能继承其直接基类的构造函数，类不能继承默认、拷贝和移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>:</span><span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">using</span> Disc_quote::Disc_quote;</span><br><span class="line">    	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些编译器生成的构造函数形如：</p>
<p><code>derived(parms) : base(args)&#123;&#125;</code></p>
<p>其中，<code>derived</code>是派生类的名字，<code>base</code>是基类的名字，<code>parms</code>是构造函数的形参列表，<code>args</code>将派生类构造函数的形参传递给基类的构造函数。在我们的<code>Bulk_quote</code>类中，继承的构造函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">	Disc_quote(book, price, qty, disc)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>
<p>当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（ 没有默认实参），另一个构造函数只接受一个形参，对应于基类中最左侧的没有默认值的那个形参。</p>
<h4 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h4><p><strong>在容器中放置指针而非对象</strong></p>
<p>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针。和往常一样，这些指针所指向对象的动态类型可能是基类类型，也可能是派生类类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(<span class="string">&quot;0-201-82470-1&quot;</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(</span><br><span class="line">    make_shared&lt;Bulk_quote&gt;(<span class="string">&quot;0-201-82470-8&quot;</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));</span><br></pre></td></tr></table></figure>

<p>可以把派生类的指针（智能）转化为基类的指针（智能）。</p>
<h3 id="第16章-模板与泛型编程"><a href="#第16章-模板与泛型编程" class="headerlink" title="第16章 模板与泛型编程"></a>第16章 模板与泛型编程</h3><h4 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h4><p><strong>函数模板</strong></p>
<p>模板定义以关键字<code>template</code>开始，后跟一个<strong>模板参数列表</strong>，这是一个逗号分隔的一个或多个模板参数的列表。</p>
<p>在模板定义中，模板参数列表不能为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//推断出T为int</span></span><br></pre></td></tr></table></figure>

<p><strong>模板类型参数</strong></p>
<p>类型参数必须使用关键字<code>class</code>和<code>typename</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误，U之前必须加上class 或typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span> &gt;</span> calc(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;);</span><br><span class="line"><span class="comment">//正确，在模板参数列表中，typename和class没有什么区别。</span></span><br></pre></td></tr></table></figure>



<p><strong>非类型模板参数</strong></p>
<p>除了定义类型参数，还可以在模板中定义非类型参数，一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字<code>class</code>或<code>typename</code>来指定非类型参数。</p>
<p>我们编写一个<code>compare</code>版本处理字符串字符常量，由于希望比较不同长度的字符串字符常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>compare</code>时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">compare(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>编译器会使用字面常量的大小来代替<code>N</code>和<code>M</code>，从而实例化模板，记住，编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符。</p>
<blockquote>
<p>非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>
<p>函数模板可以声明为<code>inline</code>或者<code>contexpr</code>的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//错误，inline说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板程序应该尽量减少对实参类型的要求。</p>
</blockquote>
<p>​    通常，当我们调用一个函数时，编译器只需要掌握函数的声明，类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>​    类模板则不同，为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p><strong>类模板</strong></p>
<p>与函数模板不同，编译器不能为类模板推断参数类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个类模板的每个实例都形成一个独立的类，类型<code>Blob&lt;string&gt;</code>与任何其他<code>Blob</code>类型都没有关联，也不会对任何其他<code>Blob</code>类型的成员有特殊访问权限。</p>
</blockquote>
<p><strong>类模板的成员函数</strong></p>
<p>​    与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p>
<p>​    类模板的成员函数具有和模板相同的模板参数，因而，定义在类模板之外的成员函数就必须以关键字<code>template</code>开始，后接类模板参数列表。</p>
<p>​    对于<code>StrBlob</code>的一个给定的成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret-type StrBlob::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>对应的<code>Blob</code>的成员应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>



<p><strong>构造函数</strong></p>
<p>与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(): data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>类模板成员函数的实例化</strong></p>
<p>如果一个成员函数没有被使用，则它不会被实例化，成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。</p>
<blockquote>
<p>默认情况下，对于一个实例化的类模板，其成员只有在使用时才被实例化。</p>
</blockquote>
<p><strong>在类代码内简化模板类名的使用</strong></p>
<p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外，在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&#123;</span></span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即，就好像我们这样编写代码一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BlobPtr&lt;T&gt;&amp; <span class="keyword">operator</span>++();</span><br></pre></td></tr></table></figure>



<p><strong>类模板和友元</strong></p>
<p>​    当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例，如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== &lt;T&gt;</span><br><span class="line">        (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友好关系被限定在用相同类型实例化的<code>Blob</code>与<code>BlobPtr</code>相同运算符之间；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca;</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;</span><br></pre></td></tr></table></figure>

<p>​    <code>BlobPtr&lt;char&gt;</code>的成员可以访问<code>ca</code>(或者其他<code>Blob&lt;char&gt;</code>对象)的非<code>public</code>部分，但<code>ca</code>对<code>ia</code>(或者其他<code>Blob&lt;int&gt;</code>对象)或<code>Blob</code>的任何其他实例都没有特殊访问权限。</p>
<p>​    一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;;</span><br><span class="line">    <span class="comment">//用类C实例化的Pal是C的一个友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">    <span class="comment">//Pal2的所有实例都是C的友元</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;;</span><br><span class="line">    <span class="comment">//C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">    <span class="comment">//Pal2的所有实例都是C的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> </span><br><span class="line">    <span class="comment">//Pal3是一个非模板类，是所有实例的友元，不需要Pal3的前置声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>令类型参数成为友元</strong></p>
<p>在新标准中，我们可以将模板类型参数声明为友元；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，对于某个类型名<code>Foo</code>,<code>Foo</code>将成为<code>Bar&lt;Foo&gt;</code>的友元，<code>Sales_data</code>将成为<code>Bar&lt;Sales_data&gt;</code>的友元，以此类推。</p>
<p><strong>模板类型别名</strong></p>
<p>我们可以定义一个<code>typedef</code>来引用实例化的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure>

<p>无法定义一个<code>typedef</code>引用<code>Blob&lt;T&gt;</code></p>
<p>但是，新标准允许我们为类模板定义一个类型别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = <span class="built_in">pair</span>&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">//authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>static成员</strong></p>
<p>与其他类相同，类模板可以声明<code>static</code>成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ctr;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>Foo</code>的实例都有其自己的<code>static</code>成员实例，即，对任意给定类型<code>X</code>，都有一个<code>Foo&lt;X&gt;::ctr</code>和一个<code>Foo&lt;X&gt;::count</code>成员。所有<code>Foo&lt;X&gt;</code>类型的对象共享相同的<code>ctr</code>对象和<code>count</code>函数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi,fi2,fi3;</span><br><span class="line"><span class="comment">// 所有三个对象共享相同的`ctr`对象和`count`函数</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过类类型对象来访问一个类模板的<code>static</code>成员，也可以使用作用域运算符直接访问成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;</span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;::count();</span><br><span class="line">ct = fi.count();</span><br><span class="line">ct = Foo::count();<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>



<p><strong>模板参数</strong></p>
<p>类似函数参数的名字，我们通常将类型参数命名为<code>T</code>，但实际上我们可以使用任何名字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Foo&gt; <span class="function">Foo <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Foo&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo tmp = a;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>模板参数与作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A tmp = a;</span><br><span class="line">    <span class="keyword">double</span> B; <span class="comment">//错误：重声明模板参数B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt; </span><br><span class="line"><span class="comment">//错误，非法重用模板参数名V</span></span><br></pre></td></tr></table></figure>

<p><strong>模板声明</strong></p>
<p>模板声明必需包含模板参数。</p>
<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，我们通过关键字<code>typename</code>来实现这一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span> <span class="params">(<span class="keyword">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back():</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。</p>
</blockquote>
<p><strong>默认模板实参</strong></p>
<p>我们可以提供默认模板实参。</p>
<p>我们重写<code>compare</code>，默认使用标准库的<code>less</code>函数对象模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T&amp;v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户调用这个版本的<code>compare</code>时，可以提供自己的比较操作，但这并不是必需的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> j = compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>



<p><strong>模板默认实参与类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> =</span> <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Numbers(T v = <span class="number">0</span>): val(V)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lot;</span><br><span class="line">Numbers&lt;&gt; av;<span class="comment">//空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>



<p><strong>成员模板</strong></p>
<p>​    一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数，这种成员被称为成员模板，成员模板不能是虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>): os(s)	&#123;&#125;</span><br><span class="line">    	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T *p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    	</span>&#123; os &lt;&lt; <span class="string">&quot;deleting&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">delete</span> p;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d;</span><br><span class="line">d(p);<span class="comment">//调用DebugDelete::operator()(double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">DebugDelete()(ip);</span><br><span class="line"><span class="comment">//在一个临时DebugDelete对象上调用DebugDelete::operator()(int*)</span></span><br></pre></td></tr></table></figure>

<p>我们可以将<code>DebugDelete</code>用作<code>unique_ptr</code>的删除器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());</span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span><br></pre></td></tr></table></figure>



<p><strong>类模板的成员模板</strong></p>
<p>​    对于类模板，我们也可以为其定义成员模板，在此情况下，类和成员各自有自己的、独立的模板参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; Blob(It b, It e);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在类模板外定义一个成员模板是，必须同时为类模板和成员模板挺模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">//构造函数的类型参数</span></span><br><span class="line">	Blob&lt;T&gt;::Blob(It b, It e):</span><br><span class="line">		data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e))&#123;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>实例化与成员模板</strong></p>
<p>为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。</p>
<p>我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">al</span><span class="params">(begin(ia), end(ia))</span></span>;</span><br><span class="line"><span class="comment">//调用了如下版本:</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt;::Blob(<span class="keyword">int</span>*, <span class="keyword">int</span>*);</span><br></pre></td></tr></table></figure>



<p><strong>控制实例化</strong></p>
<p>在大系统中，多个文件中实例化相同模板的额外开销可能非常严重，在新标准中，我们可以通过显式实例化来避免这种开销。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure>

<p><code>declaration</code>是一个类或函数声明，其中所有模板参数已被替换为模板实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span><span class="built_in">string</span>&gt;; <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>

<p>当编译器遇到<code>extern</code>模板声明时，它不会再本文件中生成实例化代码，将一个实例化声明为<code>extern</code>就表示承诺在程序其他位置有该实例化的一个非<code>extern</code>声明（定义）。对于一个给定的实例化版本，可能有多个<code>extern</code>声明，但必须只有一个定义。</p>
<blockquote>
<p>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义</p>
</blockquote>
<blockquote>
<p>在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。</p>
</blockquote>
<h4 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h4><p>从函数实参来确定模板实参的过程被称为<strong>模板实参推断</strong>。</p>
<p><strong>类型转换与模板类型参数</strong></p>
<p>在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li><code>const</code>转换：可以将一个非<code>const</code>对象的引用（或指针）传递给一个<code>const</code>的引用（或指针）形参。</li>
<li>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能用于函数模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T,T)</span></span>;		<span class="comment">// 实参拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;another val&quot;</span>)</span></span>;</span><br><span class="line">fobj(s1,s2);		<span class="comment">// 调用 fobj(string,string)，实参顶层 const 被忽略</span></span><br><span class="line">fref(s1,s2);		<span class="comment">// 调用 fref(const string&amp;,const string&amp;)，形参顶层 const 被忽略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],b[<span class="number">52</span>];</span><br><span class="line">fobj(a,b);			<span class="comment">// 调用 fobj(int*,int*);</span></span><br><span class="line">fref(a,b);			<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>如果形参是一个引用，则数组不会转换为指针，a和b的类型是不匹配的，因此调用是错误的。</p>
<blockquote>
<p>如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p>
</blockquote>
<p><strong>函数模板显式实参</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在本例中，没有任何函数实参的类型可用来推断<code>T1</code>的类型。每次调用<code>sum</code>时调用者都必须为<code>T1</code>提供一个<strong>显式模板实参</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>

<p>此调用显式指定<code>T1</code>的类型，而<code>T2</code>和<code>T3</code>的类型则由编译器推断出来。</p>
<p>​        显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br><span class="line"><span class="comment">//糟糕的设计</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">//错误，不能推断出T3模板实参</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">//正确&lt;long long, int, long&gt;分别对应 T1,T2,T3</span></span><br></pre></td></tr></table></figure>



<p><strong>正常类型转换应用于显式指定的实参</strong></p>
<p>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);		  <span class="comment">//错误，模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">//正确，实例化compare(long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>如我们所见，第一个调用是错误的，因为传递给<code>compare</code>的实参必须具有相同的类型。如果我们显式指定模板类型参数，就可以进行正常类型转换了。</p>
<p><strong>尾置返回类型和类型转换</strong></p>
<p>由于尾置返回出现在参数列表之后，它可以使用函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>decltype</code>推断的类型为<code>beg</code>表示的元素的类型的引用。</p>
<p><strong>进行类型转换的标准库模板类</strong></p>
<p>为了获取元素类型，我们可以使用标准库的<strong>类型转换</strong>模板，这些模板定义在头文件<code>type_traits</code>中。</p>
<p>我们可以使用<code>remove_reference</code>来获取元素类型，<code>remove_reference</code>模板有一个模板类型参数和一个名为<code>type</code>的<code>(public)</code>类型成员。如果我们用一个引用类型实例化<code>remove_reference</code>，则<code>type</code>将表示被引用的类型。例如，如果我们实例化<code>remove_reference&lt;int&amp;&gt;</code>，则<code>type</code>成员将是<code>int</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line"><span class="comment">//将获得beg引用的元素的类型</span></span><br></pre></td></tr></table></figure>

<p><code>decltype(*beg)</code>返回元素类型的引用类型。<code>remove_reference::type</code>脱去引用，剩下元素类型本身。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; </span><br><span class="line">	<span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/love-fanfan/cloudimg/img/image-20210903095629082.png" alt="image-20210903095629082"></p>
<p><strong>函数指针和实参推断</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br><span class="line"><span class="comment">//pf指向实例int compare(const int&amp;, const int&amp;) </span></span><br></pre></td></tr></table></figure>

<p><code>func</code>的重载版本，每个版本接受一个不同的函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">func(compare); <span class="comment">// 错误，使用compare的哪个实例？</span></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">//正确，显式模板实参消除func调用的歧义</span></span><br></pre></td></tr></table></figure>



<p><strong>模板实参推断和引用</strong></p>
<p>在[13.6 对象移动](#13.6 对象移动) 中，已经介绍过一次左值、右值引用的概念，在这里结合我自己的理解，重新梳理一遍。</p>
<p><strong>1. 左值、右值</strong></p>
<p>左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li>
<li>5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。</li>
</ul>
<p>再举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>) &#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">A a = A();</span><br></pre></td></tr></table></figure>

<ul>
<li>同样的，a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li>
<li>A()是个临时值，没法通过 &amp; 取地址，位于等号右边，所以A()是个右值。</li>
</ul>
<p>可见左右值的概念很清晰，有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<p><strong>2. 什么是左值引用、右值引用</strong></p>
<p><strong>2.1 左值引用</strong></p>
<p>左值引用大家都很熟悉，<strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>

<p><strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。</strong></p>
<p>但是，const左值引用是可以指向右值的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>

<p>const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用<code>const &amp;</code>作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<p><strong>2.2 右值引用</strong></p>
<p>再看下右值引用，右值引用的标志是<code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"> </span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>



<p><strong>2.3 右值引用有办法指向左值吗？</strong></p>
<p>有办法，<code>std::move</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>

<p>在上边的代码里，看上去是左值a通过std::move移动到了右值ref_a_right中，那是不是a里边就没有值了？并不是，打印出a的值仍然是5。</p>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong></p>
<p>同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="number">5</span>;</span><br><span class="line">ref_a = <span class="number">6</span>; </span><br><span class="line"> </span><br><span class="line">等同于以下代码：</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="built_in">std</span>::move(temp);</span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形参是个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;</span><br><span class="line">    right_value = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// ref_a_left是个左值引用</span></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// ref_a_right是个右值引用</span></span><br><span class="line"> </span><br><span class="line">    change(a); <span class="comment">// 编译不过，a是左值，change参数要求右值</span></span><br><span class="line">    change(ref_a_left); <span class="comment">// 编译不过，左值引用ref_a_left本身也是个左值</span></span><br><span class="line">    change(ref_a_right); <span class="comment">// 编译不过，右值引用ref_a_right本身也是个左值</span></span><br><span class="line">     </span><br><span class="line">    change(<span class="built_in">std</span>::move(a)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_right)); <span class="comment">// 编译通过</span></span><br><span class="line">    change(<span class="built_in">std</span>::move(ref_a_left)); <span class="comment">// 编译通过</span></span><br><span class="line"> </span><br><span class="line">    change(<span class="number">5</span>); <span class="comment">// 当然可以直接接右值，编译通过</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    <span class="comment">// 打印这三个左值的地址，都是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完后你可能有个问题，std::move会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以move返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：<strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>没有什么区别，等号左边就是左值，右边就是右值。</p>
<p>书归正传…</p>
<p><strong>从左值引用函数参数推断类型</strong></p>
<p>当一个函数参数是模板类型参数的一个普通左值引用是，规定告诉我们，只能传递给它一个左值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">f1(i); <span class="comment">//ok</span></span><br><span class="line">f1(ci); <span class="comment">// T是const int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">//错误，传递给&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>

<p>如果一个函数参数的类型是<code>const T&amp;</code>，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象、一个临时对象或是一个字面常量值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">f1(i); <span class="comment">// ok</span></span><br><span class="line">f1(ci); <span class="comment">// T是int</span></span><br><span class="line">f1(<span class="number">5</span>); <span class="comment">// 一个const &amp;参数可以绑定到一个右值；T是int</span></span><br></pre></td></tr></table></figure>

<p><strong>从右值引用函数参数推断类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">//模板参数T是int</span></span><br></pre></td></tr></table></figure>



<p><strong>引用折叠</strong></p>
<p>在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X：</p>
<ul>
<li>类型<code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code></li>
<li>类型<code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code></li>
</ul>
<blockquote>
<p>引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f3(i); <span class="comment">// 实参是一个左值：模板参数T是int&amp;</span></span><br><span class="line">f3(ci); <span class="comment">// 实参是一个左值：模板参数T是const int&amp;</span></span><br><span class="line"><span class="comment">//当T是int&amp;时，函数参数为int&amp; &amp;&amp;</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp; &amp;&amp;);</span><br><span class="line"><span class="comment">//函数折叠为：</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span>&amp;&gt;(<span class="keyword">int</span>&amp;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个函数参数是指向模板参数类型的右值引用（如，T&amp;&amp;）、则可以传递给他任意类型的实参。</p>
</blockquote>
<p><strong>编写接受右值引用参数的模板函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = val;</span><br><span class="line">    t = fcn(t);</span><br><span class="line">    <span class="keyword">if</span>(val == t)</span><br><span class="line">    &#123;<span class="comment">/*    */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>当我们对一个右值调用<code>f3</code>时，例如字面常量42，<code>T</code>为<code>int</code>。当我们对<code>t</code>赋值时，参数<code>val</code>保持不变。</p>
<p>另一方面，当我们对一个左值<code>i</code>调用<code>f3</code>时，则<code>T</code>为<code>int &amp;</code>，因此，对<code>t</code>的初始化将其绑定到<code>val</code>。当我们改变<code>t</code>的值时，也同时改变了<code>val</code>的值。所以，在这个实例化版本中，<code>if</code>判断永远得到<code>true</code>。</p>
<p>使用右值引用的函数模板通常使用我们在13.6节中看到的方式来进行重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>



<p>理解 <code>std::move</code> </p>
<p><code>std::move</code> 是如何定义的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>std::move</code> 的函数参数是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。</p>
<p><code>static_cast</code>在第4节介绍过，其作用是强制类型转换。</p>
<p><strong>转发</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们希望用它调用一个接受引用参数的函数时就会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>f</code>改变了绑定到<code>v2</code>的实参的值，但是，如果我们通过<code>flip1</code>调用<code>f</code>，<code>f</code>所做的改变就不会影响实参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(<span class="number">42</span>, i); <span class="comment">//f改变了实参i</span></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">//不会改变j</span></span><br></pre></td></tr></table></figure>

<p>问题在于<code>j</code>被传递给<code>flip1</code>的参数<code>t1</code>。此参数是一个普通的、非引用的类型<code>int</code>，而非<code>int&amp;</code>。因此，这个<code>flip1</code>调用实例化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip1</span><span class="params">(<span class="keyword">void</span>(*fcn)(<span class="keyword">int</span>, <span class="keyword">int</span>&amp;), <span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>j</code>的值被拷贝到<code>t1</code>中。<code>f</code>中的引用参数被绑定到<code>t1</code>，而非<code>j</code>，从而其改变不会影响<code>j</code>。</p>
<p><strong>定义能保持类型信息的函数参数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flip1(f, j, <span class="number">42</span>); <span class="comment">//改变j</span></span><br></pre></td></tr></table></figure>

<p>在<code>flip2</code>中，推断出的<code>T1</code>的类型为<code>int&amp;</code>，由于是引用类型，<code>t1</code>被绑定到<code>j</code>上。调用<code>f</code>时，<code>f</code>中的引用参数<code>v2</code>被绑定到<code>t1</code>，也就是<code>j</code>上。当<code>v2</code>递增时，也同时改变了<code>j</code>的值。</p>
<blockquote>
<p>如果一个函数参数是指向模板类型参数的右值引用(如<code>T&amp;&amp;</code>)，它对应的实参的<code>const</code>属性和左值/右值属性将得到保持。</p>
</blockquote>
<p>这个版本不能用于接受右值引用参数的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flip2(g, i, <span class="number">42</span>);</span><br><span class="line"><span class="comment">//调用时， t2 是右值引用，但是t2自身是左值，所以用一个左值去实例化int&amp;&amp;是错误的</span></span><br></pre></td></tr></table></figure>



<p><strong>在调用中使用std::forward保持类型信息</strong></p>
<p>​        类似<code>move</code>，<code>forward</code>定义在头文件<code>utility</code>中。与<code>move</code>不同，<code>forward</code>必须通过显式模板实参来调用，<code>forward</code>返回该显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T2&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果我们调用<code>flip(g, i, 42)</code>，<code>i</code>将以<code>int&amp;</code>类型传递给<code>g</code>，<code>42</code>将以<code>int&amp;&amp;</code>类型传递给<code>g</code>。</p>
<h4 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h4><p>​    函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。</p>
<p><strong>编写重载模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们定义打印指针的<code>debug_rep</code>版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，此函数不能用于char*;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">&quot;pointer: &quot;</span> &lt;&lt; p; <span class="comment">//打印指针本身的值</span></span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        ret &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; debug_rep(*p); <span class="comment">//打印p指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">&quot;null pointer&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.str(); <span class="comment">//返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以这样使用这些函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s(&quot;hi&quot;)；</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>对于这个调用，只有第一个版本的<code>debug_rep</code>是可行的。第二个<code>debug_rep</code>版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数都有可行的实例：</p>
<ul>
<li><code>debug_rep(const string*&amp;)</code>，由第一个版本实例化而来，<code>T</code>被绑定到<code>string*</code>。</li>
<li><code>debug_rep(string*)</code>，由第二个版本实例化而来 ，<code>T</code>被绑定到<code>string</code>。</li>
</ul>
<p>第二个版本的<code>debug_rep</code>的实例是此调用的精确匹配。第一个版本的实例需要进行普通指针到<code>const</code>指针的转换。正常函数匹配规则告诉我们应该选择第二个版本模板，实际上编译器确实选择了这个版本。</p>
<p><strong>多个可行模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(sp) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>此例中的两个模板都是可行的，而且两个都是精确匹配：</p>
<ul>
<li><code>debug_rep(const string*&amp;)</code>，由第一个版本的<code>debug_rep</code>实例化而来，<code>T</code>被绑定到<code>string*</code></li>
<li><code>debug_rep(const string*)</code>，由第二个版本实例化而来 ，<code>T</code>被绑定到<code>const string</code>。</li>
</ul>
<p>此调用被解析为<code>debug_rep(T*)</code>，即，更特例化的版本。</p>
<p>此问题在于模板<code>debug_rep(const T&amp;)</code>本质上可以用于任何类型，包括指针类型，此模板比<code>debug_rep(T*)</code>更通用，后者只能用于指针类型。</p>
<blockquote>
<p>当有多个重载模板对一个调用提供同样好的匹配是，应选择最特例化的版本。</p>
</blockquote>
<p><strong>非模板和模板重载</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>debug_rep</code>时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s(&quot;hi&quot;)；</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>有两个同样好的可行函数：</p>
<ul>
<li><code>debug_rep&lt;string&gt;(const string*&amp;)</code>，由第一个版本的<code>debug_rep</code>实例化而来，<code>T</code>被绑定到<code>string*</code></li>
<li><code>debug_rep(const string*)</code>，普通非模板函数。</li>
</ul>
<p>编译器选择最特例化的版本，出于相同的原因，一个非模板函数比一个模板函数更好。</p>
<p><strong>重载模板和类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(<span class="string">&quot;hi world~&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>三个版本都是可行的：</p>
<p><code>debug_rep(const T&amp;)</code>，<code>T</code>被绑定到<code>char[10]</code>。</p>
<p><code>debug_rep(T*)</code>，<code>T</code>被绑定到<code>const char</code>。</p>
<p><code>debug_rep(const string&amp;)</code>要求从<code>const char*</code>到<code>string</code>的类型转换。</p>
<p>非模板版本需要进行一次用户定义的类型转换，因此没有那么好。</p>
<p><code>T*</code>版本更加特例化，编译器会选择它。</p>
<blockquote>
<p>在定义任何函数之前，记得声明所哟重载的函数版本。这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非你需要的版本。</p>
</blockquote>
<h4 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h4><p>​        一个可变参数模板就是一个接受可变数目的模板函数或模板类。可变数目的参数被称为参数包。存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Args 是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明了<code>foo</code>是一个可变参数函数模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">&quot;how&quot;</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d);</span><br><span class="line">f00(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会为<code>foo</code>实例化出不同的版本；</p>
<p><strong><code>sizeof</code>…运算符</strong></p>
<p>当我们需要知道包中有多少个元素时，可以：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">template&lt;typename ... Args&gt; void g(Args ...args)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//类型参数的数目</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编写可变参数函数模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此函数必须在可变参数版本的print之前定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变参数版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;s, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...); <span class="comment">//递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>包扩展</strong></p>
<p>对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展。当扩展一个包时，我们还要提供每个扩展元素的模式。扩展一个包就是将它分解为构成的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;s, <span class="keyword">const</span> Args&amp;... rest)</span> <span class="comment">//扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...);  <span class="comment">//扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>理解包扩展</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> print(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模式表示我们希望对函数参数包<code>rest</code>中的每个元素调用<code>debug_rep</code>。与之相较，下面的模式会编译失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">print(os, debug_rep(rest...));</span><br></pre></td></tr></table></figure>

<p>这段代码的问题是我们在<code>debug_rep</code>调用中扩展了<code>rest</code>，它等价于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">cerr</span>, debug_rep(fcn, code.num(),</span><br><span class="line">                     otherData, item));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展中的模式会独立地应用于包中的每个元素。</p>
</blockquote>
<p><strong>转发参数包</strong></p>
<p>我们可以组合使用可变参数模板与<code>forward</code>机制来编写函数，实现将其实参不变地传递给其他函数。</p>
<p>首先，为了保持实参中的类型信息，必须将<code>emplace_back</code>的函数参数定义为模板类型参数的右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既扩展了模板参数包<code>Args</code>，也扩展了函数参数包<code>args</code>.</p>
<p>通过在此调用中使用<code>forward</code>，我们保证如果用一个右值调用<code>emplace_back</code>，则<code>construct</code>也会得到一个右值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">svec.emplace_back(s1+s2);</span><br></pre></td></tr></table></figure>



<h4 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//第一个版本，可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br><span class="line"><span class="comment">//第二个版本处理字符串字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">&quot;hi&quot;</span>, *p2 = <span class="string">&quot;mom&quot;</span>;</span><br><span class="line">compare(p1, p2); <span class="comment">//调用第一个模板</span></span><br><span class="line">compare(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>); <span class="comment">//调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>

<p>我们无法将一个指针转换为一个数组的引用，因此当参数是<code>p1</code>和<code>p2</code>时，第二个版本的<code>compare</code>是不可行的。</p>
<p>为了处理字符指针，可以为第一个版本的<code>compare</code>定义一个<strong>模板特例化</strong>版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<p><strong>定义函数模板特例化</strong></p>
<p>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参，为了指出我们正在实例化一个模板，应使用关键字<code>template</code>后跟一个空尖括号对<code>&lt;&gt;</code>。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数重载与模板实例化</strong></p>
<p>一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</p>
<p>当我们调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">compare(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对此调用，两个函数模板都是可行的。且提供同样好的匹配。但是，接收字符数组参数的版本更特例化，因此编译器会选择它。</p>
<blockquote>
<p>模板及其特例化版本应该声明在同一文件夹中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p>
</blockquote>
<p><strong>类模板特例化</strong></p>
<p>必须在原模板定义所在的空间中特例化它。为达到这一目的，首先必须打开命名空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码定义了一个能处理<code>Sales_data</code>的特例化<code>hash</code>版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>Saled_data&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">        <span class="keyword">typedef</span> Sales_data argument_type;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; s)</span><span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">size_t</span></span><br><span class="line">    hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ </span><br><span class="line">            hash&lt;<span class="built_in">string</span>&gt;()(s.units_sold) ^</span><br><span class="line">            hash&lt;<span class="built_in">string</span>&gt;()(s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭std命名空间；注意，花括号之后没有分号</span></span><br></pre></td></tr></table></figure>

<p>类似其他任何类，我们可以在类内或类外定义特例化版本的成员。</p>
<p>由于<code>hash&lt;Sales_data&gt;</code>使用<code>Sales_data</code>的私有成员，我们必须将它声明为<code>Sales_data</code>的友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash; <span class="comment">//友元声明所需要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了让<code>Sales_data</code>的用户能使用<code>hasn</code>的特例化版本，我们应该在<code>Sales_data</code>的头文件中定义特例化版本。</p>
</blockquote>
<p><strong>类模板部分特例化</strong></p>
<p>​        与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化本身是一个模板，使用它是用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<blockquote>
<p>我们只能部分特例化类模板，而不能部分特例化函数模板。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//原始版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&gt;</span><br><span class="line">	&#123;<span class="keyword">typedef</span> T type; &#125;;<span class="comment">//左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>T&amp;&gt;</span><br><span class="line">	&#123;<span class="keyword">typedef</span> T type; &#125;;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>



<p>我们可以只特例化特定成员函数而不是特例化整个模板。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    Foo(<span class="keyword">const</span> T &amp;t = T()) : mem(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    T mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//特例化Foo&lt;int&gt;的成员Bar</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">//实例化</span></span><br><span class="line">fs.Bar();    	<span class="comment">//正常实例化</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;     <span class="comment">//实例化</span></span><br><span class="line">fi.Bar();  		<span class="comment">//使用特例化版本的Bar()</span></span><br></pre></td></tr></table></figure>



























































]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++primer</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/07/31/EffectiveC++%E4%B8%AD%E6%96%87%E7%89%88/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h4><h4 id="定义式"><a href="#定义式" class="headerlink" title="定义式"></a>定义式</h4><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="comment">// default 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的构造函数都被声明为<code>explicit</code>，这可以阻止它被用来执行隐式类型转换，但是它仍可以进行显式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>; <span class="comment">//函数</span></span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>); <span class="comment">//错误，int和B之间没有隐式转换。</span></span><br><span class="line"></span><br><span class="line">doSomething(B(<span class="number">28</span>)); <span class="comment">//没问题，可以执行显式转换。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>被声明为<code>explicit</code>的构造函数通常比其<code>non-explicit</code>兄弟更受欢迎。</p>
</blockquote>
<h4 id="copy-构造函数"><a href="#copy-构造函数" class="headerlink" title="copy 构造函数"></a>copy 构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Widget();</span><br><span class="line">    	Widget(<span class="keyword">const</span> Widget&amp; rhs); <span class="comment">//copy构造函数</span></span><br><span class="line">    	Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs); <span class="comment">//copy assignment 操作符	</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	Widget w1;</span><br><span class="line">	<span class="function">Widget <span class="title">w1</span><span class="params">(w2)</span></span>; <span class="comment">//copy构造函数</span></span><br><span class="line">	w1 = w2; <span class="comment">//copy assignment</span></span><br><span class="line">	Widget w3 = w2; <span class="comment">//copy构造函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>w3</code>，一个新对象被定义，一定会有一个构造函数被调用，不可能调用赋值操作。</p>
</blockquote>
<h2 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1 让自己习惯C++"></a>1 让自己习惯C++</h2><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><p>今天的<code>C++</code>已经是个多重范型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。</p>
<p>你必须认识其主要的次语言。</p>
<ul>
<li>C。说到底C++仍然是以C为基础。</li>
<li><code>Object-Oriented C++</code>。这一部分也就是<code>C with Classes</code>所诉求的：<code>classes</code>（包括构造函数和析构函数），封装（<code>encapsulation</code>）、继承（<code>inheriance</code>）、多态（<code>polymorphism</code>）、<code>virtual</code>函数（动态绑定）…这一部分是面向对象编程。</li>
<li><code>Template C++</code>。这是C++的泛型编程部分，也是大多数程序员经验最少的部分。</li>
<li><code>STL</code>。<code>STL</code>是个<code>template</code>程序库，它对容器、迭代器、算法以及函数对象的规约有极佳的紧密配合与协调。</li>
</ul>
<h3 id="条款02：尽量以const、enum、inline替换-define"><a href="#条款02：尽量以const、enum、inline替换-define" class="headerlink" title="条款02：尽量以const、enum、inline替换 #define"></a>条款02：尽量以<code>const</code>、<code>enum</code>、<code>inline</code>替换 <code>#define</code></h3><p>这个条款或许改为 ：宁可以编译器替换预处理器 比较好。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_PATIO 1.653</span></span><br></pre></td></tr></table></figure>

<p>记号名称 <code>ASPECT_PATIO</code>也许从未被编译器看见。当你运行此常量但是获得一个编译错误信息时，可能会带来困惑，因为这个错误信息也许会提到 1.653 而不是<code>ASPECT_PATIO</code>。</p>
<p>解决之道是以一个常量替换上述的宏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br></pre></td></tr></table></figure>

<p>作为一个语言常量，<code>AspectRatio</code>肯定会被编译器看到。</p>
<p>值得说明的是，如果在头文件内定义一个常量的<code>char*-based</code>字符串，必须写<code>const</code>两次。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const char* const authorName = &#x27;Scott Meyers&#x27;;</span><br></pre></td></tr></table></figure>

<p><code>string</code>对象通常比其前辈<code>char*-based</code>合宜，所以一般使用下述定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第二个值得注意的是<code>class</code>专属常量，为了将常量的作用域限制于<code>class</code>内，必须让它成为<code>class</code>的一个成员，而为确保常量至多只有一份实体，必须让它成为一个<code>static</code>成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; </span><br><span class="line">    	<span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">    	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无法使用<code>#define</code>创建一个<code>class</code>专属常量，因为<code>#define</code>并不重视作用域，一旦宏被定义，它就在其后的编译过程中有效（除非在某处<code>#undef</code>）。这意味着<code>#define</code>不仅不能够用来定义<code>class</code>专属常量，也不能够提供任何封装性，也就是说没有所谓<code>private #define</code>这样的东西存在。</p>
<p>当然也可以通过枚举实现，其理论依据是：“一个枚举类型的数值可权充<code>ints</code>被使用”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="class"><span class="keyword">enum</span> &#123;</span> NumTurns = <span class="number">5</span>&#125;; </span><br><span class="line">    	<span class="comment">//&quot;the enum hack&quot; 令NumTurns 成为5的一个记号名称</span></span><br><span class="line">    	<span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enum hack</code>的行为某方面说比较像 <code>#define</code>而不像<code>const</code>，例如，取一个<code>const</code>的地址是合法的，但取一个<code>enum</code>的地址就不合法了。</p>
<p> 认识<code>enum</code>是<code>template metaprogramming</code>(模板元编程)的基础技术。</p>
<p>另一个常见的<code>#define</code>误用情况是以它实现宏。宏看来是像是函数，但不会招致函数调用带来的额外开销。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p>这般长相的宏有着太多缺点，光是想到它们就让人痛苦不堪。而且无论</p>
<p>何时当你写出这种宏，你必须记住为宏中的所有实参加上小括号。但是，仍然会发生不可思议的事情：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b); <span class="comment">//a被累加二次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>); <span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>a</code>的递增次数竟然取决于“它被拿来和谁比较”！</p>
<p>幸运的是，通过<code>template inline</code>便可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用<code>const</code></h3><p><code>const</code>语法虽然变幻多端，但并不高深莫测。如果关键字<code>const</code>出现在星号左边，表示被指物是常量；如果出现在右端，表示指针自身是常量；如果出现在星号两端，表示被指物和指针两者都是常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting; <span class="comment">//常量被指物</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">//常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 常量被指物，常量指针</span></span><br></pre></td></tr></table></figure>

<p>下列两种函数接受的参数类型是一样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget <span class="keyword">const</span> *pw)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>STL</code>模拟一个<code>const T*</code>指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin(); </span><br><span class="line"><span class="comment">//iter 的作用相当于 T* const</span></span><br><span class="line"><span class="built_in">std</span>::vertor&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin();</span><br><span class="line"><span class="comment">//cTter的作用相当于 const T*</span></span><br></pre></td></tr></table></figure>



<p><strong><code>const</code>成员函数</strong></p>
<p>两个成员函数如果只是常量性不同，可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> </span><br><span class="line">    &#123;<span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) </span><br><span class="line">    &#123;<span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator[] 可以被这么调用</span></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];	<span class="comment">//调用non-const版本</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">//调用const版本</span></span><br></pre></td></tr></table></figure>

<p>数据常量性还有另一个局限性，例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">sizt_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!lengthIsValid)&#123;                      </span><br><span class="line">      <span class="comment">//错误，在const成员函数内不能赋值给 textLength 和 lengthIsValid</span></span><br><span class="line">    TextLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);         </span><br><span class="line">    lengthValid = <span class="literal">true</span>;                   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TextLength;                         <span class="comment">//这行才是代码核心</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法很简单，利用<code>C++</code>的一个与<code>const</code>相关的摆动场：<code>mutable</code>（可变的）；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br></pre></td></tr></table></figure>



<p><strong>在<code>const</code>和<code>non-const</code>成员函数中避免重复</strong></p>
<p>问题出在如果<code>const</code>和<code>non-const operator[]</code>中代码的长度很长，会导致整个程序过长。</p>
<p>就一般守则而言，转型是一个糟糕的想法。然而代码重复也不是什么令人愉快的经验。在本例中，<code>const</code>完全做掉了<code>non-const</code>版本该做的一切，所以令<code>non-const</code>调用其<code>const</code>兄弟是一个避免代码重复的安全做法——即使过程中需要一个转型动作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一如既往</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;&#123;	<span class="comment">//将op[]返回值的const移除</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) <span class="comment">//为*this加上const</span></span><br><span class="line">                [position]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面共有两次转型操作。</p>
<blockquote>
<p>值得注意的是，令<code>const</code>版本调用<code>non-const</code>版本以避免重复的操作是危险的。</p>
</blockquote>
<h3 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h3><p>对于构造函数，规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p>
<p>重要的是，别混淆了赋值和初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span>&#123;</span>...&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones)</span><br><span class="line">&#123;</span><br><span class="line">	theName = name;       <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address; <span class="comment">//而非初始化</span></span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ABEntry</code>构造函数的一个较佳写法是，使用所谓的<code>member initialization list</code>（成员初始值）代替赋值动作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;address,</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; &amp;phones):</span><br><span class="line">	theName(name),       <span class="comment">//</span></span><br><span class="line">    theAddress(address), <span class="comment">//现在这些都是初始化</span></span><br><span class="line">    thePhones(phones),</span><br><span class="line">    numTimesConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造函数和上一个的最终结果相同，但通常效率较高。基于赋值的那个版本首先调用了<code>default</code>构造函数为变量赋值，然后立刻再对它们赋予新值，<code>default</code>构造函数的一切作为因此浪费了。</p>
<p><strong>不同编译单元内定义之<code>non-local static</code>对象的初始化次序</strong></p>
<p>所谓<code>static</code>对象，其寿命从被构造出来直到程序结束为止。因此，<code>stack</code>和<code>heap-based</code>对象都被排除。这种对象包括<code>global</code>对象、定义于<code>namespace</code>作用域内的对象、在<code>class</code>以及函数内的<code>static</code>独享。函数内的对象被称为<code>local static</code>对象，其他称为<code>non-local static</code>对象。两者的区别在于对于<code>local static</code>对象，在其所属的函数被调用之前，该对象并不存在，即只有在第一次调用对应函数时，<code>local static</code>对象才被构造出来。而对于<code>non-local static</code>对象，在<code>main()</code>函数开始前就已经被构造出来，并在<code>main()</code>函数结束后被析构。</p>
<p>所谓编译单元，是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入的头文件。</p>
<p><strong>真正的问题</strong>是：如果某编译单元内的某个<code>non-local static</code>对象的初始化动作使用了另一编译单元内的某个<code>non-local static</code>对象，它所用到的这个对象可能尚未被初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	...</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//成员函数之一</span></span><br><span class="line">    	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSyetem tfs; <span class="comment">//预留给客服使用的对象，仅声明不定义</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里稍微介绍一下<code>extern</code>，它的作用是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!</p>
<p><strong>凡是没有带extern的声明同时也都是定义</strong>。而对函数而言，带有{}是定义，否则是声明。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，且不要显式的初始化变量。</p>
</blockquote>
<p><code>tfs</code>如果在对象构造完之前就使用它，会得到惨痛的灾情。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Director::Director(params)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks(); <span class="comment">//使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进一步假设</span></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>; </span><br></pre></td></tr></table></figure>

<p>现在，初始化次序的重要性显现出来了：除非<code>tfs</code>在<code>temDir</code>之前先被初始化，否则会出现错误。但是我们无法确定<code>tfs</code>会在<code>tempDir</code>之前被初始化。</p>
<p>幸运的是一个小小的设计便可以消除这个问题，唯一要做的是：将每个<code>non-local static</code>对象搬运到自己的专属函数内，这些函数返回一个<code>reference</code>指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说：**<code>non-local static</code>对象被<code>local static</code>对象替换了。**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">  <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Director::Director&#123;params&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Director &amp;<span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Director td;</span><br><span class="line">  <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改之后，区别在于我们使用函数返回的指向<code>static</code>对象的<code>references</code>，而不再使用<code>static</code>对象自身。</p>
<blockquote>
<p>任何一种<code>non-const static</code>对象，无论它是<code>local</code>或<code>non-local</code>，在多线程环境下“等待某事发生”都会有麻烦，处理这个麻烦的一种做法是：在程序的单线程启动阶段手工调用所有<code>referenece-returning</code>函数，这可消除与初始化有关的“竞速形势”。</p>
</blockquote>
<h2 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2 构造/析构/赋值运算"></a>2 构造/析构/赋值运算</h2><h3 id="条款05：了解C-摸摸编写并调用了哪些函数"><a href="#条款05：了解C-摸摸编写并调用了哪些函数" class="headerlink" title="条款05：了解C++摸摸编写并调用了哪些函数"></a>条款05：了解C++摸摸编写并调用了哪些函数</h3><p>当我们定义了一个类，如果自己没声明，编译器就会为它声明一个<code>copy</code>构造函数、一个<code>copy assignment</code>操作符和一个析构函数，此外也会声明一个<code>default</code>构造函数。所有这些函数都是<code>public</code>且<code>inline</code>。</p>
<blockquote>
<p>注意，编译器产出的析构函数是个<code>non-virtual</code>，除非这个<code>class</code>的<code>base class</code>自身声明有<code>virtual</code>析构函数，这种情况下，这个函数的虚属性，主要来自于<code>base class</code>。</p>
</blockquote>
<p>至于<code>copy</code>构造函数和<code>copy assignment</code>操作符，编译器创建的版本只是单纯地将来源对象的每一个<code>non-static</code>成员变量拷贝到目标对象。</p>
<p>但是要注意的是，如果打算在一个<strong>内含<code>reference</code>成员</strong>的<code>class</code>内支持赋值操作，必须自己定义<code>copy assignment</code>操作符。同理，应用于<strong>内含<code>const</code>成员</strong>的<code>class</code>。</p>
<p>最后还有一种情况，如果某个<code>base classes</code>将<code>copy assignment</code>操作符声明为<code>private</code>，编译器将拒绝为其<code>derived classes</code>生成一个<code>copy assignment</code>操作符。</p>
<h4 id="virtual-关键字"><a href="#virtual-关键字" class="headerlink" title="virtual 关键字"></a>virtual 关键字</h4><p>在这为了加深印象，添加了一段关于<code>virtual</code>关键字的理解。</p>
<p><code>Virtual</code>关键字的一个重要概念 **”只有在通过基类指针或引用间接指向派生类子类型时多态性才会起作用”**，也就是说，基类的函数调用如果有virtual则根据多态性调用派生类的，如果没有virtual则是正常的静态函数调用，还是调用基类的。</p>
<p>下面这个代码很能体现对这句话的理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f(float) &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g(float) &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h(float) &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::f(float) &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::g(int) &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::h(float) &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base *pb = &amp;d;</span><br><span class="line">Derived *pd = &amp;d;</span><br><span class="line"><span class="comment">// Good : behavior depends solely on type of the object</span></span><br><span class="line">pb-&gt;f(<span class="number">3.14f</span>); <span class="comment">// Derived::f(float) 3.14</span></span><br><span class="line">pd-&gt;f(<span class="number">3.14f</span>); <span class="comment">// Derived::f(float) 3.14</span></span><br><span class="line"><span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">pb-&gt;g(<span class="number">3.14f</span>); <span class="comment">// Base::g(float) 3.14</span></span><br><span class="line">pd-&gt;g(<span class="number">3.14f</span>); <span class="comment">// Derived::g(int) 3 (surprise!)</span></span><br><span class="line"><span class="comment">// Bad : behavior depends on type of the pointer</span></span><br><span class="line">pb-&gt;h(<span class="number">3.14f</span>); <span class="comment">// Base::h(float) 3.14 (surprise!)</span></span><br><span class="line">pd-&gt;h(<span class="number">3.14f</span>); <span class="comment">// Derived::h(float) 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>pd</code>和<code>pb</code>两个指针虽然指向同一个对象，但是在调用成员函数时，一个调用的是基类的函数，一个调用的是继承类的函数，只有带<code>virtual</code>关键字的函数，两个指针才返回同样的结果。</p>
<blockquote>
<p>默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型。</p>
</blockquote>
<p>下面简要介绍<code>virtual</code>关键字的几个特征。</p>
<p><strong>静态函数不可以声明为虚函数，同时也不能被<code>const</code> 和 <code>static</code>关键字修饰。</strong></p>
<p>这是因为<code>static</code>成员函数不属于任何类对象或类实例，所以即使给此函数加上<code>virutal</code>也是没有任何意义</p>
<p><strong>构造函数不可以声明为虚函数。同时除了<code>inline</code>之外，构造函数不允许使用其它任何关键字。</strong></p>
<p><strong>析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。事实上，只要一个类有可能会被其它类所继承，就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。</strong></p>
<p>当涉及到指针引用时，继承类的析构函数没有被调用，delete时只根据指针类型调用了基类的析构函数。正确的操作是，基类和继承类的析构函数都应该被调用，解决方法是<strong>将基类的析构函数声明为虚函数</strong>。</p>
<p><strong>虚函数可以被私有化，但有一些细节需要注意。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base Fun&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived Fun&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Base *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">   ptr-&gt;fun();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：Derived fun()</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是：</p>
<ul>
<li>基类指针指向继承类对象，则调用继承类对象的函数；</li>
<li><code>int main()</code>必须声明为<code>Base</code>类的友元，否则编译失败。编译器报错：<code>ptr</code>无法访问私有函数。 当然，把基类声明为<code>public</code>， 继承类为<code>private</code>，该问题就不存在了。</li>
</ul>
<p><strong>通常类成员函数都会被编译器考虑是否进行内联。 但通过基类指针或者引用调用的虚函数必定不能被内联。 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。</strong> (这个我还没有完全理解)</p>
<p>简要接受一下内联函数：</p>
<p><strong>内联函数inline：</strong>引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<ul>
<li>1.在内联函数内不允许使用循环语句和开关语句；</li>
<li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li>
<li>3.类结构中所在的类说明内部定义的函数是内联函数。</li>
</ul>
<p><strong>纯虚函数：</strong>在基类中声明但不定义的虚函数，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加<code>“=0”</code>，如<code>virtual void funtion1()=0</code>；</p>
<p><strong>抽象类：</strong>含有纯虚函数的类为抽象类。</p>
<h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>这一条款主要想说明，很多时候，我们不希望定义的类被其他人去拷贝，但是类的<code>copy</code>构造函数和<code>copy assignment</code>操作符会被类自动定义。</p>
<p>第一个方法是：将<code>copy</code>构造函数和<code>copy assignment</code>操作符声明为<code>private</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeforSale</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">        HomeforSale(<span class="keyword">const</span> HomeforSale&amp;); <span class="comment">//只有声明</span></span><br><span class="line">    	HomeforSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeforSale&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面没写函数参数的名字，这是因为它并非必要。</p>
<p>一般而言，这种做法并不绝对安全，因为<code>member</code>函数和<code>friend</code>函数还是可以调用<code>private</code>函数。</p>
<p>另一种做法是在一个专门为了阻止<code>copying</code>动作而设计的<code>base class</code>内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	Uncopyable()&#123;&#125;</span><br><span class="line">    	~Uncopyable()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);	<span class="comment">//阻止copy行为</span></span><br><span class="line">    	Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeforSale</span>:</span><span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只要任何人——甚至是<code>member</code>函数或<code>friend</code>函数，尝试拷贝<code>Homeforsale</code>对象，他们就会尝试调用其<code>base class</code>的拷贝函数，但是这些调用会被编译器拒绝，因为其是<code>private</code>。</p>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明<code>virtual</code>析构函数</h3><p>许多时候，我们的函数会返回一个基类指针，指向继承类。</p>
<p>当继承类对象经由一个基类指针被删除，而该基类带着一个<code>non-virtual</code>析构函数。实际执行时通常发生的是对象的继承类成分没有被销毁。这样就会造成一个局部销毁的问题。</p>
<p>消除这个问题的做法很简单，给<code>base class</code>一个<code>virtual</code>析构函数。此后删除<code>derived class</code>对象就会和你想要的那般。它会销毁整个对象，包括所有<code>derived class</code>成分。</p>
<p>当<code>class</code>不企图被当作<code>base class</code>，令其析构函数为<code>virtual</code>往往是个馊主意。</p>
<p>这是因为欲实现出<code>virtual</code>函数，对象必须携带某些信息。这份信息通常是由一个所谓<code>vptr(virtual table pointer)</code>指针指出。<code>vptr</code>指向一个由函数指针构成的数组，称为<code>vtbl</code>；每个带有<code>virtual</code>函数的类都有这样一个数组，当对象调用某一<code>virtual</code>函数，实际被调用的函数取决于该对象的<code>vptr</code>所指向的那个<code>vtbl</code>——编译器在其中寻找合适的函数指针。</p>
<p>这样会导致对象的体积增加。而且不再可能把它传递给其他语言所写的函数。</p>
<blockquote>
<p>因此，只有当<code>class</code>内含有至少一个<code>virtual</code>函数时，才为它申明<code>virtual</code>析构函数。</p>
</blockquote>
<p>标准<code>string</code>不含有<code>virtual</code>函数，所以我们不应该把它当做基类。相同的分析适用于<code>vector,list,set,unordered_map</code>等等。</p>
<p><strong>抽象类和纯虚函数</strong></p>
<p>有的时候我们希望有抽象类，但是手上没有任何<code>pure virtual</code>函数，怎么办？</p>
<p>方法很简单，为抽象的那个<code>class</code>声明一个<code>pure virtual</code>析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是：必须为这个<code>pure virtual</code>析构函数提供一份定义。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AWOV::~AWOV() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>析构函数的运作方式是，最深层派生的那个<code>class</code>其析构函数最先被调用，然后是其每一个<code>base class</code>的析构函数被调用。编译器会在<code>AWOV</code>的继承类的析构函数中创建一个对<code>~AWOV</code>的调用动作。所以必须提供一份定义。</p>
<h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><ul>
<li>析构函数绝对不要吐出异常。如果一个析构函数内调用的函数可能抛出异常，析构函数应该捕捉任何出现的异常，然后选择吞下它们或结束程序，别让异常逃离析构函数。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）,让客户自己去调用该操作函数，给客户一个处理错误的机会。</li>
</ul>
<p>首先，定义两个类分别负责数据库连接以及该类资源的管理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该类负责数据库的连接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;    <span class="comment">// 静态成员函数，建立一个DBConnection对象</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类负责类DBConnection的资源管理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ~DBConn() &#123;    <span class="comment">// 析构函数确保数据库连接总是会被关闭</span></span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，客户可以写出如下代码以管理数据库连接：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">     <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码结束时，会自动调用~DBConn()，如果close调用成功,那最好，如果close调用失败，那么DBConn析构函数就会传播该异常，即允许异常离开这个析构函数，会造成问题。</p>
<p>两个办法可以避免这个问题：</p>
<ol>
<li><p>如果close抛出异常就结束程序，通常通过调用abort完成。</p>
</li>
<li><p>吞下close抛出的异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		db.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		<span class="comment">//记下对close的调用失败</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		db.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		<span class="comment">//记下对close的调用失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>一般而言，吞掉异常是个坏主意，因为它压制了“某些动作失败”的重要信息。</p>
<p>更好的方法是将<code>close</code>的执行移交给用户，由客户自己调用<code>close</code>，然后再在析构函数中<code>try and catch</code>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改后的DBConn类实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;    <span class="comment">// 要求用户自己关闭数据库对象</span></span><br><span class="line">        db.close();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ~DBConn() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;    <span class="comment">// 如果用户忘记了这么做，就采用 try catch 机制吞下异常。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                db.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">                <span class="comment">// 记录此次 close 失败</span></span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;    <span class="comment">// 增设此变量用以判断用户是否已经自行调用 close()，用户也可根据此变量判断 close() 是否顺利执行并作出相应的异常处理。</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="条款09：绝不在构造和析构过称中调用virtual函数"><a href="#条款09：绝不在构造和析构过称中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过称中调用virtual函数"></a>条款09：绝不在构造和析构过称中调用<code>virtual</code>函数</h3><blockquote>
<p>在构造或析构期间不要调用 virtual函数，因为这样的调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。</p>
</blockquote>
<p>假设你有一套模拟股票交易的类继承体系，例如，购入、出售订单等。这样的交易一定要经过审计，所以每一个交易对象被创建，在一个审查日志中就需要创建一个相应的条目。下面是一个看起来似乎合理的解决问题的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span> <span class="comment">// 所有交易的基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Transaction();</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 做出一份因类型不同而不同的日志记录</span></span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Transaction::Transaction() <span class="comment">// 基类构造函数之实现</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     logTransaction(); <span class="comment">// 最后动作是志记这笔交易</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123; <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;<span class="comment">// derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">      ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题出现在，一个<code>BuyTransaction</code>构造函数被调用，但首先<code>Transaction</code>构造函数一定会被更早调用：这时候调用的<code>logTransaction</code>是基类的版本，即使现在创建的对象是继承类。</p>
<p>显然这里调用了<code>BuyTransaction</code>的构造函数。但因为在C++中，当子类开始构造时，它所包含的父类的部分要先完成构造，所以率先调用的构造函数是它的父类<code>Transaction</code>的构造函数。现在问题来了，因为父类的构造函数调用了一个<strong>纯虚函数</strong>，这就会导致即使你创建的是它的子类对象，这个虚函数也不会绑定到子类的版本上，而是使用的父类版本。</p>
<p>这就”有悖常理”了，虚函数不是会<strong>自动</strong>绑定到继承层级里对应的一个类吗？其实C++这样做是有一个很好的原因的。我们在条款04讲过，使用未初始化的数据可能会给程序带来风险。因为在创建一个子类对象时，它的父类部分会先被创建。当父类的构造函数刚刚调用完成时，我们只能保证父类部分的数据被初始化，而不能保证衍生部分的被初始化。如果现在让这个虚函数去对应子类的版本，就可能会因为使用未初始化的数据而导致程序<strong>运行时错误</strong>。</p>
<p>事实上，正是由于这个原因，当一个子类对象在完成它自己全部成员的构造之前，C++只会把它当成父类，除了虚函数还包括<code>typeid</code>，<code>dynamic_cast</code>等，都会把当前对象当做父类，用来规避使用未初始化数据可能带来的风险。</p>
<p>在构造或析构期间调用<code>virtual</code>函数的问题并不总是如此容易被察觉，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Transaction()</span><br><span class="line">     &#123; init(); &#125; <span class="comment">// 调用non-virtual...</span></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">     ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction(); <span class="comment">// 这里调用virtual!</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即使<code>init()</code>函数有定义而且不是虚函数，它却调用了没有定义的纯虚函数<code>logTransaction()</code>，这就会导致在运行过程中，一旦使用了这里的代码，程序就会崩溃。</p>
<p>这两个代码的问题相同，但是第二种比较潜藏并且暗中为害。</p>
<p>如何保证继承类的对象被创建是，会有适当版本的<code>logTransaction()</code>被调用？</p>
<p>将<code>Transaction</code>中的<code>logTransaction</code>转变为一个 <code>non-virtual</code>函数，然后要求派生类构造函数将必要的信息传递给 <code>Transaction</code> 构造函数，而后那个函数就可以安全地调用 <code>non-virtual</code>的 <code>logTransaction</code>。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span></span>;</span><br><span class="line"> </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(conststd::<span class="built_in">string</span>&amp; logInfo)</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// 如今是个non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo); <span class="comment">//如今是个non-virtual函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction( parameters )</span><br><span class="line">    : Transaction(createLogString( parameters))</span><br><span class="line">    &#123; ... &#125; <span class="comment">// 将log信息传递给基类构造函数</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    换句话说，由于你不能在基类的构造过程中使用<code>virtual</code>函数向下调用，你可以改为让派生类将必要的构造信息上传给基类构造函数作为补偿。</p>
<p>​    在此例中，注意 <code>BuyTransaction</code>中那个 <code>private static</code> 函数 <code>createLogString</code> 的使用。使用一个辅助函数创建一个值传递给基类构造函数，通常比通过在成员初值列给基类它所需数据更加便利（也更加具有可读性）。将那个函数设置为<code>static</code>，就不会有偶然触及到一个新生的 <code>BuyTransaction</code> <code>object</code>对象的仍未初始化的数据成员的危险。</p>
<blockquote>
<p>总结：不要在构造函数或者析构函数中调用虚函数，因为这样的虚函数只会对应起来当前构造或析构的类，不会上升到它的任何子类。</p>
</blockquote>
<h3 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令<code>operator=</code>返回一个<code>reference to *this</code></h3><p>关于赋值，可以把它写成连锁形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">x = y = z = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<p>为了实现“连锁赋值”，赋值操作一般返回一个<code>reference</code>指向操作符的左侧实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这只是个协议，并无强制性，如果不遵守它，代码一样可以通过编译，然后这份协议被所有内置类型和标准程序库的类型（<code>string,vector,complex,trl::shared_ptr</code>）共同遵守。</p>
<blockquote>
<p>总结，令赋值操作符返回一个<code>reference to *this</code>。</p>
</blockquote>
<h3 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator=中处理自我赋值"></a>条款11：在<code>operator=</code>中处理自我赋值</h3><p>自我赋值发生在对象被赋值给自己时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;</span><br></pre></td></tr></table></figure>

<p>上述情况比较明显，下列情况可就不容易被一眼看出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[i] = a[j];</span><br><span class="line">*px = *py;</span><br></pre></td></tr></table></figure>

<p>如果两个对象来自于同一个继承体系，它们甚至不需声明为相同类型就可能造成不明显的自我赋值，因为一个<code>base class</code>的<code>reference</code>或<code>pointer</code>可以指向一个<code>derived class</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> Base&amp; rb, Derived* pd)</span></span>;</span><br><span class="line"><span class="comment">//rb 和*pd可能是同一对象</span></span><br></pre></td></tr></table></figure>

<p>这样的问题会导致“在停止使用资源之前意外释放了它的问题”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">delete</span> pb;</span><br><span class="line">  pb = <span class="keyword">new</span> Bitmap(*rhs.bp);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>*this</code>和<code>rhs</code>是同一对象，会发生这样的错误，<code>pd</code>指向一个已经被删除的对象。</p>
<p>欲阻止这样的错误，传统的做法是加一个“证同测试”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)             <span class="comment">//先做一个身份检测</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> pb;                   <span class="comment">//如果不是自己，再执行如下操作</span></span><br><span class="line">  pb = <span class="keyword">new</span> Bitmap(*<span class="keyword">this</span>.pb);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本仍存在异常方面的麻烦，如果<code>new Bitmap</code>导致异常，<code>Wiget</code>最终会持有一个指针指向一块被删除的<code>Bitmap</code>。因此我们来看一个更好的解决方法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">  Bitmap *pOrigin = pb;            <span class="comment">//先保存一个原pb的备份</span></span><br><span class="line">  pb = <span class="keyword">new</span> Bitmap(*<span class="keyword">this</span>.pb);       <span class="comment">//拷贝过来rhs的pb</span></span><br><span class="line">  <span class="keyword">delete</span> pOrigin;                  <span class="comment">//只删除备份</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这条解决方法既对自赋值安全，对异常也是安全的。如果现在<code>new</code>的这行抛出了异常，指针<code>pb</code>也不会被提前删除。同时这样的语句排列省去了上一条解决方法身份检测的步骤，因为即使传入的<code>rhs</code>是<code>*this</code>本身，最后删除的也只是备份而不是<code>*this</code>自己的<code>pb</code>。</p>
<p>另一个替代方案是所谓的<code>copy and swap</code>技术，这个技术和“异常安全性”有密切关系，将在条款29详细说明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">   ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;   <span class="comment">//把rhs和*this的数据成员互相调换</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">  Widget temp(rhs);       <span class="comment">//拷贝rhs</span></span><br><span class="line">  swap(temp);             <span class="comment">//将*this的数据与这个拷贝的数据调换</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用和上一个方法相似的思路，也是相当于生成一份拷贝，再把这份拷贝复制进<code>*this</code>中。</p>
<p>还有另一种形式，巧妙利用了<code>C++</code>传值会自动生成一份本地拷贝的特性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">Widget::operator</span><span class="params">(Widget rhs)</span></span>&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<ul>
<li>赋值操作符要考虑到自赋值，使用参数身份检测，排列语句，先拷贝再调换的方法来确保代码是自赋值安全的。</li>
<li>同样当一个函数使用多个参数时，也要确保函数能在这些参数同时指向同一个对象时可以工作正常。</li>
</ul>
</blockquote>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><p>设计良好之面向对象系统(<code>OO-systems</code>)会将对象的内部封装起来，只留两个函数负责对象拷贝(复制)。</p>
<p>C++有两种<strong>拷贝函数</strong>(copying function): <strong>拷贝构造函数</strong>(copy constructor)和<strong>拷贝赋值操作符</strong>(copy assignment operator)。在条款05我们讲到过，如果在自己定义的类中不声明这些拷贝函数，编译器会自动为你生成。如果我们声明了自己的拷贝函数，程序将会执行我们自己的拷贝函数。我们来看一个栗子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logCall</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; funcName)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs):name(rhs.name)&#123;   <span class="comment">//使用初始化列表</span></span><br><span class="line">  logCall(<span class="string">&quot;Customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">  logCall(<span class="string">&quot;Customer copy assignment operator&quot;</span>);</span><br><span class="line">  name = rhs.name;    <span class="comment">//拷贝数据</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//返回*this，见第10章</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上我们定义了<code>Customer</code>类的构造函数(使用了初始化列表)和拷贝赋值操作符，这些代码是没有问题的。可是直到我们新增了一个数据成员:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cutomer</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Data lastTransaction;     <span class="comment">//新增了一个交易日期的数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们依然使用相同的两种拷贝函数，那么我们只能得到一个<strong>部分拷贝</strong>的对象(<code>partial copy</code>)，我们只能拷贝到name而不能拷贝到<code>lastTransaction</code>。</p>
<p><strong>解决方法:</strong></p>
<p>很简单很直接，当我们的类新增数据成员时，要保证拷贝函数也要照顾到新来的同志们。</p>
<p>部分拷贝更可能潜在发生的地方是继承层级中，假设我们在普通用户之上定义一个VIP用户:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span> :</span> <span class="keyword">public</span> Customer&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">  <span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  :priority(rhs.prority)&#123;           <span class="comment">//使用初始化列表来构造该类的数据成员</span></span><br><span class="line">  logCall(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">  logCall(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">  priority = rhs.priority;          <span class="comment">//拷贝该类的数据成员</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码看起来像是拷贝了所有的数据成员，但是却忘记了它的基类部分！如果我们不传入基类对象作为子类构造函数的参数，当构造这个子类的时候，它的基类的<strong>默认</strong>构造函数将会被调用，结果就是，基类<code>Customer</code>的<code>name</code>等数据成员被设定为了默认值，那么全体VIP用户的数据就丢失了（人家充了钱反而号被你搞丢了）</p>
<p>我们再来看赋值操作符，赋值操作符同样没有把基类作为传进来的参数，因此当拷贝某对象时，它的基类部分也不会被拷贝进来，所以这样的代码同样会导致一个部分拷贝。</p>
<p><strong>解决方法:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">  : priority(rhs.prority), Customer(rhs)&#123;     <span class="comment">//要把基类部分也添加进初始化列表</span></span><br><span class="line">  logCall(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">  logCall(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">  Customer::<span class="keyword">operator</span>=(rhs);         <span class="comment">//要使用基类的拷贝操作符</span></span><br><span class="line">  priority = rhs.priority; </span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一章讨论的是完整拷贝的问题，但一般我们也要考虑到操作符的异常安全性(<code>exception safety</code>)，所以需要结合条款12讨论的的异常安全性，例如使用先拷贝再调换(<code>copy and swap</code>)的思路，来实现万全的拷贝赋值功能。</p>
<p>可能大家也会发现，C++的这两种拷贝函数有相似的功能和代码，那么我们能不能避免代码重复，让其中一个拷贝函数调用另一个呢？答案是<strong>不能</strong></p>
<p>使用拷贝赋值操作符调用拷贝构造函数，或者使用拷贝构造函数调用拷贝赋值操作符，都是没有意义的。拷贝赋值操作符适用于已经构造好的对象，而拷贝构造函数适用于还没有构造好的对象，所以这种做法在语义上是错误的。</p>
<p>如果我们真的想要节省代码，比如某个类有特别多的数据成员，我们可以写另一个函数用来给每个成员赋值，两个拷贝函数都可以调用，这个函数一般叫<code>init()</code>。</p>
<blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>拷贝函数要照顾到类的所有部分，包括所有的数据成员和它的基类部分</li>
<li>不要用一个拷贝函数来实现另一个拷贝函数，两种拷贝函数的语义不同。如果要节省代码，可以另写一个<code>init()</code>函数让两个拷贝函数来调用。</li>
</ul>
</blockquote>
<h2 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理</h2>]]></content>
  </entry>
</search>
